Directory = {}

Directory.find_file_memory = [];
Directory.find_file = function(file_obj, file_path = 0, file_name = 0, return_all = 0, is_first_pass = 1)
    if is_first_pass then 
        if file_path == "" then file_path = "/"
        find_file_memory = []
        is_first_pass = 0 
    end if 

    if tp(file_path) == "string" and file_path == "/" then return file_obj
    if tp(file_path) == "string" and file_path[0] != "/" then file_path = "/" + file_path
    if tp(file_path) == "string" and file_path[-1] == "/" then file_path = path[:-1]
    if tp(file_path) == "string" then file_path = file_path.lower
    if tp(file_name) == "string" then file_name = file_name.lower

    target_file = false

    for object in file_obj.get_folders + file_obj.get_files
        if tp(object) != "file" then continue
        if not return_all and tp(target_file) == "file" then 
            self.find_file_memory = []
            return target_file
        end if 
        
        if return_all and [file_path, file_name] == [0, 0] then 
            self.find_file_memory.push([object, object.name, object.get_content, {"is_folder": object.is_folder, "is_binary": object.is_binary}, object.size, object.permissions, object.owner, object.group])
            continue 
        end if 

        if (return_all and tp(file_name) == "string") and object.name.lower.search(file_name.lower) then 
            self.find_file_memory.push([object, object.name, object.get_content, {"is_folder": object.is_folder, "is_binary": object.is_binary}, object.size, object.permissions, object.owner, object.group])
            continue
        end if 

        if (tp(file_path) == "string" and not return_all) and object.path.lower == file_path.lower then 
            target_file = object 
            continue
        end if 
        
        if (tp(file_name) == "string" and not return_all) and object.name.lower.search(file_name.lower) then 
            target_file = object 
            continue
        end if 

        if ([file_path, file_name, return_all] == [0, 0, 0]) then 
            self.find_file_memory.push([object, object.name, object.path, object.get_content, {"is_folder": object.is_folder, "is_binary": object.is_binary}, object.size, object.permissions, object.owner, object.group])
        end if 

        if object.is_folder then target_file = self.find_file(object, file_path, file_name, return_all, is_first_pass)
    end for 

    if ([file_path, file_name, return_all] == [0, 0, 0]) or return_all then return self.find_file_memory
    self.find_file_memory = [] 
   
    return target_file
end function

Directory.validate_file = function(root_file, cmd_name, param_token, only_folders = 0, all = 0)
    param_token_value = param_token[0].value
    param_token_type = param_token[0].type
    target_file = false
    
    is_keyword = true 
    if param_token_value.split("/").len > 1 then is_keyword = false
  
    if not tp(root_file) == "file" then return _callback.catch("[blbx][" + cmd_name + "][err]: remote session has no file objects...")
    
    if is_keyword then 
        if all then 
            target_file_arr = Directory.find_file(root_file, 0, param_token_value, 1)
            if not target_file_arr.len then return _callback.catch("[blbx][" + cmd_name + "][err]: could not find any matches for keyword '" + param_token_value + "'...")
            return _callback.catch(target_file_arr, 1)
        end if 
        target_file = Directory.find_file(root_file, 0, param_token_value)
        if not tp(target_file) == "file" then return _callback.catch("[blbx][" + cmd_name + "][err]: could not find target file by name...")
        if not target_file.is_folder and only_folders then return _callback.catch("[blbx][" + cmd_name + "][err]: object must be a folder...")

        return _callback.catch(target_file, 1)
    end if

    target_file = Directory.find_file(root_file, param_token_value)
    if not tp(target_file) == "file" then return _callback.catch("[blbx][" + cmd_name + "][err]: could not find target file by name...")
    if not target_file.is_folder and only_folders then return _callback.catch("[blbx]["+cmd_name+"][err]: object must be a folder...")

    return _callback.catch(target_file, 1)
end function 


Session = {}

Session.process = {}

Session.process.safe_run = function(cmd_name, parameters, data = 0)
    if tp(command.indexes.indexOf(cmd_name)) != "number" then return false
    command_syntax_proxy = command[cmd_name]
    return command_syntax_proxy(parameters)
end function

Session.process.internal_run = function(cmd_name, paramters_str = 0, data = 0)
    if not paramters_str then 
        parameters = [] 
    else 
        Parser.reset()
        parameters = Parser.ParseCLI(cmd_name + " " + paramters_str)[0].params
    end if
    //_callback.local_debug("<color=red>" + parameters, "parameters", 103)
    return self.safe_run(cmd_name, parameters, data)
end function    

Session.process.status = true
Session.process.connected = false

Session.process.is_running = function()
    return self.status
end function 

Session.process.set_status = function(new_status)
    self.status = new_status
    return self.status
end function

Session.process.is_connected = function()
    return self.connected
end function 

Session.process.set_connected = function(new_connected)
    self.connected = new_connected
    return self.status
end function

Session.env = {}

Session.env.var = {"body": {}}

Session.env.var.has = function(variable_name)
    return self.body.hasIndex(variable_name)
end function

Session.env.var.get = function(variable_name)
    if not self.has(variable_name) then return false 
    return self.body[variable_name]
end function

Session.env.var.set = function(variable_name, new_value) 
    self.body[variable_name] = new_value
end function

Session.env.var.rm = function(variable_name)
    if not self.has(variable_name) then return false 
    self.body[variable_name].delete 
    return true 
end function 

Session.env.macro = {"body": {}}

Session.env.macro.has = function(macro_name)
    return self.body.hasIndex(macro_name)
end function

Session.env.macro.get = function(macro_name)
    if not self.body.has(macro_name) then return false 
    return self.body[macro_name]
end function

Session.env.macro.set = function(macro_name, new_value) 
    self.body[macro_name] = new_value
end function

Session.env.macro.rm = function(macro_name)
    if not self.has(macro_name) then return false 
    self.body[macro_name].delete 
    return true 
end function 

Session.env.global_flag = {"body": {}}

Session.env.global_flag.has = function(global_flag_name)
    return self.body.hasIndex(global_flag_name)
end function

Session.env.global_flag.get = function(global_flag_name)
    if not self.body.has(global_flag_name) then return false 
    return self.body[global_flag_name]
end function

Session.env.global_flag.set = function(global_flag_name, new_value) 
    self.body[global_flag_name] = new_value
end function

Session.env.global_flag.rm = function(global_flag_name)
    if not self.has(global_flag_name) then return false 
    self.body[global_flag_name].delete 
    return true 
end function 

Session.db = {}
Session.db.items = {}
Session.db.root_folder = "/root/blackbox/db/"

Session.db.get_path = function(table_name)
    return self.root_folder + "." + table_name
end function

Session.db.init_database = function(table_name)
    get_shell.host_computer.touch(self.get_path(table_name), "init_blbx_db.json")
    init_path = self.get_path(table_name) + "/init_blbx_db.json"
    init_file = Directory.find_file(get_shell.host_computer.File("/"), init_path)
    
    if not tp(init_file) == "file" then return false
    init_file.set_content(JSON.write({"name": table_name, "entries": 0}))
    
    init_file.chmod("u-rwx")
    init_file.chmod("g-rwx")
    init_file.chmod("o-rwx")
end function


Session.db.select = function(table_name)
    if table_name.split("/").len == 1 then table_name = self.get_path(table_name)
    target_directory = Directory.find_file(get_shell.host_computer.File("/"), table_name)
    if not tp(target_directory) == "file" then return false
    return target_directory
end function 

Session.db.add_file = function(table_name)
    database = self.select(table_name)
    if not database then return false 
    entry_name = "." + table_name + "-" + str(database.get_files.len)
    create_entry_file = get_shell.host_computer.touch(database.path, entry_name)
    if not create_entry_file then return false
    check_entry = Directory.find_file(get_shell.host_computer.File("/"), database.path + "/" + entry_name)
    if tp(check_entry) == "string" then 
        print 
        printb(("* * " + check_entry + " * *").c("black"))
        printb(("* * failed to add database entry '" + entry_name + "'... * *").c("black black purple"))
        print 
    end if 
    if not check_entry then 
        print 
        printb(("* * failed to add database entry '" + entry_name + "'... * *").c("black black purple"))
        printb(("* * local machine is out of disk space * *").c("black black purple"))
        print 
    end if 
    check_entry.set_content(JSON.write({}))
    return check_entry
end function

Session.db.create = function(table_name) 
    self.init_database(table_name)
    self.add_file(table_name)
end function

Session.db.update_db_init_entries = function(table_name, amount)
    database = self.select(table_name)
    if not database then return false 

end function 

Session.db.parse = function(table_name, clear_screen_bool = false)
    database = self.select(table_name)
    if tp(database) != "file" then return false 
    database = database.get_files
    progress_bar_history = []
    result = {}
    count = 0
    LIMIT = 200
    for entry_file in database 
        count = count + 1
        if not entry_file.name.lower.search(table_name) then continue 
        result = result + JSON.read(entry_file.get_content)
        progress = count * LIMIT / (database.len * LIMIT)
        progress_bar = (a + _callback.loading_key_frame(progress))
        if tp(progress_bar_history.indexOf(progress_bar)) != "number" then 
            if clear_screen_bool then clear_screen else print
            printb(progress_bar)
            progress_bar_history.push(progress_bar)
        end if  
    end for 
    return result 
end function

Session.db.speed_parse = function(table_name, clear_screen_bool = true) //arrays only
    database = self.select(table_name)
    if tp(database) != "file" then return false 
    database = database.get_files
    result = []
    progress_bar_history = []
    count = 0
    LIMIT = 200
    for entry_file in database 
        count = count + 1
        if not entry_file.name.lower.search(table_name) then continue
        entry = entry_file.get_content.split("\[|\]|\{|\}|\:|\" + "".quote + "|\,|\s|\n|\t").clean([""])
        result = result + entry 
        progress = count * LIMIT / (database.len * LIMIT)
        progress_bar = (a + _callback.loading_key_frame(progress))
        if tp(progress_bar_history.indexOf(progress_bar)) != "number" then 
            if clear_screen_bool then clear_screen else print
            printb(progress_bar)
            progress_bar_history.push(progress_bar)
        end if 
    end for 

    return result
end function

Session.db.split_map = function(map, max_size = 10000)
    temp = map 
    master = {"0": {}}
    index1 = -1
    index2 = -1

    total_length = function()
        count = 0
        for element in master.values 
            count = count + element.len 
        end for 
        return count 
    end function 

    while not total_length() >= map.len 
        recent_child_object = master.values[-1]
        index1 = index1 + 1
        if not master.hasIndex(str(index)) then 
            master[str(index)] = {} 
            continue 
        end if 
        while recent_child_object.len < max_size
            index2 = index2 + 1
            if index2 >= max_size then break 
            wait(.1)
            temp_indexes = temp.indexes[:1]
            temp_values = temp.values[:1]
            recent_child_object[temp_indexes[0]] = temp_values[0]
            temp.pop
        end while 
        index1 = index1 + 1
        master[str(index1)] = {}
    end while 
    return master
end function 



Session.db.add_to = function(incoming_data = {}, table_name)
    if tp(incoming_data) != "map" and tp(incoming_data) != "list" then return false
    if not incoming_data.len then return true 
    database = self.select(table_name)
    if not database then return false
    database = database.get_files
    if not database.len then self.init_database(table_name)
    _callback.debug("<color=red>" + database.len, "internal add_to", 350)
    if database.len < 2 then
        _callback.debug("<color=red>add_to: checking new file" + database.len, "internal add_to", 352)
        self.add_file(table_name)
        return self.add_to(incoming_data, table_name)
    end if 

    if tp(incoming_data) == "list" then
        count = -1
        index = -1
        progress_bar_history = []

        _callback.local_debug(incoming_data, "internal", 365)
        while incoming_data.hasIndex(index)
            content_object = incoming_data[index]
            index = index + 1
            count = count + 1
            database = self.select(table_name).get_files
            entry_file = database[-1]
            entry_file_content = entry_file.get_content 
            if JSON.read(entry_file.get_content).len >= incoming_data.len then 
                self.add_file(table_name)
                entry_file = self.select(table_name).get_files[-1]
                index = index - 1
                continue
            end if
            progress_bar = (a + _callback.loading_key_frame(count * 200 / (incoming_data.len * 200)))
            if tp(progress_bar_history.indexOf(progress_bar)) != "number" then 
                clear_screen
                printb(progress_bar)
                progress_bar_history.push(progress_bar)
            end if  
            self.add_to(content_object, table_name)
        end while 
        return true 
    end if 
    entry_file = database[-1]
    entry_file_content = entry_file.get_content 
    parsed_contents = JSON.read(entry_file_content)
    if parsed_contents.len >= 200 then 
        self.add_file(table_name)
        _callback.local_debug("<color=red>contents too large, continuing...")
        return self.add_to(incoming_data, table_name)
    end if  
    if tp(incoming_data) == "map" then entry_file.set_content(JSON.write(parsed_contents + incoming_data))
    //_callback.local_debug("<color=orange>success!")
    //_callback.local_debug("<color=green>" + entry_file.get_content, "<color=green>updated entry file content", 355)
    return true
end function 

Session.db.add_array_to = function(incoming_data = [], table_name, json_bool = false)
    database = self.select(table_name)
    if not tp(database) == "file" then return false 
    database = database.get_files 
    if database.len < 2 then 
        self.add_file(table_name)
        return self.add_array_to(table_name)
    end if
    
    entry_file = database[-1]
    if entry_file.get_content.len >= 59999 then 
        self.add_file(table_name)
        return self.add_array_to(table_name)
    end if 

    entry_file_content = entry_file.get_content 
    entry_file.set_content(entry_file_content + fif(json_bool, JSON.write(incoming_data), incoming_data.join(char(10))))
    
    return true
end function

Session.db.reset = function(table_name)
    database = self.select(table_name)
    if not database then return false 
    database = database.get_files
    for entry_file in database
        if entry_file.name.lower.search("init_blbx_db.json") then continue 
        entry_file.delete
    end for 
    return true  
end function 

Session.db.set = function(incoming_data, table_name)
    database = self.select(table_name)
    if tp(database) != "file" then return false 
    if tp(incoming_data) == "list" then 
        incoming_data = incoming_data.combine
        if not incoming_data or not incoming_data.len then return false
    end if 
    self.add_to(incoming_data, table_name) 
    return true
end function 

Session.db.has_entry = function(entry, table_name)
    database = self.select(table_name)
    if tp(database) != "file" then return false 
    database = database.get_files 
    temp = {}
    for entry_file in database 
        if entry.file.name.lower.search("init_blbx_db.json") then continue 
        temp = temp + JSON.read(file.get_content)
    end for 
    if temp == {} then return false 
    if temp.hasIndex(entry) or tp(temp.indexes.indexOf(entry)) == "number" or tp(temp.values.indexOf(entry)) == "number" then return true
    return false
end function

Session.db.has = function(table_name)
    database = self.select(table_name)
    if not database then return false 
    return true
end function 

Session.db.init = function(table_name_arr)
    for table_name in table_name_arr 
        database = self.select(table_name)
        if not database then 
            self.create(table_name)
            database = self.select(table_name)
        end if 
   
        if table_name == "dictionary" and not database.get_files.len > 2 then 
            PasswordGenerator.init(PasswordGenerator.PASSWORDS)    
            printb(a + "*** building dictionary attack lookup table ***".color("purple"))
            printb(a + "this will take a minute".color("black"))
            printb(a + "please wait".color("black"))
            
            extra_hashes = {md5("Usand"): "Usand", md5("rixie"): "rixie"}
            try_generate_passwords = PasswordGenerator.AllPasswords() + etra_hashes // {md5(passwd): passwd}
            for group in try_generate_passwords
                self.add_to(try_generate_passwords, "dictionary")
            end for 
        end if 
    end for 

    return true
end function

Session.rpc = {} // Remote Procedure Call - look it up
Session.rpc.hand_shake = get_custom_object()

Session.rpc.get_hand_shake = function()
    return self.hand_shake
end function 

Session.rpc.wipe_hand_shake = function()
    self.hand_shake = get_custom_object()
    return self.hand_shake
end function 

Session.rpc.new_hand_shake = function()
    self.hand_shake = get_custom_object()
    return self.hand_shake
end function 

Session.rpc.get_access = function(file_instance)
    for machine_file in file_instance.get_folders
        if machine_file.has_permission("w") and machine_file.has_permission("x") then return machine_file

        result = self.get_access(machine_file)
        if not result then continue 
        return result 
    end for 
    return false
end function 

Session.rpc.set_endpoint = function(shell_instance, src_file_name, src_file_content)
    comp_instance = shell_instance.host_computer
    file_instance = comp_instance.File("/")
    
    accessed_file = self.get_access(file_instance)
    if not accessed_file then return _callback.catch("[session][rpc][endp]: no accessable directories found...")
    accessed_file_path = fif((accessed_file.path == "/"), "", accessed_file.path)
    src_file_name = "." + src_file_name 
    src_file_path = accessed_file_path + "/" + src_file_name

    try_touch = comp_instance.touch(fif(accessed_file_path == "", "/", accessed_file_path), src_file_name)
    if not try_touch then return _callback.catch("[session][rpc][endp]: failed to create '"+src_file_name+"', permission denied...")
    touched_file = comp_instance.File(src_file_path)
    if not touched_file then return _callback.catch("[session][rpc][endp]: source file '"+src_file_name+"' created but not found...")
    touched_file.set_content(src_file_content.split(";").join(char(10)))
    
    store = shell_instance.build(touched_file.path, fif((accessed_file_path == ""), "/", accessed_file_path))

    binary_name = src_file_name[:-4] // removes '.src'
    if tp(store) == "string" and store.len > 0 then return _callback.catch("[session][rpc][endp]: " + store)
    binary_file = comp_instance.File(accessed_file_path + "/" + binary_name)
    if not tp(binary_file) == "file" then return _callback.catch("[session][rpc][endp]: binary file '"+binary_name+"' created but not found...")
    
    return _callback.catch(binary_file, 1)
end function

Session.rpc.src = {}
Session.rpc.src.scan_nw = function()
    return "c10 = char(10);c0 = char(0);tp = @typeof;string.color=function(string_split_by_space="+"black black black".quote+");list=string_split_by_space.split("+" ".quote+");  if not string_split_by_space.len then string_split_by_space="+"black black black".quote+";  colorm={"+"black".quote+":"+"<#707070>".quote+", "+"white".quote+":"+"<#BEB9E7FF>".quote+", "+"purple".quote+":"+"<#7A53F6>".quote+", "+"pink".quote+":"+"<#ED2EEA>".quote+", "+"red".quote+":"+"<color=red>".quote+", "+"dark_red".quote+":"+"<#731313>".quote+", "+"blue".quote+":"+"<color=blue>".quote+", "+"green".quote+":"+"<#2BB930>".quote+", "+"dark_green".quote+":"+"<#2C6407>".quote+", "+"cyan".quote+":"+"<#32E3EF>".quote+", "+"yellow".quote+":"+"<#D2DE0F>".quote+", "+"brown".quote+":"+"<#674D06>".quote+", "+"orange".quote+":"+"<#EA9512>".quote+"};  alpha="+"qwertyuiopasdfghjklzxcvbnm".quote+";number="+"1234567890".quote+";symbol="+"!@#$%^&*()_+-={}|[]\:;'<>?,./".quote+"+"+"".quote+""+"".quote+";  check_all=function();res=1;for i in list;if not colorm.hasIndex(i) then ;res=0;break;end if;end for;return res;end function;  if not check_all() then return false;  while list.len < 3;list.push(list[-1]);end while;  coa=colorm[list[0]];con=colorm[list[1]];cos=colorm[list[2]];curr_color=coa;curr_type="+"alpha".quote+";newl=[];fp=1//;count=-1;  for char in self.values;    is_a=(tp(alpha.indexOf(char.lower)) == "+"number".quote+");is_n=(tp(number.indexOf(char)) == "+"number".quote+");is_s=(tp(symbol.indexOf(char)) == "+"number".quote+");    if char==c10 then ;newl.push(char+curr_color);continue;end if;    if is_a then curr_type="+"alpha".quote+";if is_n then curr_type="+"number".quote+";if is_s then curr_type="+"symbol".quote+";    if curr_type=="+"alpha".quote+" then;      if curr_color!=coa or (curr_color==coa and fp) then curr_color=coa else curr_color="+"".quote+";fp=0;      newl.push(curr_color+char);curr_color=coa;continue;    end if;    if curr_type=="+"number".quote+" then;      if curr_color!=con or (curr_color==con and fp) then curr_color=con else curr_color="+"".quote+";fp=0;      newl.push(curr_color+char);curr_color=con;continue;    end if;    if curr_type=="+"symbol".quote+" then;      if curr_color!=cos or (curr_color==cos and fp) then curr_color=cos else curr_color="+"".quote+";fp=0;      newl.push(curr_color+char);curr_color=cos;continue;    end if;    newl.push(char);  end for;  ;  self=newl.join("+"".quote+");ctr=0;  for i in self;    if i == "+"<".quote+" then ctr=ctr+1;  end for;  for i in range(1,ctr);    self=self+"+"</color>".quote+";  end for;  return self[:-8];end function;string.c = @string.color;string.search = function(sub_string = "+"".quote+");  return tp(self.lower.indexOf(sub_string.lower)) == "+"number".quote+";;end function;;incoming_data = get_custom_object().data;_callback = @incoming_data._callback;;scan_network = function();    local_router = get_router ;    lan_address_arr = get_router.devices_lan_ip;    router_addresses = [];    count = 0;;    for lan_address in lan_address_arr ;        if lan_address.split("+"\.".quote+")[-1] == "+"1".quote+" then ;            router_addresses.push(lan_address);            count = count + 1;            continue;        end if ;    end for ;    ;    print ;    print "+"<b>".quote+" + "+"network devices: ".quote+".c("+"black".quote+") + "+"</b>".quote+";    print ;    print "+"<b>".quote+" + lan_address_arr[:(-count)][0].c("+"black black purple".quote+") + lan_address_arr[:-count].join(char(10) + "+"<b>".quote+".c("+"black black purple".quote+"));    print ;    print "+"<b>".quote+" + "+"nearby routers: ".quote+".c("+"black".quote+") + "+"</b>".quote+";    print ;    print "+"<b>".quote+" + router_addresses[0].c("+"black black purple".quote+") + char(10) + router_addresses[1:].join(char(10) + "+"<b>".quote+".c("+"black black purple".quote+"));    print;;    return _callback.catch({"+"network_devices".quote+": lan_address_arr[:-count], "+"routers".quote+": router_addresses}, 1);end function ;return scan_network()"
end function
Session.rpc.src.rshell = function()
    return "incoming_object = get_custom_object();incoming_data = incoming_object.data ;_callback = @incoming_data._callback;string.search = function(sub_string = "+"".quote+");  return tp(self.lower.indexOf(sub_string.lower)) == "+"number".quote+";end function;tp = @typeof;Directory = @incoming_data.Directory;host_ip_address = incoming_data.host_ip_address;send_reverse_shell_instance = function(reverse_shell_host_ip);    target_library_file = Directory.find_file(get_shell.host_computer.File("+"/".quote+"), 0, "+"metaxploit.so".quote+");    if not target_library_file then return _callback.catch("+"[blbx][rshell][err]: cannot find metaxploit.so on machine...".quote+");    metaxploit = include_lib(target_library_file.path);    try_rshell_client = metaxploit.rshell_client(reverse_shell_host_ip, 1222, c0);    if tp(try_rshell_client) == "+"string".quote+" then return _callback.catch("+"[blbx][rshell][err]: ".quote+" + try_rshell_client);    return _callback.catch(try_rshell_client, 1);end function ;result = send_reverse_shell_instance(host_ip_address).data;incoming_object.data = {"+"rshell".quote+": result};return incoming_object"
end function 
Session.rpc.src.escalate = function()
    return "c10 = char(10);c0 = char(0);tp = @typeof;incoming_object = get_custom_object();incoming_data = incoming_object.data ;string.color=function(string_split_by_space="+"black black black".quote+");list=string_split_by_space.split("+" ".quote+");  if not string_split_by_space.len then string_split_by_space="+"black black black".quote+";  colorm={"+"black".quote+":"+"<#707070>".quote+", "+"white".quote+":"+"<#BEB9E7FF>".quote+", "+"purple".quote+":"+"<#7A53F6>".quote+", "+"pink".quote+":"+"<#ED2EEA>".quote+", "+"red".quote+":"+"<color=red>".quote+", "+"dark_red".quote+":"+"<#731313>".quote+", "+"blue".quote+":"+"<color=blue>".quote+", "+"green".quote+":"+"<#2BB930>".quote+", "+"dark_green".quote+":"+"<#2C6407>".quote+", "+"cyan".quote+":"+"<#32E3EF>".quote+", "+"yellow".quote+":"+"<#D2DE0F>".quote+", "+"brown".quote+":"+"<#674D06>".quote+", "+"orange".quote+":"+"<#EA9512>".quote+"};  alpha="+"qwertyuiopasdfghjklzxcvbnm".quote+";number="+"1234567890".quote+";symbol="+"!@#$%^&*()_+-={}|[]\:;'<>?,./".quote+"+"+"".quote+""+"".quote+";  check_all=function();res=1;for i in list;if not colorm.hasIndex(i) then ;res=0;break;end if;end for;return res;end function;  if not check_all() then return false;  while list.len < 3;list.push(list[-1]);end while;  coa=colorm[list[0]];con=colorm[list[1]];cos=colorm[list[2]];curr_color=coa;curr_type="+"alpha".quote+";newl=[];fp=1//;count=-1;  for char in self.values;    is_a=(tp(alpha.indexOf(char.lower)) == "+"number".quote+");is_n=(tp(number.indexOf(char)) == "+"number".quote+");is_s=(tp(symbol.indexOf(char)) == "+"number".quote+");    if char==c10 then ;newl.push(char+curr_color);continue;end if;    if is_a then curr_type="+"alpha".quote+";if is_n then curr_type="+"number".quote+";if is_s then curr_type="+"symbol".quote+";    if curr_type=="+"alpha".quote+" then;      if curr_color!=coa or (curr_color==coa and fp) then curr_color=coa else curr_color="+"".quote+";fp=0;      newl.push(curr_color+char);curr_color=coa;continue;    end if;    if curr_type=="+"number".quote+" then;      if curr_color!=con or (curr_color==con and fp) then curr_color=con else curr_color="+"".quote+";fp=0;      newl.push(curr_color+char);curr_color=con;continue;    end if;    if curr_type=="+"symbol".quote+" then;      if curr_color!=cos or (curr_color==cos and fp) then curr_color=cos else curr_color="+"".quote+";fp=0;      newl.push(curr_color+char);curr_color=cos;continue;    end if;    newl.push(char);  end for;  ;  self=newl.join("+"".quote+");ctr=0;  for i in self;    if i == "+"<".quote+" then ctr=ctr+1;  end for;  for i in range(1,ctr);    self=self+"+"</color>".quote+";  end for;  return self;end function;string.c = @string.color;;list.clean=function(example_list);  newl=[];  if not tp(example_list) == "+"list".quote+" then example_list = [example_list];  for i in self;    if tp(example_list.indexOf(i)) == "+"number".quote+" then continue;    newl.push(i);  end for;  self=newl;  return self;end function;;incoming_object = get_custom_object();incoming_data = incoming_object.data ;_callback = @incoming_data._callback;username = incoming_data.username;password = incoming_data.password;dictionary = incoming_data.dictionary ;b = "+"<b>".quote+";a = "+"<align=center>".quote+";escalate = function(_user, _dict, _pass = 0);    print b + ("+"*** attempting dictionary attack ***".quote+").c("+"black black purple".quote+") + c0;    print b + ("+"*** please wait ***".quote+").c("+"black".quote+") + c0;    wait(2);;    if _pass then ;        try_shell_login = get_shell(_user, _pass);        if typeof(try_shell_login) != "+"shell".quote+" then return _callback.catch("+"[blbx][esca][err]: shell instance login attempt failed...".quote+");        ;        return _callback.catch(try_shell_login, 1);    end if ;;    found = false ;    count = 0;    limit_check = 0;    LIMIT = 200;    progress_bar_history = [];    for password in _dict;        limit_check = limit_check + 1;        password = password.values.clean(["+"".quote+""+"".quote+"]).join("+"".quote+");        try_shell_login = get_shell(_user, password);        if limit_check == LIMIT then ;          limit_check = 0;          count = count + 1;          progress_bar = (a + _callback.loading_key_frame(((count * 200) / _dict.values.len))) // 341,000 passwords in total;          if tp(progress_bar_history.indexOf(progress_bar)) != "+"number".quote+" then ;            clear_screen;            progress_bar_history.push(progress_bar);            print(b + progress_bar);          end if ;        end if ;        if typeof(try_shell_login) == "+"null".quote+" then continue ;        print ;        print(b + a + ("+"*** password found for user '".quote+" + _user + "+"'@'".quote+" + password + "+"' ***".quote+").c("+"black black purple".quote+") + c0);        print          ;        found = try_shell_login;        break;    end for ;    if not found then return _callback.catch("+"[blbx][esca][err]: dictionary attack failed. password not found...".quote+")  ;    return _callback.catch(found, 1);end function;;escalation_result = escalate(username, dictionary, password);;incoming_object.data = escalation_result;return incoming_object;"
end function 
Session.rpc.src.dictionary = function()
    return "incoming_data = get_custom_object().data;_callback = @incoming_data._callback;username = incoming_data.username;dictionary = incoming_data.dictionary;dictionary_attack = function(_user, _dict);    found = false ;    for password in _dict.values ;        try_shell_login = get_shell(_user, password);        if typeof(try_shell_login) == "+"null".quote+" then continue ;        found = password;        break;    end for ;    if not found then return _callback.catch("+"[blbx][dict][err]: dictionary attack failed. password not found...".quote+", 0)  ;    print "+"<b>password found: ".quote+" + found + "+"</b>".quote+";    return _callback.catch(found, 1);end function ;return dictionary_attack(username, dictionary)"
end function 
Session.rpc.src.bounce = function()
    return "c10 = char(10);c0 = char(0);incoming_object = get_custom_object();incoming_data = incoming_object.data ;string.color=function(string_split_by_space="+"black black black".quote+");list=string_split_by_space.split("+" ".quote+");  if not string_split_by_space.len then string_split_by_space="+"black black black".quote+";  colorm={"+"black".quote+":"+"<#707070>".quote+", "+"white".quote+":"+"<#BEB9E7FF>".quote+", "+"purple".quote+":"+"<#7A53F6>".quote+", "+"pink".quote+":"+"<#ED2EEA>".quote+", "+"red".quote+":"+"<color=red>".quote+", "+"dark_red".quote+":"+"<#731313>".quote+", "+"blue".quote+":"+"<color=blue>".quote+", "+"green".quote+":"+"<#2BB930>".quote+", "+"dark_green".quote+":"+"<#2C6407>".quote+", "+"cyan".quote+":"+"<#32E3EF>".quote+", "+"yellow".quote+":"+"<#D2DE0F>".quote+", "+"brown".quote+":"+"<#674D06>".quote+", "+"orange".quote+":"+"<#EA9512>".quote+"};  alpha="+"qwertyuiopasdfghjklzxcvbnm".quote+";number="+"1234567890".quote+";symbol="+"!@#$%^&*()_+-={}|[]\:;'<>?,./".quote+"+"+"".quote+""+"".quote+";  check_all=function();res=1;for i in list;if not colorm.hasIndex(i) then ;res=0;break;end if;end for;return res;end function;  if not check_all() then return false;  while list.len < 3;list.push(list[-1]);end while;  coa=colorm[list[0]];con=colorm[list[1]];cos=colorm[list[2]];curr_color=coa;curr_type="+"alpha".quote+";newl=[];fp=1//;count=-1;  for char in self.values;    is_a=(tp(alpha.indexOf(char.lower)) == "+"number".quote+");is_n=(tp(number.indexOf(char)) == "+"number".quote+");is_s=(tp(symbol.indexOf(char)) == "+"number".quote+");    if char==c10 then ;newl.push(char+curr_color);continue;end if;    if is_a then curr_type="+"alpha".quote+";if is_n then curr_type="+"number".quote+";if is_s then curr_type="+"symbol".quote+";    if curr_type=="+"alpha".quote+" then;      if curr_color!=coa or (curr_color==coa and fp) then curr_color=coa else curr_color="+"".quote+";fp=0;      newl.push(curr_color+char);curr_color=coa;continue;    end if;    if curr_type=="+"number".quote+" then;      if curr_color!=con or (curr_color==con and fp) then curr_color=con else curr_color="+"".quote+";fp=0;      newl.push(curr_color+char);curr_color=con;continue;    end if;    if curr_type=="+"symbol".quote+" then;      if curr_color!=cos or (curr_color==cos and fp) then curr_color=cos else curr_color="+"".quote+";fp=0;      newl.push(curr_color+char);curr_color=cos;continue;    end if;    newl.push(char);  end for;  ;  self=newl.join("+"".quote+");ctr=0;  for i in self;    if i == "+"<".quote+" then ctr=ctr+1;  end for;  for i in range(1,ctr);    self=self+"+"</color>".quote+";  end for;  return self;end function;string.c = @string.color;string.search = function(sub_string = "+"".quote+");  return tp(self.lower.indexOf(sub_string.lower)) == "+"number".quote+";;end function;list.remove_repeats=function();  newl=[];  for i in self;    if tp(newl.indexOf(i)) != "+"number".quote+" then newl.push(i);  end for;  self=newl;  return self;end function;list.clean=function(example_list);  newl=[];  for i in self;    if tp(example_list.indexOf(i)) == "+"number".quote+" then continue;    newl.push(i);  end for;  self=newl;  return self;end function;list.mass_concat = function();  result = [];  for sub_arr in self ;    result = result + sub_arr;  end for ;  return result;end function ;_callback = @incoming_data._callback;Directory = @incoming_data.Directory;Session = @incoming_data.Session;Exploit = @incoming_data.Exploit;library_path = @incoming_data.library_path;database = @incoming_data.database;lan_address = @incoming_data.lan_address;notify = @incoming_data.notify;hide_ip = @incoming_data.hide_ip;tp = @typeof;JSON = @incoming_data.JSON;;memory_arr = [];metaxploit = Exploit.module.get_local_lib("+"metaxploit.so".quote+")//;;library = metaxploit.load(library_path);if not Exploit.module.library.get_metax() then return _callback.catch("+"[expl][attack][err]: metaxploit library not found on machine...".quote+");if tp(Session.machine.ip.get_lan_address_arr().indexOf(Session.machine.ip.get_lan_address())) != "+"number".quote+" then Session.machine.ip.add_lan_address(lan_address);;exploit_map = Exploit.module.parse_exploits(library, database);memory_address_arr = exploit_map.data.indexes;;saved_exploits = [];captured_exploits = [];for address in memory_address_arr ;  captured_exploits = Exploit.module.run_exploits(exploit_map.data[address], address, lan_address, library, lan_address, database, 0) //change_password json;end for ;;;print(notify(("+"bounce attack on ".quote+" + ("+"'".quote+" + hide_ip(lan_address) + "+"'".quote+").c("+"black black white".quote+") + "+" completed.".quote+")) + c0);;incoming_object.data = { "+"Session".quote+": Session, "+"Exploit".quote+": Exploit, "+"exploit_arr".quote+": captured_exploits, "+"library".quote+": library };;return incoming_object"
end function

Session.rpc.data = {} // organizes RPC data for sending and recieving

Session.rpc.data.catch = function()
    return get_custom_object()
end function

Session.rpc.data.send = function(shell_instance, program, program_prompt = "", data = {}, delete = 0)
    Session.rpc.new_hand_shake().data = data

    try_rpc = shell_instance.launch(program.path, program_prompt.trim)
    if delete then program.delete
    if tp(try_rpc) == "string" then return _callback.catch("[session][rpc][send]: " + try_rpc)
    return _callback.catch(try_rpc, 1)
end function


Session.machine = {}
Session.machine.ip = {}
Session.machine.ip.lan_address = ""
Session.machine.ip.pub_address = ""
Session.machine.ip.lan_address_arr = []
Session.machine.ip.pub_address_arr = []

Session.machine.ip.random_ip = function()
    n = function()
        return floor(rnd * (255 - 0 + 1) + 0)
    end function 

    return str(n) + "." + str(n) + "." + str(n) + "." + str(n)
end function 

Session.machine.ip.get_lan = function()
    return self.lan_address
end function

Session.machine.ip.set_lan = function(new_lan_address)
    self.lan_address = new_lan_address
    return self.lan_address
end function

Session.machine.ip.get_pub = function()
    return self.pub_address
end function 

Session.machine.ip.set_pub = function(new_pub_address)
    self.pub_address = new_pub_address
    return self.pub_address
end function 

Session.machine.ip.add_lan_address = function(new_lan_address)
    self.lan_address_arr.push(new_lan_address)
    return new_lan_address
end function 

Session.machine.ip.set_lan_address_arr = function(new_lan_address_arr)
    self.lan_address_arr = new_lan_address_arr
    return self.lan_address_arr
end function 

Session.machine.ip.get_lan_address_arr = function()
    return self.lan_address_arr
end function 

Session.machine.ip.get_lan_address = function()
    return self.lan_address
end function 

Session.machine.ip.add_pub_address = function(new_pub_address)
    self.pub_address_arr.push(new_pub_address)
    return new_pub_address
end function 

Session.machine.ip.set_pub_address_arr = function(new_pub_address_arr)
    self.pub_address_arr = new_pub_address_arr
    return self.pub_address_arr
end function 

Session.machine.ip.get_pub_address_arr = function
    return self.pub_address_arr
end function 


Session.machine.user = {}
Session.machine.user.current = {"name": ""}

Session.machine.user.get_name = function()
    return self.current.name
end function

Session.machine.user.set_name = function(new_user_name)
    self.current.name = new_user_name
    return self.current.name
end function 

Session.machine.user.wipe = function() 
    self.current = {"name": ""}
end function

Session.object = {}

Session.object.rshell = {"list": []}
Session.object.shell = {"list": []}
Session.object.computer = {"list": []}
Session.object.file = {"list": []}

Session.parse_object = function(object_list, lan_address, as_user = 0, return_all = 0)
    if not object_list.len then return false 
    user_dict = {"root": [], "guest": [], "unknown": [], "usr": []}
    
    search_sub_array = function(main_arr, search_for_str)
        found = false 
        for sub_arr in main_arr 
            if sub_arr[1].lower.search(sub_arr) then found = sub_arr[1]
        end for
        return false 
    end function 
    
    username_array = []
    
    for object_arr in object_list
        object = object_arr[0]
        username = object_arr[1]
        username_array.push(username)
        if not username then username = "unknown"
        lanip = object_arr[2]

        if lanip != lan_address then continue
        
        if as_user then 
            if username.lower.search(as_user.lower) then 
                user_dict.usr.push(object)
                continue
            end if
        end if
    
        if username == "root" then 
            user_dict.root.push([object, username])
            continue
        end if
        if username == "guest" then
            user_dict.guest.push([object, username])
            continue 
        end if 
        if username == "unknown" then
            user_dict.unknown.push([object, username])
            continue 
        end if 
        
        if not tp(username_array.indexOf(username)) == "number" then user_dict.usr.push([object, username])
    end for 

    if not as_user and lan_address and return_all then return user_dict.root + user_dict.guest + user_dict.unknown + user_dict.usr
    if ((not as_user and lan_address) and not return_all) then
        if user_dict.root.len > 0 then return user_dict.root[0][0]
        if user_dict.usr.len > 0 then return user_dict.usr[0][0]
        if user_dict.unknown.len > 0 then return user_dict.unknown[0][0]
        if user_dict.guest.len > 0 then return user_dict.guest[0][0]
    end if 

    if ((as_user and lan_address) and not return_all) then 
        if user_dict.root.len > 0 and as_user == "root" then return user_dict.root[0][0]
        found = false
        if user_dict.usr.len > 0 and as_user then
            for user in user_dict.usr 
                if user[1].lower.search(as_user.lower) then found = user[0]
            end for 
        end if 
        if found then return found 
        if user_dict.unknown.len > 0 then return user_dict.unknown[0][0]
        if user_dict.guest.len > 0 then return user_dict.guest[0][0]
    end if 

    return false
end function

Session.get_object_arr = function(object_type)
    return self.object[object_type].list
end function

Session.is_empty = function(object_type)
    if not self.get_object_arr(object_type).len then return true 
    return false 
end function 

Session.get_user = function(object)
    if tp(object) == "shell" then object = object.host_computer 
    if tp(object) == "computer" then object = object.File("/")

    if not tp(Directory.find_file(object, "/root")) == "file" then file = [Directory.find_file(object, "/boot/System.map"), Directory.find_file(object, "/home")] else file = [Directory.find_file(object, "/root"), Directory.find_file(object, "/home")]
 
    if tp(file[0]) == "file" and file[0].has_permission("w") then return "root"
    if tp(file[1]) == "file" then file_list = file[1].get_folders else return false 
    users = [] 
    result = []

    for file in file_list 
       if file.has_permission("w") then users.push(file.name)
    end for 

    if users.hasIndex(1) then return users[0]
    if tp(users.indexOf("guest")) == "number" then return "guest"
    return "unknown"
end function

Session.add = function(object, lan_address)
    if tp(object) == "file" then 
        while object.path != "/"
            object = object.parent
        end while 
    end if
    self.object[tp(object)].list.push([object, self.get_user(object), lan_address, tp(object)])
    if tp(object) == "shell" or tp(object) == "rshell" then return self.add(object.host_computer, lan_address)
    if tp(object) == "computer" then return self.add(object.File("/"), lan_address)
    return true
end function 

Session.wipe = function()
    self.object.number = {"list": []}
    self.object.rshell = {"list": []}
    self.object.shell = {"list": []}
    self.object.comp = {"list": []}
    self.object.file = {"list": []}
end function




Exploit = {}

Exploit.net_session = false 
Exploit.change_password = false
Exploit.scan_library = false 

Exploit.get_net_session = function()
    return self.net_session
end function 

Exploit.set_net_session = function(new_net_session)
    self.net_session = new_net_session
end function 

Exploit.is_change_pass = function()
    return self.change_password
end function 

Exploit.set_change_pass = function(new_pass_bool)
    self.change_password = new_pass_bool
    return self.change_password
end function    

Exploit.is_scan_mode = function()
    return self.scan_library
end function 

Exploit.set_scan_mode = function(new_mode_bool)
    self.scan_library = new_mode_bool
    return self.scan_library
end function

Exploit.device = {}

Exploit.device.tree = {}
Exploit.device.current = {}
Exploit.device.user_map = {}
Exploit.device.serialized_tree = ""

Exploit.device.wipe = function()
    self.tree = {}
    self.current = {}
    self.user_map = {}
    self.serialized_tree = ""
end function

Exploit.device.get_current = function()
    return self.current
end function

Exploit.device.set_current = function(new_current_device)
    self.current = new_current_device
    return self.current
end function

Exploit.device.add = function(object, lan_address)
    if not self.tree.hasIndex(lan_address) then self.tree[lan_address] = {"shells": [], "rshells": [], "computers": [], "files": []}
    if tp(object) == "shell" then 
        self.tree[lan_address].shells.push([object, Session.get_user(object), lan_address, tp(object)])
        return self.add(object.host_computer, lan_address)
    end if 
    if tp(object) == "rshell" then 
        self.tree[lan_address].shells.push([object, Session.get_user(object), lan_address, tp(object)])
        return self.add(object.host_computer, lan_address)
    end if
    if tp(object) == "computer" then 
        self.tree[lan_address].computers.push([object, Session.get_user(object), lan_address, tp(object)])
        return self.add(object.File("/"), lan_address)
    end if 
    if tp(object) == "file" then 
        while object.path != "/"
            object = object.parent
        end while 
        self.tree[lan_address].files.push([object, Session.get_user(object), lan_address, tp(object)])
    end if

    return true
end function 

Exploit.device.has = function(lan_address)
    return tp(self.tree.indexes.indexOf(lan_address)) == "number"
end function


Exploit.device.get = function(lan_address)
    if not self.has(lan_address) then return false 
    return self.tree[lan_address]
end function 

Exploit.device.has_object = function(lan_address, object_type)
    if not self.has(lan_address) then return false 
    if not self.get(lan_address)[object_type + "s"].len then return false 
    return true 
end function

Exploit.device.get_object = function(lan_address, object_type)
    if not self.has_object(lan_address, object_type) then return false 
    return Session.parse_object(self.get(lan_address)[object_type + "s"], lan_address)
end function 

Session.borrow = function(object_type, lan_address, as_user = 0)
    object = Exploit.device.get_object(lan_address, object_type)
    if not object then return false 
    
    return object
end function


Exploit.device.add_user = function(lan_address, username)
    if not self.user_map.hasIndex(lan_address) then self.user_map[lan_address] = []
    user_arr = self.user_map[lan_address]
    if username and tp(user_arr.indexOf(username)) != "number" then user_arr.push(username.lower)
    self.user_map[lan_address] = user_arr.remove_repeats    
    return true 
end function

Exploit.device.has_user = function(username, lan_address)
    if not self.user_map.hasIndex(lan_address) then return false
    return tp(self.user_map[lan_address].indexOf(username)) == "number"
end function 

Exploit.device.get_user = function(username, lan_address)
    full_username = false
    if not self.has_user(username, lan_address) then return false
    for user in self.device.user_map[lan_address]
        if user.lower.search(username.lower) then 
            full_username = user 
            break 
        end if 
    end for 
    return full_username
end function

Exploit.device.get_user_arr = function(lan_address)
    if not self.user_map.indexes.hasIndex(lan_address) then return false 
    return self.user_map[lan_address]
end function 

Exploit.device.align_ip_addresses = function()
    for lan_address in Session.machine.ip.get_lan_address_arr()
        if not self.has(lan_address) then self.add(lan_address)
        if not self.user_map.hasIndex(lan_address) then self.add_user(lan_address)
        
        for obj in Session.object.shell.list + Session.object.computer.list + Session.object.file.list
            if lan_address != obj[2] then continue
            username = obj[1]
            object = obj[0]

            if not self.has_user(username, lan_address) then self.add_user(lan_address, username)
            if tp(object) == "shell" then Session.machine.ip.set_pub(object.host_computer.public_ip) 
            if tp(object) == "computer" then Session.machine.ip.set_pub(object.public_ip)
        end for  
    end for 
end function 

Exploit.device.show_tree = function()
    add_line 
    printb("           device tree".c("black"))
    add_line
    printb(bar(30))
    add_line
    printb((" public address: ".c("black") + Session.machine.ip.get_pub()).c("purple"))
    add_line
    for lan_address in self.user_map.indexes
        printb(bar(30))
        add_line
        printb("  lan address: ".c("black") + lan_address.c("purple"))
        add_line
        for user in self.user_map[lan_address]
            printb(("   user: ".c("black") + user).c("purple"))
        end for
        if Exploit.device.has(lan_address) and Exploit.device.get(lan_address) then shells = Exploit.device.get(lan_address).shells else shells = 0
        if Exploit.device.has(lan_address) and Exploit.device.get(lan_address) then computers = Exploit.device.get(lan_address).computers else computers = 0
        if Exploit.device.has(lan_address) and Exploit.device.get(lan_address) then files = Exploit.device.get(lan_address).files else files = 0
        
        add_line
        
        if shells then shell_message = ("shell: ".c("black") + str(shells.len)).c("purple") else shell_message = ""
        if computers then computer_message = ("computer: ".c("black") + str(computers.len)).c("purple") else computer_message = ""
        if files then file_message = (("file: ".c("black") + str(files.len)).c("purple") + "\n") else file_message = ""
        printb(("   " + shell_message + " " + computer_message + " " + file_message))
    end for 
    printb(bar(30))

    return true
end function 

Exploit.has_object = function(object)
    total_user_list  = Exploit.device.user_map.values.mass_concat().remove_repeats
    object_user = Session.get_user(object)
    if tp(total_user_list.indexOf(fif(object_user, object_user, "unknown").lower)) == "number" then return true 
    return false
end function

Exploit.module = {}
Exploit.module.clear_logs = function()
    file_instance = Session.borrow("file", Session.machine.ip.get_lan())
    if not tp(file_instance) == "file" then return false 
    logs_file_arr = Directory.find_file(file_instance)
    if not logs_file_arr or logs_file_arr and not logs_file_arr.len then return false
    get_logs_file = function()
        _logs_file = logs_file_arr[floor((rnd * logs_file_arr.len-1) + 1)][0]
        if _logs_file.is_folder then return get_logs_file()
        printb("attempting overwrite with: ".c("black") + _logs_file.path.c("purple"))
        return _logs_file
        // if this function causes the program to run recursively. it's because there are no files to use on the machine.
    end function 
    logs_file = get_logs_file()
    try_corrupt_logs = logs_file.move("/var", "system.log")
    message = ""
    if tp(try_corrupt_logs) == "string" and try_corrupt_logs.len then message = try_corrupt_logs + ". could not corrupt logs..." else message = "logs corrupted..."
    
    return message 
end function 

Exploit.module.library = {}

Exploit.module.get_payloads = function(library, check = 0, find_memory = 0, database = 0)
    if not database then database = Session.db.parse("exploit")
    if not database then database = {}
    library_name = library.lib_name 
    library_version = library.version 
    if not database.len then return false 
    if not database.hasIndex(library_name) then return false 
    if database.hasIndex(library_name) and not database[library_name].hasIndex(library_version) then return false
    if check then return true 
    
    owned_memory_array = database[library_name][library_version].indexes
   
    payload = []
    for memory_address in owned_memory_array
        if not find_memory then 
            payload = payload + database[lib_name][library_version][memory_address]
            continue 
        end if 

        if memory_address == find_memory then 
            payload = database[library_name][library_version][memory_address]
            break 
        end if 
    end for 

    return payload
end function

Exploit.module.create_exploit = function(payload_arr, memory_address, library_name, library_version)
    return {library_version: {memory_address: payload_arr}}
end function

Exploit.module.add_exploit = function(database_entry, library, saved_database = 0, set_db = 1)
    add_line 
    
    printb(("storing to " + library.lib_name + " v" + library.version).c("black black purple"))
    
    if not saved_database then saved_database = Session.db.parse("exploits")
    if not saved_database then saved_database = {}
    library_name = library.lib_name
    library_version = library.version 
    
    for entry in database_entry 
        
        if not saved_database.len or (saved_database.len > 0 and not saved_database.hasIndex(library_name)) then saved_database[library_name] = {}
        if not saved_database[library_name].len or (saved_database[library_name].len > 0 and not saved_database[library_name].hasIndex(library_version)) then saved_database[library_name][library_version] = {}
        //print not saved_database[library_name].len or (not saved_database[library_name].hasIndex(library_version))
        
        printb((("adding " + str(entry.value.indexes.len) + " exploits to " + library_name + " v" + library_version).c("purple")).c("purple"))
        //saved_database[library_name][library_version] = entry.value 

        for memory_address in entry.value.indexes
            if not saved_database[library_name][library_version].hasIndex(memory_address) then saved_database[library_name][library_version][memory_address] = []
            saved_database[library_name][library_version][memory_address] = (saved_database[library_name][library_version][memory_address] + entry.value[memory_address]).remove_repeats
            _callback.local_debug("<color=red>add_exploit: checking additions")
        end for 

    end for 
    if set_db then Session.db.set(saved_database, "exploit")
    return saved_database 
end function 

Exploit.module.get_local_lib = function(library_name)
    try_library_arr = Directory.find_file(get_shell.host_computer.File("/"), 0, library_name, 1)
    
    if not try_library_arr.len then return false 
    result = false 
    for library_file in try_library_arr 
        library_file = library_file[0]
        if library_file.name == library_name then 
            try_library = include_lib(library_file.path)
            if tp(["null", "number"].indexOf(tp(try_library))) == "number" then continue
            result = try_library
            break 
        end if 
    end for 

    return result
end function 

Exploit.module.allocate = function(object, lan_address, hide_objects = 0)
    if Exploit.has_object(object) then return false
    if tp(["shell", "rshell", "computer", "file"].indexOf(tp(object))) != "number" then return false 
    printb((tp(object)).c("purple"))
    return Session.add(object, lan_address)
end function


Exploit.module.library.get_metax = function()
    return Exploit.module.get_local_lib("metaxploit.so")
end function 

Exploit.module.library.get_crypto = function()
    return Exploit.module.get_local_lib("crypto.so")
end function 

Exploit.module.parse_exploits = function(library, database = 0)
    exploit_map = {}

    if not database then database = Session.db.parse("exploit")
    if database then 
        if database.hasIndex(library.lib_name) then 
            if ((database[library.lib_name].hasIndex(library.version) and database[library.lib_name][library.version].indexes.len > 0) and not Exploit.is_scan_mode()) then 
                memory_address_arr = database[library.lib_name][library.version].indexes
                
                for address in memory_address_arr 
                    unsafe_value_arr = self.get_payloads(library, 0, address, database)
                    exploit_map[address] = unsafe_value_arr
                end for 

                if exploit_map.len then return _callback.catch(exploit_map, 1)
            end if
        end if
        print
        printb(("[expl][attack][notif]: library " + library.lib_name + " v" + library.version + " not found in database...").c("black black purple"))
    end if

    print 
    printb("commencing scan...".c("purple"))
    print

    memory_address_arr = self.library.get_metax().scan(library)
    for address in memory_address_arr
        unsafe_value_arr = []
        output = self.library.get_metax().scan_address(library, address)
        for line in output.split(c10)
            if tp(line.indexOf("</b>.")) == "number" then unsafe_value_arr.push(slice(line, line.indexOf("<b>"), line.indexOf("</b>"))[3:])
        end for 
        exploit_map[address] = unsafe_value_arr
    end for 

    return _callback.catch(exploit_map, 1)
end function 

Exploit.module.run_exploits = function(payload_arr = [], database, memory_address, lan_address, library, change_password = 0, database = 0, set_db = 1)
    if not payload_arr.len then return false 
    
    if not database then database = {}
    exploit_arr = []
    for payload in payload_arr
        if change_password then object = library.overflow(memory_address, payload, change_password) else object = library.overflow(memory_address, payload)
        if tp(object) == "null" then continue 
        if tp(object) == "number" then 
            printb("password changed or firewall bypassed...".c("black"))
            printb(("in case, new password is: "+ change_password).c("black black purple"))
            continue 
        end if 
        
        exploit = self.create_exploit(payload_arr, memory_address, library.lib_name, library.version)
        exploit_arr.push(exploit)
    
        self.add_exploit(exploit, library, database, set_db)

        if not Exploit.module.allocate(object, lan_address) and (Exploit.device.get(lan_address) and Exploit.device.get(lan_address)[tp(object) + "s"].len) then continue 
    
        Exploit.device.add(object, lan_address)
        Exploit.device.add_user(lan_address, Session.get_user(object))
    end for 
    
    Exploit.device.align_ip_addresses()
    
    return exploit_arr 
end function

Exploit.module.grab_ports = function(ip_address, must_match = [], all = 0)
    match_arr = []
    remote_router = get_router(ip_address)
    if tp(remote_router) == "null" then return false 
    ports_arr = remote_router.used_ports
    if all then return ports_arr

    for port in ports_arr 
        if tp(must_match.indexOf(str(port.port_number))) == "number" then match_arr.push(port)
    end for 

    return match_arr
end function

Exploit.module.malware = {}
Exploit.module.malware.send = function(shell_instance, malware_src_name, malware_prompt, malware_src_content, rpc_data = {})
    try_set_endpoint = Session.rpc.set_endpoint(shell_instance, malware_src_name, malware_src_content)
    if not try_set_endpoint.status then return try_set_endpoint

    try_send_data = Session.rpc.data.send(shell_instance, try_set_endpoint.data, malware_prompt, rpc_data, 1)
    return try_send_data
    //use to build trojan and rat commands. trojans are traps, rats are ran by us.
end function 

Exploit.module.malware.catch = function()
    return Session.rpc.data.catch() // callback must accept param custom_obj that houses rpc return data
end function 

Exploit.scout = function()

end function

Exploit.attack = function(lan_address, change_password = 0, third_arg)
    memory_arr = []
    //we will store mems and payloads by object type 
    //this allows recon command and Exploit.scout to 
    //avoid shell objects because it will only scan
    library = self.get_net_session().dump_lib
    if tp(Session.machine.ip.get_lan_address_arr().indexOf(Session.machine.ip.get_lan_address())) != "number" then Session.machine.ip.add_lan_address(lan_address)
    if tp(self.module.library.get_metax().rshell_server) != "list" then rshell_arr = [] else rshell_arr = Exploit.module.library.get_metax().rshell_server 

    exploit_map = self.module.parse_exploits(library)
    saved_database = Session.db.parse("exploits")
    memory_address_arr = exploit_map.data.indexes

    for address in memory_address_arr 
        _callback.debug(third_arg, "internal".c("purple"), 1080)
        self.module.run_exploits(exploit_map.data[address], saved_database, address, lan_address, library, third_arg) //change_password json
    end for 
    printb(a + ("*** attack on '" + hide_ip(Session.machine.ip.get_pub_address_arr()[-1]) + "@" + hide_ip(lan_address) + "' completed ***").c("purple"))

    return _callback.catch("", 1)
end function

Usage = {}
Usage.usage_object_map = {}
Usage.display = function(cmd_name, usage_object)
    print
    printb(("command name: ").upper.c("black") + cmd_name.upper.c("purple"))
    printb("long: ".upper.c("black") + usage_object.long.c("black black purple"))
    printb("short: ".upper.c("black") + usage_object.short.c("black black purple"))
    print
    printb("usage: ".upper.c("black"))
    for usage_line in usage_object.usage_arr 
        printb(" " + usage_line.c("black black purple"))
    end for 
    print 
    printb("desc: ".upper.c("black"))
    print " " + usage_object.desc.c("black black purple")
    print
end function 

Usage.create_usage_object = function(cmd_name, usage_arr, description, long, short)
    self.usage_object_map[cmd_name] = {"usage_arr": usage_arr, "desc": description, "long": long, "short": short}
    return self.usage_object_map[cmd_name]
end function

Usage.get_usage_object = function(cmd_name) 
    return self.usage_object_map[cmd_name]
end function 

Usage.notify_library_missing = function(library_name, cmd_name)
    printb("[blbx][" + cmd_name + "][err]: library '" + library_name + "' missing from local machine...")
    add_line
    printb("*** run the following ***")
    printb(wisp + "[#]:> sw 1 -p[1542, 80]")
    printb("* copy the public ip address *")
    printb(wisp + "[#]:> apt addrepo <ip_address>")
    printb(wisp + "[#]:> update -deps") // will be extended to update the tool automatically or by prompt on start up
end function 

Usage.init = function()
    //  {"cmd_name": "ls", "usage_arr": [" clear ", " cls ", " cs "], "desc": "clears terminal screen and displays next input.", "long": "clear", "short": "cls | cs"}
    linux_cmd_arr = [{"cmd_name": "clear", "usage_arr": [" clear ", " cls ", " cs "], "desc": "clears terminal screen and displays next input.", "long": "clear", "short": "cls | cs"}, {"cmd_name": "exit", "usage_arr": [" exit "], "desc": "leaves the blbx process and exits program.", "long": "exit", "short": "-q"}, {"cmd_name": "ls", "usage_arr": [" ls [<file_path> | <file_name>]"], "desc": "displays files and directories found in a directory.", "long": "ls", "short": ""}, {"cmd_name": "cd", "usage_arr": [" cd [<file_path> | <file_name>] ", " cd ... ", " cd .. ", " cd . " , " cd "], "desc": "navigates shell instance to directory.", "long": "cd", "short": ""}, {"cmd_name": "cat", "usage_arr": [" cat [<file_name> | <file_path>] "], "desc": "displays the contents of a text file on terminal.", "long": "cat", "short": ""},  {"cmd_name": "rm", "usage_arr": [" rm [<file_name> | <file_path>] "], "desc": "removes file or directory from machine.", "long": "rm", "short": ""}, {"cmd_name": "ifconfig", "usage_arr": [" ifconfig ", " ifconfig -help "], "desc": "clears terminal screen and displays next input.", "long": "ifconfig", "short": "ifc"}]
    custom_cmd_arr = [{"cmd_name": "find", "usage_arr": [" find [<file_name> | <file_path>] OPTION: -content "], "desc": "recursively finds a file on machine and displays its path and content by option.", "long": "find", "short": "--f"},  {"cmd_name": "apt", "usage_arr": [" apt [-upgrade | -upg] ", " apt [-update | -upd] ", " apt [-addrepo | -ar] ", " apt [-delrepo | -dr] ", " apt [-search | -sch] ", " apt [-show | -shw] ", " apt [-install | -i] "], "desc": "handles repository commands for local machine.", "long": "apt", "short": ""},  {"cmd_name": "attack", "usage_arr": [" attack <ip_address> OPTION: -port[<port_number>, ...] | -p[...] OPTION: [-scan | -s] -cgp -fw "], "desc": "attacks target ip address on all ports unless specified. also attacks router and changes password and bypasses firewalls.", "long": "attack", "short": "-atk"},  {"cmd_name": "rat", "usage_arr": [" rat [-rshell | -rsh] ", " rat [-scan_nw | -snw] ", " rat [-dict | -d] ", " rat [-esc | -e] ", " rat -bounce[<lan_address>, <library_name>] | -b[...] ", " rat -escalate[<as_user>, <password>] "], "desc": "rat exploit that remotely runs scripts to reverse shell, scan the network, dictionary attack, or escalate permissions.", "long": "rat", "short": ""}, {"cmd_name": "connect", "usage_arr": [" connect <lan_address> OPTION: <as_user> "], "desc": "initializes the emulated remote shell instance without starting a shell. now you can use linux and exploiting commands on the remote victim.", "long": "connect", "short": "con"}, {"cmd_name": "sweep", "usage_arr": [" sweep <target_amount> OPTION: -port[<port_number>, ...] "], "desc": "finds random ip addresses to attack or investigate.", "long": "sweep", "short": "sw"}, {"cmd_name": "nmap", "usage_arr": [" nmap <ip_address> ", " nmap <domain_address> "], "desc": "displays available open and closed ports on a target ip address.", "long": "nmap", "short": ""}, {"cmd_name": "disconnect", "usage_arr": [" disconnect "], "desc": "exits emulated shell connection and starts operating with local machine objects.", "long": "disconnect", "short": "dc"}, {"cmd_name": "dia", "usage_arr": [" dia -setup ", " dia -add_bot ", " dia -add_bridge ", " dia -monitor ", "dia -sniff[<ip_address>, ...]", " dia -decrypt ", " dia expand <bot_amount> ", " dia visit -bridge[<ip_address>, <lan_address>] ", " dia visit -bot[<ip_address>, <lan_address>] ", "  "], "desc": "clears terminal screen and displays next input.", "long": "clear", "short": "cls | cs"}, {"cmd_name": "load", "usage_arr": [" load [-dictionary | -dict | -d] ", " load [-exploit | -expl | -e] ", " load [-botnet | -bot | -b] "], "desc": "parses and loads large data sets for use by other commands. this command is pipe-applicable.", "long": "load", "short": "ld"}, {"cmd_name": "creds", "usage_arr": [" creds [-passwd | -pass | -p] ", " creds [-bank | -b] ", " creds [-mail | -m] "], "desc": "finds the corresponding text files and lists. their contents. piping is allowed.", "long": "creds", "short": "cred"}, {"cmd_name": "decipher", "usage_arr": [" decipher [hash | 'hash'] OPTION: [-scan | -s]"], "desc": "looks for md5 in the [blbx] lookup table, called [blt], or scans the hash to decipher it.", "long": "decipher", "short": "dec"}]
    syntax_cmd_arr=  [{"cmd_name": "syntax_assign", "usage_arr": [" variable = <variable_name> ", " variable = <command> ",  " variable = <literal> ",  " variable = <ip_address> "], "desc": "environment varables allow commands to access data that is saved in runtime state and. it is recovered on startup, and saved on every update do the database.", "long": "=", "short": ""}]

    cmd_arr = linux_cmd_arr + custom_cmd_arr + syntax_cmd_arr

    for cmd in cmd_arr 
        self.create_usage_object(cmd.cmd_name, cmd.usage_arr, cmd.desc, cmd.long, cmd.short)
    end for 

    return true 
end function 

Wifi = {}
Wifi.connect = function()
    wifi_info=Directory.find_file(get_shell.host_computer.File("/"), 0, "gift.txt")
    crypto=Exploit.module.library.get_crypto();crypto.airmon("start", "wlan0")
    if tp(crypto) == "null" then 
        printb("* * missing 'crypto.so' library. wifi connection failed * *".color("black"))
        printb("* * you've been bricked. not a problem. hop on discord! * *".c("black black purple"))
        printb("*** see <u>https://discord.greyhack.gg</u> ***".c("black black purple"))
        return false
    end if
    
    try_connection = false
    if tp(wifi_info) == "file" and wifi_info.get_content.split(c10)[0] == "Wifi access:" then
        bssid = wifi_info.get_content.split(c10)[3]
        essid = wifi_info.get_content.split(c10)[4]
        passwd = wifi_info.get_content.split(c10)[5].split(": ")[1]
        try_connection = get_shell.host_computer.connect_wifi("wlan0", bssid, essid, passwd)
        printb(a + "*** gift.txt found, attempting conection ***".c("purple"))
        if try_connection == 1 then 
            printb(a + ("** connected to '" + essid + "@" + passwd + "' **").c("purple"))
            return true
        end if
        if tp(try_connection) == "string" then printb("* * " + try_connection.lower + " * *".c("black black purple"))
        if tp(try_connection) == "null" then printb("* * failed to connect to '" + essid + "@" + passwd + "' * *".c("black black purple"))
    end if 
    if not try_connection then 
        printb(a + "* * gift.txt not found, proceeding with exploits... * *".c("black black purple"))
        wait(2)
    end if
    bssid_array=[];essid_array=[];pl=[]
    for i in get_shell.host_computer.wifi_networks("wlan0")
        i=i.split(" ")
        bssid_array.push(i[0]);essid_array.push(i[2]);power_array.push(i[1][:-1].to_int)
    end for

    index=power_array.indexOf(power_array.sort[-1])
    bssid=bssid_array[index];essid=essid_array[index];power=(300000/power_array.sort[-1])
    file_capture=objects.nf(get_shell.host_computer.File("/"), 0, "file.cap")

    if tp(file_capture) != "file" or tp(file_capture) == "file" and tp(crypto.aircrack(file_capture.path)) == "null" then
        printb("* * failed to connect to optimal network***".c("black black purple"))
        printb("* * use the [blbx] linux commands to connect manually * *".c("black black purple"))
        printb("*** see [help] ***".c("black black purple"))
        return false 
    end if 

    add_line
    printb(("*** hacking target '" + essid + "'. ACK packet goal is (" + str(round(power)) + ") ***").c("black black purple"))
    printb("*** please wait ***".c("black"))
    add_line

    try_aireplay = crypto.aireplay(bssid, essid, power)
    if tp(try_aireplay) == "string" then 
        printb("* * " + try_aireplay + " * *".c("black"))
        printb("* * use the [blbx] linux commands to connect manually * *".c("black black purple"))
        printb("*** see [help] ***".c("black black purple"))
        return false
    end if

    file_cap = Directory.find_file(get_shell.host_computer.File("/"), 0, "file.cap").path
    if not file_cap then 
        printb("* * failed to create file.cap... * *".c("black black purple"))
        printb("* * use the [blbx] linux commands to connect manually * *".c("black black purple"))
        printb("*** see [help] ***".c("black black purple"))
        return false 
    end if 
    printb("*** attempting file.cap aircrack ***".c("black black purple"))
    passwd = crypto.aircrack()
    try_aircrack = get_shell.host_computer.connect_wifi("wlan0", bssid, essid, passwd)
    if tp(try_aircrack) == "string" then 
        printb("* * " + try_aircrack.lower + " * *".c("black"))
        printb("* * use the [blbx] linux commands to connect manually * *".c("black black purple"))
        printb("*** see [help] ***".c("black black purple"))
        return false 
    end if
    if tp(try_aircrack) == "null" then 
        printb("* * failed to connect to '" + essid + "@" + passwd + "' * *".c("black"))
        printb("* * use the [blbx] linux commands to connect manually * *".c("black black purple"))
        printb("*** see [help] ***".c("black black purple"))
        return false 
    end if
    if try_aircrack == 1 then printb("*** connected to '" + essid + "@" + passwd + "' ***".c("purple"))
    wait(2)
    return true
end function

Params = {}
Params.extract_type = function(PARAMS, token_type_arr)
    instances = []
    _callback.local_debug(PARAMS, "<color=blue>PARAMS", 1363)
    for param_token in PARAMS
        for token_type in token_type_arr
            if param_token.type == token_type then 
                instances.push(param_token)
                continue 
            end if
        end for 
    end for 
    _callback.local_debug(instances, "<color=red>extract_types, internal", 1372)
    return instances
end function

Params.extract_flags = function(PARAMS) 
    result_flags = []
    for token in PARAMS 
        if token.type != TokenTypes.Flag then continue 
        result_flags.push(token)
    end for

    return result_flags
end function 

Params.extract_flag_content = function(flag)
    return flag.split("\[|\]|\,|\s").clean([""])
end function

Params.translate_input_brackets = function(input_string)
    toggle_bracket = false 
    result = ""
    for ch in input_string 
        if ch == "#" and not toggle_bracket then 
            result = result + "["
            toggle_bracket = true
            continue 
        end if  
        if ch == "#" and toggle_bracket then 
            result = result + "]"
            toggle_bracket = false
            continue 
        end if 
        result = result + ch 
    end for 

    return result 
end function

Dictionary = {}
Dictionary.lookup_table = []

Dictionary.set_lookup_table = function(new_lookup_table)
    self.lookup_table = new_lookup_table
    return self.lookup_table
end function

Dictionary.parse_lookup_table = function()
    if not self.lookup_table.len then 
        clear_screen
        printb(a + "*** parsing dictionary attack lookup table ***".c("purple"))
        prompt_proceed = ui(a + b + "* * proceed? Y/n * *".c("black black purple") + "\n\n\n" + Prompt.get_message())
        if prompt_proceed.search("y") then self.set_lookup_table(Session.db.speed_parse("dictionary"))
    end if 
end function 

Dictionary.get_lookup_table = function()
    self.parse_lookup_table()
    return self.lookup_table
end function

Dia = {}
Dia.bridge = {}
Dia.bridge.network = {}

Dia.bridge.endpoint = {}

Dia.bridge.endpoint.add_bot = function(shell_instance)
    comp_instance = shell_instance.host_computer
    
end function

// internal
