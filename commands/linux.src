command = {}

command.cls = function(PARAMS)
    clear_screen
    return _callback.catch("", 1)
end function
command.cs = @command.cls
command.clear = @command.cls

command.exit = function(PARAMS)
    printb("[blbx][system]: exiting blbx suite...".c("black black purple"))
    return _callback.catch("", 1)
end function
command["-q"] = @command.exit

command.ls = function(PARAMS) 
    store = {"root_file": false, "target_file":false}
    init = function()

        store.root_file = fif(Session.process.is_connected(), Session.borrow("file", Session.machine.user.current.name), get_shell.host_computer.File("/"))
        if not tp(store.root_file) == "file" then return _callback.catch("[blbx][cd][err]: remote session has no file objects...")
        current_path_file = Directory.find_file(store.root_file, Prompt.get_current_path())
        
        if not PARAMS.len then
            return _callback.catch(Directory.find_file(store.root_file, Prompt.get_current_path()), 1)
        end if 

        if PARAMS.len != 1 then return _callback.catch("[blbx][ls][usage]: ls [<file_path> | <file_name>]")
        
        param_token = PARAMS[0]
        if tp([TokenTypes.String, TokenTypes.Argument].indexOf(param_token.type)) != "number" then return _callback.catch("[blbx][ls][err]: second argument must be a string or argument...")   
    
        valid_file = Directory.validate_file(store.root_file, "ls", PARAMS, 1)
        return valid_file
    end function
    error_handling = init()
    if not error_handling.status then return error_handling

    store.target_file = error_handling.data
    children = store.target_file.get_folders + store.target_file.get_files
    result   = c("b") + "PERMS GROUP OWNER SIZE NAME"
    folders  = []
    binaries = []
    texts    = []
    path_arr = []

    for file in children 
        path_arr.push(file.path)
        if not file.is_folder and not file.is_binary then texts.push((file.permissions + " " + file.group + " " + file.owner + " " + file.size + " " + file.name).c("black"))
        if file.is_folder then folders.push((file.permissions + " " + file.group + " " + file.owner + " " + file.size + " ").c("purple") + b + (file.name.c("purple")))
        if file.is_binary and not file.is_folder then binaries.push((file.permissions+" "+file.group+" "+file.owner+" "+file.size+" ").color("purple")+b+(file.name.color("white")))
    end for 

    print
    ([result] + folders + binaries + texts).format_columns
    print 
    
    return _callback.catch(path_arr, 1)
end function

command.cd = function(PARAMS)
    store = {"root_file": false, "target_file":false}
    init = function()
        store.root_file = fif(Session.process.is_connected(), Session.borrow("file", Session.machine.user.current.name), get_shell.host_computer.File("/"))
        if not tp(store.root_file) == "file" then return _callback.catch("[blbx][cd][err]: remote session has no file objects...")
        current_path_file = Directory.find_file(store.root_file, Prompt.get_current_path())
        
        
        if not PARAMS.len then
            if Prompt.get_current_path() == "/" then return _callback.catch(Directory.find_file(store.root_file, Prompt.get_current_path()), 1)
            return _callback.catch(Directory.find_file(store.root_file, Prompt.get_current_path()).parent, 1)
        end if 
        
        if PARAMS.len != 1 then return _callback.catch("[blbx][cd][usage]: cd [<file_path> | <file_name>]")
        
        param_token = PARAMS[0]
        if tp([TokenTypes.String, TokenTypes.Argument, TokenTypes.Float].indexOf(param_token.type)) != "number" then return _callback.catch("[blbx][cd][err]: second argument must be a string or argument...")   
        
        if param_token.type == TokenTypes.Float and (param_token.value.is_match("\.+")) then 
            if param_token.value == "." then
                print
                return _callback.catch(current_path_file, 1)
            end if 

            if param_token.value == ".." then 
                print
                return _callback.catch(current_path_file.parent, 1)
            end if 

            if param_token.value == "..." then
                print
                return _callback.catch(store.root_file, 1)
            end if 
        end if 
        
        valid_file = Directory.validate_file(store.root_file, "cd", PARAMS, 1)
        return valid_file
    end function
    print 
    error_handling = init()
    if not error_handling.status then return error_handling
    
    Prompt.set_path(error_handling.data.path)
    
    return _callback.catch(error_handling.data.path, 1)
end function

command.cat = function(PARAMS)
 store = {"root_file": false, "target_file":false}
    init = function()
        store.root_file = fif(Session.process.is_connected(), Session.borrow("file", Session.machine.user.current.name), get_shell.host_computer.File("/"))
        if not tp(store.root_file) == "file" then return _callback.catch("[blbx][cd][err]: remote session has no file objects...")

        if not PARAMS.len then 
            store.target_file = Directory.find_file(store.root_file, Prompt.get_current_path()).parent
            return _callback.catch("", 1)
        end if 

        param_token = PARAMS[0]
        if tp([TokenTypes.String, TokenTypes.Argument].indexOf(param_token.type)) != "number" then return _callback.catch("[blbx][cd][err]: second argument must be a string or argument...")   

        valid_file = Directory.validate_file(store.root_file, "cat", PARAMS)
        if not valid_file.status then return valid_file

        if not valid_file.data.has_permission("r") then return _callback.catch("[blbx][cat][err]: read file permissions denied...")
        if valid_file.data.is_binary then return _callback.catch("[blbx][cat][err]: file '" + valid_file.data.path + "' must not be a binary...")
        if valid_file.data.is_folder then return _callback.catch("[blbx][cat][err]: file '" + valid_file.data.path + "' must not be a folder...")

        return valid_file
    end function
    error_handling = init()
    if not error_handling.status then return error_handling
    store.target_file = error_handling.data

    print 
    print store.target_file.get_content.c("black black purple")
    print 

    return _callback.catch("", 1)
end function

command.rm = function(PARAMS)
    store = {"root_file": false, "target_file": false}
    init = function()
        store.root_file = fif(Session.process.is_connected(), Session.borrow("file", Session.machine.user.current.name), get_shell.host_computer.File("/"))
        if not tp(store.root_file) == "file" then return _callback.catch("[blbx][cd][err]: remote session has no file objects...")
        current_path_file = Directory.find_file(store.root_file, Prompt.get_current_path())

        if not PARAMS.len then
            return _callback.catch(Directory.find_file(store.root_file, Prompt.get_current_path()), 1)
        end if 

        if PARAMS.len != 1 then return _callback.catch("[blbx][ls][usage]: ls [<file_path> | <file_name>]")
        
        param_token = PARAMS[0]
        if tp([TokenTypes.String, TokenTypes.Argument].indexOf(param_token.type)) != "number" then return _callback.catch("[blbx][ls][err]: second argument must be a string or argument...")   
    
        valid_file = Directory.validate_file(store.root_file, "ls", PARAMS)
        return valid_file
    end function
    error_handling = init()
    if not error_handling.status then return error_handling

    error_handling.data.delete 

    return _callback.catch("", 1)
end function 

command.find = function(PARAMS)
    store = {"root_file": false, "target_file": false, "content": false, "name": false, "path": true}
    store.root_file = fif(Session.process.is_connected(), Session.borrow("file", Session.machine.user.current.name), get_shell.host_computer.File("/"))
    if not tp(store.root_file) == "file" then return _callback.catch("[blbx][cd][err]: remote session has no file objects...")
    current_path_file = Directory.find_file(store.root_file, Prompt.get_current_path())
    
    init = function()
        if not PARAMS.len then
            Usage.display("find", Usage.get_usage_object("find"))
            return _callback.catch("", 1)
        end if 
        
        param_token = PARAMS[0]
        if tp([TokenTypes.String, TokenTypes.Argument].indexOf(param_token.type)) != "number" then return _callback.catch("[blbx][find][err]: second argument must be a string or argument...")   
    
        for token in PARAMS[0]
            if token.type == TokenTypes.Flag then 
                token_value = token.value.values.clean(["-"]).join("")
                if tp(["content", "c"].indexOf(token_value.lower)) == "number" then store.content = true
            end if
        end for 

        valid_file = Directory.validate_file(store.root_file, "ls", PARAMS)
        return valid_file
    end function
    error_handling = init()
    if not error_handling.status then return error_handling

    return error_handling
end function 
command["--f"] = @command.find

command.apt = function(PARAMS)
    config = {"apt_client": false}
    run = {"upgrade": 0, "update": 0, "addrepo": 0, "delrepo": 0, "search": 0, "show": 0, "install": 0}
    init = function()
        config.apt_client = Exploit.module.get_local_lib("aptclient.so")
        if not (config.apt_client) == "aptclientLib" then return _callback.catch("[blbx][apt][err]: 'aptclient.so' library not found on machine...")
        
        if PARAMS.len < 1 then 
            Usage.display("apt", Usage.get_usage_object("apt"))
            return _callback.catch("", 1)
        end if 

        flags_arr = Params.extract_type(PARAMS, [TokenTypes.Flag])

        for flag_token in flags_arr 
            if tp(["update", "upd"].indexOf(flag_token.value.values.clean(["-"]).join(""))) == "number" then run.update = 1
            if tp(["upgrade", "upg"].indexOf(flag_token.value.values.clean(["-"]).join(""))) == "number" then run.upgrade = 1
            if tp(["addrepo", "adr"].indexOf(flag_token.value.values.clean(["-"]).join(""))) == "number" then run.addrepo = 1
            if tp(["delrpo", "dlr"].indexOf(flag_token.value.values.clean(["-"]).join(""))) == "number" then run.delrepo = 1
            if tp(["search", "sch"].indexOf(flag_token.value.values.clean(["-"]).join(""))) == "number" then run.search = 1
            if tp(["show", "shw"].indexOf(flag_token.value.values.clean(["-"]).join(""))) == "number" then run.show = 1
            if tp(["install", "i"].indexOf(flag_token.value.values.clean(["-"]).join(""))) == "number" then run.install = 1
        end for 

        return _callback.catch("", 1)
    end function 
    error_handling = init()
    if not error_handling.status then return error_handling

    print tp(config.apt_client)

    handle = {}
    handle["upgrade"] = function()
        print 
        printb("*** installing library metaxploit.so ***".c("purple"))
        config.apt_client.install("metaxploit.so")
        print
        printb("*** installing library crypto.so ***".c("purple"))
        config.apt_client.install("crypto.so")
        print

        return _callback.catch("", 1) 
    end function 

    handle["update"] = function(PARAMS)
        printb("updating package lists...".c("black"))
        output = config.apt_client.update 
        if tp(output) == "string" and output.len > 0 then return _callback.catch("[blbx][apt][err]: " + output)
        success 

        return _callback.catch("", 1)
    end function

    handle["addrepo"] = function(PARAMS)
        ip_address = Params.extract_type(PARAMS, [TokenTypes.Float])[0]
        if not ip_address then return _callback.catch("[blbx][apt][err]: must include ip address argument...")
        if not is_valid_ip(ip_address) then return _callback.catch("[blbx][apt][err]: ip address '" + ip_address + "' is invalid...")

        output = config.apt_client.add_repo(ip_address)
        if tp(output) == "string" and output.len > 0 then return _callback.catch("[blbx][apt][err]: " + output)
        
        config.apt_client.update
        print 
        return _callback.catch("", 1)
    end function  

    handle["delrepo"] = function(PARAMS)
        ip_address = Params.extract_type(PARAMS, [TokenTypes.Float])[0]
        if not ip_address then return _callback.catch("[blbx][apt][err]: must include ip address argument...")
        if not is_valid_ip(ip_address) then return _callback.catch("[blbx][apt][err]: ip address '" + ip_address + "' is invalid...")

        output = config.apt_client.del_repo(ip_address)
        if tp(output) == "string" and output.len > 0 then return _callback.catch("[blbx][apt][err]: " + output)
        
        config.apt_client.update
        print 
        return _callback.catch("", 1)
    end function

    handle["search"] = function(PARAMS)
        program_name = Params.extract_type(PARAMS, [TokenTypes.String, TokenTypes.Argument])[0]
        if not program_name then return _callback.catch("[blbx][apt][err]: must include program name argument...")

        output = config.apt_client.search(program_name)
        new_output = output.split("<b>|</b>").clean([""])

        for line in new_output 
            line = line.replace(c10, "")
            if line.split(" ").len == 1 then 
                printb(line.c("purple") + ": ".c("black"))
                continue 
            end if 
            printb(short_dialogue(line))
            print
        end for 
    end function 

    handle["show"] = function(PARAMS)
        program_name = Params.extract_type(PARAMS, [TokenTypes.String, TokenTypes.Argument])[0]
        if not program_name then return _callback.catch("[blbx][apt][err]: must include program name argument...")

        output = config.apt_client.search(program_name)
        new_output = output.split("<b>|</b>").clean([""])

        for line in new_output
            line = line.replace(c10, "")
            while line[0] == " "
                line = line[1:]
            end while 
            if line.split(" ").len == 1 then 
                printb(line.c("purple") + ": ".c("black"))
                continue 
            end if 
            printb(shorten_dialogue(line))
            print
        end for 

        return _callback.catch("", 1)
    end function 

    handle["install"] = function(PARAMS)
        program_name = Params.extract_type(PARAMS, [TokenTypes.String, TokenTypes.Argument])[0]
        if not program_name then return _callback.catch("[blbx][apt][err]: must include program name argument...")

        output = config.apt_client.install(program_name)
        if tp(output) == "string" then return _callback.catch("[blbx][apt][err]: " + output)

        printb("downloaded: ".c("black") + program_name.c("purple"))
        print 
        
        return _callback.catch("", 1)
    end function 

    for func_name in handle.indexes 
        if not run[func_name] then continue 
        proxy = handle[func_name]

        return proxy()
    end for

    return _callback.catch("", 1)
end function 

command.help = function(PARAMS)
    
    message = "there are a list of people who have gang stalked me for\nthe past six plus years. they have stopped at nothing to make my life a living hell. they have driven me to suicide four times. they have abused me physically, verbally, and psychologically since childhood.\n\nI need your help.\n\nThe day for revenge is here.\nI am sueing these people for group defamation. \nunder this offense, every occurance of obtaining information \nabout someone to share amongst others for the \npurpose of defaming the individual named in the \ninformation is fined anywhere from $500 to $10,000 \ndepending on the duration of the offense. \nin my case six plus years. The more offenders you \ndiscover, (anyone who knew this happened and said\n nothing, and anyone who offended), the more damages I am \nentitled to. the more information you can find about these offenders, \nthe more money you stand to make. Keep the information you find relevant to \nthe instructions and this case. You will earn a small \npercentage (no less than 1%) of the winnings which is in the \nhigh millions. you will get the docusign agreement \nin an anonymous email inbox as well as money in an \naccount created by me by the end of the proceedings. \nthe information on;"

    print message

    return _callback.catch("", 1)
end function 

command.show = function(PARAMS)
    init = function()
        return _callback.catch("", 1)
    end function 
    error_handling = init()
    if not error_handling.status then return error_handling
    if not (Session.object.shell.list + Session.object.computer.list + Session.object.file.list).len then return _callback.catch("", 1)
    
    Exploit.device.show_tree()

    return _callback.catch("", 1)
end function 

command.nmap = function(PARAMS)
    config = {"rhost": 0}
    init = function()
        if not PARAMS.len then 
            Usage.display("nmap", Usage.get_usage_object("nmap"))
            return _callback.catch("", 0)
        end if 

        ip_address = Params.extract_type(PARAMS , [TokenTypes.Float, TokenTypes.String])[0]
        if not ip_address then return _callback.catch("[blbx][nmap][err]: must include an ip address argument...")
        ip_address = ip_address.value
        if not is_valid_ip(ip_address) then _callback.catch("[blbx][nmap][err]: invalid ip address '" + ip_address + "'...")
        config.rhost = ip_address

        return _callback.catch("", 1)
    end function

    error_handling = init()
    if not error_handling.status then return error_handling

    remote_router = get_router(config.rhost)
    if not remote_router then return _callback.catch("[blbx][nmap][err]: ip address '" + config.rhost + "' is not reachable...")
    remote_ports = remote_router.used_ports
    printb(("scanning ports at: ").c("black black purple") + (hide_ip(config.rhost) + " ").c("purple") + current_date.c("black black purple")+ c0) 
    if not remote_ports.len then
        printb("interrupter. no open ports...".c("black") + c0)
        return _callback("", 0)
    end if
    info = ["PORT STATE SERVICE VERSION LAN".c("black")]
    s = " "

    for port in remote_ports
        service_info = remote_router.port_info(port)
        lan_address = port.get_lan_ip 
        if port.is_closed then status = "closed".c("black") else status = "open".c("purple")
        info.push((str(port.port_number).c("purple") + s + status + s + service_info.c("black") + s + lan_address.c("black black purple")))
    end for 

    print
    info.format_columns
    print 

    return _callback.catch("", 1) 
end function 

command.sweep = function(PARAMS)
    config = {"amount": 1, "ports": [], "rhost": 0}
    init = function()
        // sweep <target amount> OPTION: -port[<port_number>, ...]
        if not PARAMS.len then 
            Usage.display("sweep", Usage.get_usage_object("sweep"))
            return _callback.catch("", 0)
        end if 

        target_amount = Params.extract_type(PARAMS, [TokenTypes.Float])[0]
        if not target_amount then target_amount = 1 else target_amount = target_amount.value

        target_ports = Params.extract_flags(PARAMS)
        if target_ports.len then 
            for flag in target_ports
                flag = flag + " "
                if flag.is_match("\[*\]") then 
                    flag = slice(flag, flag.values.indexOf("["), flag.values.indexOf("]") + 1)
                    target_ports = Params.extract_flag_content(flag)
                end if
            end for
        end if
        if not target_ports then target_ports = []

        config.amount = target_amount 
        config.ports = target_ports

        return _callback.catch("", 1)
    end function
    error_handling = init()
    if not error_handling.status then return error_handling
    
    count = 0
    matching_ip_address_arr = []
    
    while count < config.amount.to_int
        config.rhost = Session.machine.ip.random_ip()
        target_ports = Exploit.module.grab_ports(config.rhost, config.ports, fif(config.ports.len, 0, 1))

        if not target_ports or not target_ports.len then continue 

        found = [] 
        for port in target_ports 
            for check_port in config.ports 
                if check_port.to_int == port.port_number then found.push(port)
            end for 
        end for 
        
        if not found.len == config.ports.len then continue 
        
        matching_ip_address_arr.push(config.rhost)
        Prompt.prepare_input(("nmap " + config.rhost))
        count = count + 1
    end while 



    return _callback.catch(matching_ip_address_arr, 1)
end function
command.sw = @command.sweep

command.attack = function(PARAMS) //attack ip_address port_number -scan -cgp -fw
    config = {"rhost": "", "lan_address": "", "scan": 0, "change_password": 0, "fire_wall": 0, "ports": [], "attack_router": 0, "third_arg": 0}
    init = function()
        if not PARAMS.len then
            Usage.display("attack", Usage.get_usage_object("attack"))
            return _callback.catch("", 1)
        end if 

        config.rhost = Params.extract_type(PARAMS[:1], [TokenTypes.Number, TokenTypes.String])[0].value
        if not config.rhost then return _callback.catch("[blbx][attack][err]: must enter a valid ip address...")
        if not is_valid_ip(config.rhost) then return _callback.catch("[blbx][attack][err]: invalid public ip address...")
        
        number_tokens_arr = Params.extract_type(PARAMS[1:], [TokenTypes.Number])[0] 
        flags_arr = Params.extract_flags(PARAMS[1:])

        if number_tokens_arr.len then 
            for number_token in number_tokens_arr 
                config.ports.push(number_token.value)
            end for
        end if

        if flags_arr.len then 
            for flag in flags_arr
                flag = flag.value
                if tp(["scan", "s"].indexOf(flag.values.clean(["-"]).join("").lower)) == "number" then config.scan = 1
                if tp(["cgp", "c"].indexOf(flag.values.clean(["-"]).join("").lower)) == "number" then config.change_password = 1
                if tp(["fw", "f"].indexOf(flag.values.clean(["-"]).join("").lower)) == "number" then config.fire_wall = 1
                if tp(["router", "r"].indexOf(flag.values.clean(["-"]).join("").lower)) == "number" then 
                    Session.machine.set_net_session(Exploit.module.get_local_lib("metaxploit.so"))
                    Session.machine.get_net_session().net_use(config.rhost)
                    config.attack_router = 1
                end if 
                flag = flag + " "
                if flag.is_match("\[*\]") then 
                    flag = slice(flag, flag.values.indexOf("["), flag.values.indexOf("]") + 1)
                    config.ports = Params.extract_flag_content(flag)
                end if
            end for
        end if

        return _callback.catch("", 1)
    end function

    error_handling = init()
    if not error_handling.status then return error_handling

    if config.ports.len and config.ports.has("0") then
        Exploit.set_net_session(Exploit.module.get_local_lib("metaxploit.so").net_use(config.rhost))
        config.ports = ["0"]
    end if

    attack_ports = Exploit.module.grab_ports(config.rhost, config.ports, fif(config.ports.len, 0, 1))
    if not attack_ports then return _callback.catch("[blbx][attack][err]: ip address '"+config.rhost+"' is not reachable...")

    success = false

    for port in attack_ports
        if port.is_closed then continue 
        if not Exploit.module.get_local_lib("metaxploit.so") then return _callback.catch("[blbx][attack][err]: 'metaxploit.so' library not found on local machine... ")
        Exploit.set_net_session(Exploit.module.get_local_lib("metaxploit.so").net_use(config.rhost, port.port_number))
        if not tp(Exploit.get_net_session()) == "NetSession" then 
            printb("[blbx][attack][warning]: net-session failed to start...".c("black black purple"))
            continue
        end if 
        config.lan = port.get_lan_ip 
        
        handle_bool_flags = function()
            return fif((config.change_password), 1, fif((config.fire_wall), 1, 0))
        end function


        Session.machine.ip.add_pub_address(config.rhost)

        attack_result = Exploit.attack(config.lan, config.scan, handle_bool_flags())
        
        if not attack_result.status then 
            print            
            printb(attack_result.data.c("black black purple"))
            print
            continue
        end if 

        if not attack_result then 
            printb("attack failed...".c("black black purple"))
            continue 
        end if 

        success = true
    end for 

    if success then Prompt.prepare_input("show")

    return _callback.catch("", 1)
end function 
command["atk"] = @command.attack

command.connect = function(PARAMS)
    config = {"lan_address": 0, "as_user": 0}
    init = function()
        if not PARAMS.len then 
            Usage.display("connect", Usage.get_usage_object("connect"))
            return _callback.catch("", 0)
        end if 

        lan_address = Params.extract_type(PARAMS, [TokenTypes.Float])[0]
        username = Params.extract_type(PARAMS, [TokenTypes.String, TokenTypes.Argument])[0]
        if not lan_address then return _callback.catch("[blbx][connect][err]: must include a lan address argument...")
        if not is_lan_ip(lan_address.value) then return _callback.catch("[blbx][connect][err]: invalid lan address '" + lan_address + "'...")
        if not Exploit.device.has(lan_address.value) then return _callback.catch("[blbx][connect][err]: device map does not contain lan address '" + lan_address.value + "'...")
        config.lan_address = lan_address.value

        username_arr = Exploit.device.user_map[config.lan_address]

        if username then 
            if not tp(username_arr.indexOf(username.value.lower)) == "number" then return _callback.catch("[blbx][connect][err]: username not found in device '" + config.lan_address + "'...")
            config.username = username.value.lower
        else 
            if tp(username_arr.indexOf("root")) == "number" then config.username = "root"
            if username_arr.len and (tp(username_arr.indexOf("root")) != "number" and tp(username_arr.indexOf("guest")) != "number") then config.username = username_arr[0]
            if tp(username_arr.indexOf("guest")) == "number" then congfig.username = "guest"
        end if
        
        if not config.username then return _callback.catch("[blbx][connect][err]: username not found in device '" + config.lan_address + "'...")

        return _callback.catch("", 1)
    end function
    error_handling = init()
    if not error_handling.status then return error_handling

    Exploit.device.set_current(config.lan_address)
    Session.machine.ip.set_lan(config.lan_address)
    Session.process.set_connected(true)

end function 

command.rat = function(PARAMS)

    init = function()
        if not Session.process.is_connected() then return _callback.catch("[blbx][rat][err]: must [connect] to a target to use [rat] exploit...")

        Usage.display("rat", Usage.get_usage_object("rat"))
        if not PARAMS.len > 1 then return _callback.catch("[blbx][rat][usage]: ")
    
        return _callback.catch("", 1)
    end function 
    error_handling = init()
    if not error_handling.status then return error_handling

    return _callback.catch("", 1)
end function  

// linux