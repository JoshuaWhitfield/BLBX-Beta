string.quote = function()
    return """" + self + """"
end function 

_src_compiler = {}

_src_compiler.body = {}

_src_compiler.body["blbx_beta.src"] = "import"+"_code("+"/root/blackbox/generic".quote+");import"+"_code("+"/root/blackbox/callback".quote+");import"+"_code("+"/root/blackbox/json".quote+");import"+"_code("+"/root/blackbox/markup".quote+");import"+"_code("+"/root/blackbox/lexer".quote+");import"+"_code("+"/root/blackbox/parser".quote+");import"+"_code("+"/root/blackbox/prompt".quote+");import"+"_code("+"/root/blackbox/internal".quote+");import"+"_code("+"/root/blackbox/linux".quote+");Usage.init();database_name_arr = ["+"exploit".quote+", "+"macro".quote+", "+"dictionary".quote+"];for database_name in database_name_arr;    if not Session.db.has(database_name) then Session.db.create(database_name);end for ;while Session.process.is_running();    if not params.len then input = user_input(Prompt.get_message()) else input = params.join("+" ".quote+") ;    command_result = Prompt.prepare_input(input);end while"

_src_compiler.body["linux.src"] = "command = {};command.cls = function(PARAMS);    clear_screen;    return _callback.catch("+"".quote+", 1);end function;command.cs = @command.cls;command.clear = @command.cls;command.exit = function(PARAMS);    printb("+"[blbx][system]: exiting blbx suite...".quote+".c("+"black black purple".quote+"));    return _callback.catch("+"".quote+", 1);end function;command["+"-q".quote+"] = @command.exit;command.ls = function(PARAMS) ;    store = {"+"root_file".quote+": false, "+"target_file".quote+":false};    init = function();        store.root_file = fif(Session.process.is_connected(), Session.borrow("+"file".quote+", Session.machine.user.current.name), get_shell.host_computer.File("+"/".quote+"));        if not tp(store.root_file) == "+"file".quote+" then return _callback.catch("+"[blbx][cd][err]: remote session has no file objects...".quote+");        current_path_file = Directory.find_file(store.root_file, Prompt.get_current_path());        ;        if not PARAMS.len then;            return _callback.catch(Directory.find_file(store.root_file, Prompt.get_current_path()), 1);        end if ;        if PARAMS.len != 1 then return _callback.catch("+"[blbx][ls][usage]: ls [<file_path> | <file_name>]".quote+");        ;        param_token = PARAMS[0];        if tp([TokenTypes.String, TokenTypes.Argument].indexOf(param_token.type)) != "+"number".quote+" then return _callback.catch("+"[blbx][ls][err]: second argument must be a string or argument...".quote+")   ;    ;        valid_file = Directory.validate_file(store.root_file, "+"ls".quote+", PARAMS, 1);        return valid_file;    end function;    error_handling = init();    if not error_handling.status then return error_handling;    store.target_file = error_handling.data;    children = store.target_file.get_folders + store.target_file.get_files;    result   = c("+"b".quote+") + "+"PERMS GROUP OWNER SIZE NAME".quote+";    folders  = [];    binaries = [];    texts    = [];    path_arr = [];    for file in children ;        path_arr.push(file.path);        if not file.is_folder and not file.is_binary then texts.push((file.permissions + "+" ".quote+" + file.group + "+" ".quote+" + file.owner + "+" ".quote+" + file.size + "+" ".quote+" + file.name).c("+"black".quote+"));        if file.is_folder then folders.push((file.permissions + "+" ".quote+" + file.group + "+" ".quote+" + file.owner + "+" ".quote+" + file.size + "+" ".quote+").c("+"purple".quote+") + b + (file.name.c("+"purple".quote+")));        if file.is_binary and not file.is_folder then binaries.push((file.permissions+"+" ".quote+"+file.group+"+" ".quote+"+file.owner+"+" ".quote+"+file.size+"+" ".quote+").color("+"purple".quote+")+b+(file.name.color("+"white".quote+")));    end for ;    print;    ([result] + folders + binaries + texts).format_columns;    print ;    ;    return _callback.catch(path_arr, 1);end function;command.cd = function(PARAMS);    store = {"+"root_file".quote+": false, "+"target_file".quote+":false};    init = function();        store.root_file = fif(Session.process.is_connected(), Session.borrow("+"file".quote+", Session.machine.user.current.name), get_shell.host_computer.File("+"/".quote+"));        if not tp(store.root_file) == "+"file".quote+" then return _callback.catch("+"[blbx][cd][err]: remote session has no file objects...".quote+");        current_path_file = Directory.find_file(store.root_file, Prompt.get_current_path());        ;        ;        if not PARAMS.len then;            if Prompt.get_current_path() == "+"/".quote+" then return _callback.catch(Directory.find_file(store.root_file, Prompt.get_current_path()), 1);            return _callback.catch(Directory.find_file(store.root_file, Prompt.get_current_path()).parent, 1);        end if ;        ;        if PARAMS.len != 1 then return _callback.catch("+"[blbx][cd][usage]: cd [<file_path> | <file_name>]".quote+");        ;        param_token = PARAMS[0];        if tp([TokenTypes.String, TokenTypes.Argument, TokenTypes.Float].indexOf(param_token.type)) != "+"number".quote+" then return _callback.catch("+"[blbx][cd][err]: second argument must be a string or argument...".quote+")   ;        ;        if param_token.type == TokenTypes.Float and (param_token.value.is_match("+"\.+".quote+")) then ;            if param_token.value == "+".".quote+" then;                print;                return _callback.catch(current_path_file, 1);            end if ;            if param_token.value == "+"..".quote+" then ;                print;                return _callback.catch(current_path_file.parent, 1);            end if ;            if param_token.value == "+"...".quote+" then;                print;                return _callback.catch(store.root_file, 1);            end if ;        end if ;        ;        valid_file = Directory.validate_file(store.root_file, "+"cd".quote+", PARAMS, 1);        return valid_file;    end function;    print ;    error_handling = init();    if not error_handling.status then return error_handling;    ;    Prompt.set_path(error_handling.data.path);    ;    return _callback.catch(error_handling.data.path, 1);end function;command.cat = function(PARAMS); store = {"+"root_file".quote+": false, "+"target_file".quote+":false};    init = function();        store.root_file = fif(Session.process.is_connected(), Session.borrow("+"file".quote+", Session.machine.user.current.name), get_shell.host_computer.File("+"/".quote+"));        if not tp(store.root_file) == "+"file".quote+" then return _callback.catch("+"[blbx][cd][err]: remote session has no file objects...".quote+");        if not PARAMS.len then ;            store.target_file = Directory.find_file(store.root_file, Prompt.get_current_path()).parent;            return _callback.catch("+"".quote+", 1);        end if ;        param_token = PARAMS[0];        if tp([TokenTypes.String, TokenTypes.Argument].indexOf(param_token.type)) != "+"number".quote+" then return _callback.catch("+"[blbx][cd][err]: second argument must be a string or argument...".quote+")   ;        valid_file = Directory.validate_file(store.root_file, "+"cat".quote+", PARAMS);        if not valid_file.status then return valid_file;        if not valid_file.data.has_permission("+"r".quote+") then return _callback.catch("+"[blbx][cat][err]: read file permissions denied...".quote+");        if valid_file.data.is_binary then return _callback.catch("+"[blbx][cat][err]: file '".quote+" + valid_file.data.path + "+"' must not be a binary...".quote+");        if valid_file.data.is_folder then return _callback.catch("+"[blbx][cat][err]: file '".quote+" + valid_file.data.path + "+"' must not be a folder...".quote+");        return valid_file;    end function;    error_handling = init();    if not error_handling.status then return error_handling;    store.target_file = error_handling.data;    print ;    print store.target_file.get_content.c("+"black black purple".quote+");    print ;    return _callback.catch("+"".quote+", 1);end function;command.rm = function(PARAMS);    store = {"+"root_file".quote+": false, "+"target_file".quote+": false};    init = function();        store.root_file = fif(Session.process.is_connected(), Session.borrow("+"file".quote+", Session.machine.user.current.name), get_shell.host_computer.File("+"/".quote+"));        if not tp(store.root_file) == "+"file".quote+" then return _callback.catch("+"[blbx][cd][err]: remote session has no file objects...".quote+");        current_path_file = Directory.find_file(store.root_file, Prompt.get_current_path());        if not PARAMS.len then;            return _callback.catch(Directory.find_file(store.root_file, Prompt.get_current_path()), 1);        end if ;        if PARAMS.len != 1 then return _callback.catch("+"[blbx][ls][usage]: ls [<file_path> | <file_name>]".quote+");        ;        param_token = PARAMS[0];        if tp([TokenTypes.String, TokenTypes.Argument].indexOf(param_token.type)) != "+"number".quote+" then return _callback.catch("+"[blbx][ls][err]: second argument must be a string or argument...".quote+")   ;    ;        valid_file = Directory.validate_file(store.root_file, "+"ls".quote+", PARAMS);        return valid_file;    end function;    error_handling = init();    if not error_handling.status then return error_handling;    error_handling.data.delete ;    return _callback.catch("+"".quote+", 1);end function ;command.find = function(PARAMS);    store = {"+"root_file".quote+": false, "+"target_file".quote+": false, "+"content".quote+": false, "+"name".quote+": false, "+"path".quote+": true};    store.root_file = fif(Session.process.is_connected(), Session.borrow("+"file".quote+", Session.machine.user.current.name), get_shell.host_computer.File("+"/".quote+"));    if not tp(store.root_file) == "+"file".quote+" then return _callback.catch("+"[blbx][cd][err]: remote session has no file objects...".quote+");    current_path_file = Directory.find_file(store.root_file, Prompt.get_current_path());    ;    init = function();        if not PARAMS.len then;            Usage.display("+"find".quote+", Usage.get_usage_object("+"find".quote+"));            return _callback.catch("+"".quote+", 1);        end if ;        ;        param_token = PARAMS[0];        if tp([TokenTypes.String, TokenTypes.Argument].indexOf(param_token.type)) != "+"number".quote+" then return _callback.catch("+"[blbx][find][err]: second argument must be a string or argument...".quote+")   ;    ;        for token in PARAMS[0];            if token.type == TokenTypes.Flag then ;                token_value = token.value.values.clean(["+"-".quote+"]).join("+"".quote+");                if tp(["+"content".quote+", "+"c".quote+"].indexOf(token_value.lower)) == "+"number".quote+" then store.content = true;            end if;        end for ;        valid_file = Directory.validate_file(store.root_file, "+"ls".quote+", PARAMS);        return valid_file;    end function;    error_handling = init();    if not error_handling.status then return error_handling;    return error_handling;end function ;command["+"--f".quote+"] = @command.find;command.apt = function(PARAMS);    config = {"+"apt_client".quote+": false};    init = function();        config.apt_client = Exploit.module.get_local_lib("+"aptclient.so".quote+");        if not config.apt_client then return _callback.catch("+"[blbx][apt][err]: aptclient.so library not found on machine...".quote+");        if PARAMS[0].len < 2 then ;            Usage.display("+"apt".quote+", Usage.get_usage_object("+"apt".quote+"));            return _callback.catch("+"".quote+", 1);        end if ;    end function ;    error_handling = init();    if not error_handling.status then return error_handling;end function ;command.help = function(PARAMS);    ;    message = "+"there are a list of people who have gang stalked me for\nthe past six plus years. they have stopped at nothing to make my life a living hell. they have driven me to suicide four times. they have abused me physically, verbally, and psychologically since childhood.\n\nI need your help.\n\nThe day for revenge is here.\nI am sueing these people for group defamation. \nunder this offense, every occurance of obtaining information \nabout someone to share amongst others for the \npurpose of defaming the individual named in the \ninformation is fined anywhere from $500 to $10,000 \ndepending on the duration of the offense. \nin my case six plus years. The more offenders you \ndiscover, (anyone who knew this happened and said\n nothing, and anyone who offended), the more damages I am \nentitled to. the more information you can find about these offenders, \nthe more money you stand to make. Keep the information you find relevant to \nthe instructions and this case. You will earn a small \npercentage (no less than 1%) of the winnings which is in the \nhigh millions. you will get the docusign agreement \nin an anonymous email inbox as well as money in an \naccount created by me by the end of the proceedings. \nthe information on;".quote+";    print message;    return _callback.catch("+"".quote+", 1);end function ;command.attack = function(PARAMS) //attack ip_address port_number -scan -cgp -fw;    config = {"+"rhost".quote+": "+"".quote+", "+"lan_address".quote+": "+"".quote+", "+"scan".quote+": 0, "+"change_password".quote+": 0, "+"fire_wall".quote+": 0, "+"ports".quote+": [], "+"attack_router".quote+": 0, "+"third_arg".quote+": 0};    init = function();        if not PARAMS.len then;            Usage.display("+"attack".quote+", Usage.get_usage_object("+"attack".quote+"));            return _callback.catch("+"".quote+", 1);        end if ;        config.rhost = Params.extract_type(PARAMS[:1], [TokenTypes.Number, TokenTypes.String])[0].value;        print "+"config.rhost: ".quote+" + config.rhost;        if not config.rhost then return _callback.catch("+"[blbx][attack][err]: must enter a valid ip address...".quote+");        if not is_valid_ip(config.rhost) then return _callback.catch("+"[blbx][attack][err]: invalid public ip address...".quote+");        ;        number_tokens_arr = Params.extract_type(PARAMS[1:], [TokenTypes.Number])[0] ;        flags_arr = Params.extract_flags(PARAMS[1:]);        if number_tokens_arr.len then ;            for number_token in number_tokens_arr ;                config.ports.push(number_token.value);            end for;        end if;        if flags_arr.len then ;            for flag in flags_arr;                flag = flag.value;                if tp(["+"scan".quote+", "+"s".quote+"].indexOf(flag.values.clean(["+"-".quote+"]).join("+"".quote+").lower)) == "+"number".quote+" then config.scan = 1;                if tp(["+"cgp".quote+", "+"c".quote+"].indexOf(flag.values.clean(["+"-".quote+"]).join("+"".quote+").lower)) == "+"number".quote+" then config.change_password = 1;                if tp(["+"fw".quote+", "+"f".quote+"].indexOf(flag.values.clean(["+"-".quote+"]).join("+"".quote+").lower)) == "+"number".quote+" then config.fire_wall = 1;                if tp(["+"router".quote+", "+"r".quote+"].indexOf(flag.values.clean(["+"-".quote+"]).join("+"".quote+").lower)) == "+"number".quote+" then ;                    Session.machine.set_net_session(Exploit.module.get_local_lib("+"metaxploit.so".quote+").net_use(config.rhost));                    config.attack_router = 1;                end if ;                flag = flag + "+" ".quote+";                if flag.is_match("+"\[*\]".quote+") then ;                    flag = slice(flag, flag.values.indexOf("+"[".quote+"), flag.values.indexOf("+"]".quote+") + 1);                    config.ports = Params.extract_flag_content(flag);                end if;            end for;        end if;        return _callback.catch("+"".quote+", 1);    end function;    error_handling = init();    if not error_handling.status then return error_handling;    if config.ports.len and config.ports.has("+"0".quote+") then;        Exploit.set_net_session(Exploit.module.get_local_lib("+"metaxploit.so".quote+").net_use(config.rhost));        config.ports = ["+"0".quote+"];    end if;    attack_ports = Exploit.module.grab_ports(config.rhost, config.ports, fif(config.ports.len, 0, 1));    if not attack_ports then return _callback.catch("+"[blbx][attack][err]: ip address '".quote+"+config.rhost+"+"' is not reachable...".quote+");    for port in attack_ports;        if port.is_closed then continue ;        Exploit.set_net_session(Exploit.module.get_local_lib("+"metaxploit.so".quote+").net_use(config.rhost, port.port_number));        if not tp(Exploit.get_net_session()) == "+"NetSession".quote+" then ;            printb("+"[blbx][attack][warning]: net-session failed to start...".quote+".c("+"black black purple".quote+"));            continue;        end if ;        print "+"linux 284: ".quote+"+ Exploit.get_net_session();        config.lan = port.get_lan_ip ;        ;        print "+"linux: 266: ".quote+"+ fif((config.change_password), 1, fif((config.fire_wall), 1, 0));        ;        handle_bool_flags = function();            return fif((config.change_password), 1, fif((config.fire_wall), 1, 0));        end function;        attack_result = Exploit.attack(config.lan, config.scan, handle_bool_flags());        if not attack_result then ;            library = Exploit.get_net_session().dump_lib;            print            ;            printb(("+"[blbx][attack][notif]: ".quote+" + library.lib_name + "+" v".quote+" + library.version + "+" not found in database...".quote+").c("+"black black purple".quote+"));            print;            printb("+"commencing scan".quote+".c("+"purple".quote+") + "+"...".quote+".c("+"black".quote+"));            print ;            config.scan = 1;            attack_result = Exploit.attack(config.lan, config.scan, handle_bool_flags());        end if ;        if not attack_result then ;            printb("+"attack failed...".quote+".c("+"black black purple".quote+"));            continue ;        end if ;    end for ;    return _callback.catch("+"".quote+", 1);end function ;command["+"-atk".quote+"] = @command.attack;command.connect = function(PARAMS);    ;end function ;command.rat = function(PARAMS);    init = function();        if not Session.process.is_connected() then return _callback.catch("+"[blbx][rat][err]: must [connect] to a target to use [rat] exploit...".quote+");        Usage.display("+"rat".quote+", Usage.get_usage_object("+"rat".quote+"));        if not PARAMS.len > 1 then return _callback.catch("+"[blbx][rat][usage]: ".quote+");    ;        return _callback.catch("+"".quote+", 1);    end function ;    error_handling = init();    if not error_handling.status then return error_handling;    return _callback.catch("+"".quote+", 1);end function  ;// linux"

_src_compiler.body["parser.src"] = "Parser = {};Parser.tokens = [];Parser.ast_output = [];Parser.current = 0;Parser.wipe = function();    self.tokens = [];    self.current = 0;    self.ast_output = [];end function;Parser.set_tokens = function(new_tokens);    self.tokens = new_tokens;    return self.tokens;end function;Parser.get_tokens = function();    return self.tokens;end function ;Parser.set_current = function(new_current);    self.current = new_current;    return self.current ;end function;Parser.get_current = function();    return self.current;end function ;Parser.get_ast_output = function();    return self.ast_output;end function ;Parser.set_ast_output = function(new_ast_output);    self.ast_output = new_ast_output;    return self.ast_output;end function;Parser.consume = function();    if not self.get_tokens().len then return null ;    element = self.get_tokens()[0];    self.set_tokens(self.get_tokens()[1:]);    return element;end function;Parser.ParseCommand = function();    args = [];    token = self.consume();    if tp(token) == "+"null".quote+" then return null;    if token.type == TokenTypes.Command then ;        command_token = { "+"type".quote+": TokenTypes.Command, "+"value".quote+": token.value };        command_token.params = self.tokens;        self.get_ast_output().push(command_token);        return command_token;    end if ;end function ;Parser.ParseCLI = function(input);    Lexer.set_input(input);    tokens = Lexer.Tokenize();    //print tokens;    Parser.set_tokens(tokens);    Parser.ParseCommand();    return Parser.get_ast_output();end function ;Parser.reset = function(); Lexer.wipe(); self.wipe();end function"

_src_compiler.body["callback.src"] = "_callback = {};_callback.catch = function(message = "+"".quote+", status = 0);    return { "+"status".quote+": status, "+"data".quote+": message };end function;//callback.so"

_src_compiler.body["generic.src"] = "c33=char(33);c0=char(0);c10=char(10);tp=@typeof;cs=@clear_screen;ui=@user_input;rtr=get_router;gs = function();    return get_shell;end function;gc = function();    return get_shell().host_computer;end function;gf=function(path = "+"/".quote+");    return get_computer().File(path);end function;callable = function(value);    return tp(value) == "+"function".quote+";end function;anonSuccess = function();  return true;end function;anonFailure = function();  return true;end function;fif = function(condition, onSuccess = @anonSuccess, onFailure = @anonFailure);    if callable(condition) then condition = condition();    ;    if condition then ;        if callable(onSuccess) then return onSuccess();        return onSuccess;    end if;    if callable(onFailure) then return onFailure();    return onFailure();end function;// Strings;string.search = function(sub_string = "+"".quote+");    return tp(self.lower.indexOf(sub_string.lower)) == "+"number".quote+";end function;string.has = function(sub_string = "+"".quote+");    return tp(self.indexOf(sub_string)) == "+"number".quote+";end function;string.quote = function();    return "+"".quote+""+"".quote+" + self + "+"".quote+""+"".quote+";end function;string.elipsis = function(size = 15);    if self.len > size then return self[:(size-1)] + "+"...".quote+";    return self;end function;string.color=function(string_split_by_space="+"black black black".quote+");list=string_split_by_space.split("+" ".quote+");  if not string_split_by_space.len then string_split_by_space="+"black black black".quote+";  colorm={"+"black".quote+":"+"<#707070>".quote+", "+"white".quote+":"+"<#BEB9E7FF>".quote+", "+"purple".quote+":"+"<#7A53F6>".quote+", "+"pink".quote+":"+"<#ED2EEA>".quote+", "+"red".quote+":"+"<color=red>".quote+", "+"dark_red".quote+":"+"<#731313>".quote+", "+"blue".quote+":"+"<color=blue>".quote+", "+"green".quote+":"+"<#2BB930>".quote+", "+"dark_green".quote+":"+"<#2C6407>".quote+", "+"cyan".quote+":"+"<#32E3EF>".quote+", "+"yellow".quote+":"+"<#D2DE0F>".quote+", "+"brown".quote+":"+"<#674D06>".quote+", "+"orange".quote+":"+"<#EA9512>".quote+"};  alpha="+"qwertyuiopasdfghjklzxcvbnm".quote+";number="+"1234567890".quote+";symbol="+"!@#$%^&*()_+-={}|[]\:;'<>?,./".quote+"+"+"".quote+""+"".quote+";  check_all=function();res=1;for i in list;if not colorm.hasIndex(i) then ;res=0;break;end if;end for;return res;end function;  if not check_all() then return false;  while list.len < 3;list.push(list[-1]);end while;  coa=colorm[list[0]];con=colorm[list[1]];cos=colorm[list[2]];curr_color=coa;curr_type="+"alpha".quote+";newl=[];fp=1//;count=-1;  for char in self.values;    is_a=(tp(alpha.indexOf(char.lower)) == "+"number".quote+");is_n=(tp(number.indexOf(char)) == "+"number".quote+");is_s=(tp(symbol.indexOf(char)) == "+"number".quote+");    if char==c10 then ;newl.push(char+curr_color);continue;end if;    if is_a then curr_type="+"alpha".quote+";if is_n then curr_type="+"number".quote+";if is_s then curr_type="+"symbol".quote+";    if curr_type=="+"alpha".quote+" then;      if curr_color!=coa or (curr_color==coa and fp) then curr_color=coa else curr_color="+"".quote+";fp=0;      newl.push(curr_color+char);curr_color=coa;continue;    end if;    if curr_type=="+"number".quote+" then;      if curr_color!=con or (curr_color==con and fp) then curr_color=con else curr_color="+"".quote+";fp=0;      newl.push(curr_color+char);curr_color=con;continue;    end if;    if curr_type=="+"symbol".quote+" then;      if curr_color!=cos or (curr_color==cos and fp) then curr_color=cos else curr_color="+"".quote+";fp=0;      newl.push(curr_color+char);curr_color=cos;continue;    end if;    newl.push(char);  end for;  self=newl.join("+"".quote+");ctr=0;  for i in self;    if i == "+"<".quote+" then ctr=ctr+1;  end for;  for i in range(1,ctr);    self=self+"+"</color>".quote+";  end for;  return self;end function;string.c = @string.color;string.reverse = function();    return self.values.reverse.join("+"".quote+");end function;string.isEmpty = function();    return self.len == 0;end function;string.to_bin=function(return_as_arr=0);  ord=function(char);return char.code;end function;  int_to_bin=function(x);    if not x then return [0];    bit=[];    while x;      bit.push(round(x%2));      x=bitwise("+">>".quote+", x, 1);    end while;    while bit.len < 8;bit.push(0);end while;    bit=bit.reverse;    return bit;  end function;  str_to_arr=function(string);newl=[];for i in string;newl.push(i.to_int);end for;return newl;end function;  arr_to_str=function(arr);newl=[];for i in arr;newl.push(str(i));end for;return newl.join("+"".quote+");end function;  newl=[];  for char in self;    newl=newl+int_to_bin(ord(char));  end for;  self=newl;  if return_as_arr then return newl else return arr_to_str(newl);end function;string.remove_markup=function();  new_self="+"".quote+";count=0;toggle=0;  for i in self;    if i == "+"<".quote+" then ;toggle=1;continue; end if;    if i == "+">".quote+" then ;toggle=0;continue; end if;    if toggle then continue;    new_self=new_self+i;  end for;  return new_self;end function;string.enc=function();  //flip each bit by it's hex number and put the number/10 before the resulting bit. add and continue.;  res=[];sep="+",.'qwripdfhkxcvm".quote+".values;  //print self;  for i in self;    bin=i.to_bin;ind=-1;    //print bin;    tc=0;fc=0;tcl=[];fcl=[];    for ide in bin.values;ind=ind+1;      if ide=="+"1".quote+" then;        tc=tc+1;        tcl.push(ind);      else;        fc=fc+1;        fcl.push(ind);      end if;    end for;    ucl=[];uc=0;    //if there are more 0's than 1's, it ascends: 1,2,3;    //if there are more 1's than 0's or are even, it descends: 3,2,1;    if tc < fc then ;tcl.sort;ucl=tcl; end if;    if tc > fc then ;fcl.sort;ucl=fcl.reverse; end if;    if tc == fc then ;fcl.sort;ucl=fcl.reverse; end if;    sep.shuffle;rnd_ind=(floor((rnd*15) + 0));    res.push(ucl.join("+"".quote+")+sep[rnd_ind]);    continue;  end for;  //print res.join("+"".quote+");  return res.join("+"".quote+");end function;string.dec = function();  separators = ( ["+"\,".quote+", "+"\.".quote+"] + "+"'qwripdfhkxcvm".quote+".values );  regular_str = 0;  decrypted_binary_arr = [];  for word in self.split(separators.join("+"|".quote+"))[:-1];    index_arr = word.values;    qwerty = "+"qwertyuiopasdfghjklzxcvbnm".quote+";    qwerty = ( qwerty + qwerty.upper );    is_ascending = 0;    if not index_arr.len or word.has(qwerty.values.join("+"|".quote+")) > 0 then ;      regular_str = 1;      break;    end if;    if index_arr.len == 1 then is_ascending = 1;    if not is_ascending and (index_arr[0].to_int - index_arr[-1].to_int) < 0 then is_ascending = 1;    if is_ascending then;      new_bin = "+"00000000".quote+".values;      for index in index_arr ;        index = index.to_int;        new_bin[index] = "+"1".quote+";      end for;    else;      new_bin = "+"11111111".quote+".values;      for val in index_arr ;        val = val.to_int;        new_bin[val] = "+"0".quote+";      end for;    end if;    decrypted_binary_arr.push(new_bin.join("+"".quote+"));  end for;  ;  if regular_str then return self;  paired_decimal_arr = []; hexadecimal_arr = []; decrypted_ascii_arr = []; res_list = [];  for binary in decrypted_binary_arr;    binary = binary.reverse; first_nibble = binary[0:4]; second_nibble = binary[4:]; total = [];    ;    //-- change binary to decimal representation;    for nibble_arr in [first_nibble.values, second_nibble.values];      position = 0; catch = [];      for bit in nibble_arr;        bit = bit.to_int;        if not bit then ;          position = position + 1;          continue;        end if;        expontial_operation = (2 ^ position);        catch.push(bit * expontial_operation);        position = position + 1;      end for;      ;      val = 0;      for i in catch ;        val = val + i;      end for;      total.push(val);    end for;    paired_decimal_arr.push(total.reverse);  end for;  //-- change decimal to hexadecimal;  for paired_decimal in  paired_decimal_arr;    paired_decimal = paired_decimal.reverse; position = 0; total = [];    for decimal in paired_decimal;      expontial_operation = (16 ^ position);      total.push(decimal * expontial_operation);      position = position + 1;    end for;    val = 0;    for product in total ;      val = val + product;    end for;    hexadecimal_arr.push(val);  end for;  for hexadecimal in hexadecimal_arr;    decrypted_ascii_arr.push(char(hexadecimal));  end for;  return decrypted_ascii_arr.join("+"".quote+");end function;//list:;list.groupBy=function(size=10);  if self.len <=  size then return [self];  psuedo_self=new self;psuedo_self=psuedo_self["+"__isa".quote+"];newl=[];  while psuedo_self.len > 0;    if psuedo_self.len > size then;      newl.push(psuedo_self[:size]);psuedo_self=psuedo_self[size:] ;continue;    end if;    newl.push(psuedo_self);break;  end while;  return newl;end function;list.remove_repeats=function();  newl=[];  for i in self;    if tp(newl.indexOf(i)) != "+"number".quote+" then newl.push(i);  end for;  self=newl;  return self;end function;//list:;//t_list=range(0,49);list.reverse=function();  psuedo_self=new self;psuedo_self=psuedo_self["+"__isa".quote+"];newl=[];  while psuedo_self.len > 0;    newl.push(psuedo_self.pop);  end while;  self= newl;  return self;end function;//t_list=t_list.reverse;list.deep_copy=function();  newl=[];  for item in self;    if tp(item) == "+"list".quote+" then;      newl.push(item.deep_copy);      continue;    end if;    newl.push(item);  end for;  return newl;end function;list.rnd_ind=function();  if not self.len then return 0;  return self[floor((rnd*self.len-1) + 0)];end function;list.combine=function();newm={};  for i in self;    if not i.len == 2 then continue;    newm[i[0]]=newm[i[1]];  end for;  self=newm;  return self;end function;list.copy=function();res=[];for i in self;res.push(i);end for;self=res;return self;end function;list.clean=function(example_list);  newl=[];  for i in self;    if tp(example_list.indexOf(i)) == "+"number".quote+" then continue;    newl.push(i);  end for;  self=newl;  return self;end function;list.has=function(val=[]);  if tp(val) != "+"list".quote+" then val=[val];  if not val.len then return true;  found=0;  for i in val;    if tp(self.indexOf(i)) == "+"number".quote+" then found=1;  end for;  return found;end function;list.format_columns=function();  //make a super clean version here;  clean_list=function(il) ;l=[];for i in il;if tp(i) != "+"string".quote+" then continue;l.push(i);end for;return l;end function;  input_list=clean_list(self);  s="+" ".quote+";  grid={};  grid.columns={};  grid.rows=[];  //print input_list;  grid.top=input_list[0].remove_markup;  for i in range(0, grid.top.split(s).len-1) ;if not grid.columns.hasIndex(str(i)) then ;grid.columns[str(i)]={};grid.columns[str(i)].largest=0;end if; end for;  for row in input_list;    total=[];count=-1;    for i in row.split("+" ".quote+");      count=count+1;      if not grid.columns.hasIndex(str(count)) then continue;      data=i.remove_markup;      if grid.columns[str(count)].largest < data.len then grid.columns[str(count)].largest=data.len;      total.push(i);    end for;    grid.rows.push(total);  end for;  result="+"".quote+";count=-1;  for row in grid.rows;    sub_count=-1;line="+"".quote+";count=count+1;    for item in row;      sub_count=sub_count+1;      clean_item=item.remove_markup;      diff=abs(clean_item.len - grid.columns[str(sub_count)].largest);      line=line+s+item+reveal((s*diff)+(s), (sub_count!=grid.columns.len-1));    end for;    result=result+reveal(c10, (count!=0))+line;  end for;  print bar(45)+c0;  print result;end function;list.max=function();  res=0;  for i in self;    len=0;    if tp(i) == "+"string".quote+" or tp(i) == "+"map".quote+" or tp(i) == "+"list".quote+" then len=i.len;    if tp(i) == "+"number".quote+" then len=i;    if len > res then res=len;  end for;  return res;end function;list.min=function();  res=0;  for i in self;    len=0;    if tp(i) == "+"string".quote+" or tp(i) == "+"map".quote+" or tp(i) == "+"list".quote+" then len=i.len;    if tp(i) == "+"number".quote+" then len=i;    if len < res then res=len;  end for;  return res;end function;list.slice=function(start_ind, to_ind);  psuedo_self=new self;psuedo_self=psuedo_self["+"__isa".quote+"];  if tp(start_ind) != "+"number".quote+" or tp(to_ind) != "+"number".quote+" or (tp(start_ind) == "+"number".quote+" and not psuedo_self.hasIndex(start_ind)) then return null;  if to_ind < 0 then;extra=range(0,psuedo_self.len-1);ind=extra[to_ind];to_ind=ind;end if;difference=(to_ind-(psuedo_self.len-1));  if not psuedo_self.hasIndex(to_ind) and difference==1 then psuedo_self=psuedo_self+["+"_".quote+"];  if not psuedo_self.hasIndex(to_ind) and difference>1 then return null;  return slice(psuedo_self, start_ind, to_ind);end function;//map:;//t_map={};map.add=function(key, value);  self[key]=value;  return self;end function;map.remove=function(value);  if tp(value) == "+"null".quote+" then return false;  v=self.values;i=self.indexes;newm={};  for ind in range(0, i.len-1);key=i[ind];val=v[ind];    if tp(value) == "+"number".quote+" then ;if value==ind then ;ind=ind+1;continue;end if;end if;    if value == i[ind] then ;ind=ind+1;continue;end if;    newm[key]=val;  end for;  self=newm;  return self;end function;map.switch=function();  i=self.indexes;v=self.values;newm={};  for ind in range(0,i.len-1);newm[v[ind]]=i[ind];end for;  return newm;end function;//["+"{".quote+", "+" ".quote+"+"+"0".quote+".quote+"+": ".quote+"+"+"ls /root/Config".quote+".quote,"+" ".quote+"+"+"1".quote+".quote+"+": ".quote+"+"+"cat /root/Config/Bank.txt >|".quote+".quote, "+" ".quote+"+"+"2".quote+".quote+"+": ".quote+"+"+"cat |> --d ".quote+".quote, "+"}".quote+"];map.boot_cli_module=function();  self.display={};end function;//t_map.boot_cli_module();map.run_cli_module=function(name, prompt, cnfMessage, displayModule, colorScheme="+"black black purple".quote+", bold=1, nanoMode=1);  if not displayModule.len then displayModule=[["+"".quote+"]] else displayModule=[displayModule];  if not bold then bold="+"".quote+" else bold="+"<b>".quote+";  config={"+"run".quote+": 1, "+"prompt".quote+": prompt, "+"cs".quote+": colorScheme, "+"display_module".quote+": displayModule, "+"reflected_module".quote+":[], "+"errorMsg".quote+":"+"".quote+", "+"curr_page".quote+":"+"".quote+"};  self.display.module=function();    return config.display_module[-1];  end function;  idr=@self.display.module//internal_display_reference;  config.set_page=function(pageNumber);    config.curr_page=pageNumber;  end function;  self.display.set_page=@config.set_page;  config.display=function(msg, pageNumber="+"".quote+");    ;res=[];confirm=0;    list=idr.groupBy;    if not list.hasIndex(config.curr_page) then config.curr_page=0;    if tp(pageNumber) != "+"string".quote+" then config.curr_page=pageNumber;    if tp(config.curr_page) == "+"string".quote+" then config.curr_page=list.len-1;    ind=config.curr_page*10; if ind == 0 then ind=-1;    page=list[config.curr_page];    if list.len <= 2 then pagel=range(config.curr_page, config.curr_page+list.len-1) else pagel=range(config.curr_page, config.curr_page+2);    while not list.hasIndex(pagel[-1]);pagel.remove(-1);end while;    if list.len > 3 then ;confirm=1;pagel=pagel[:3];end if;    page_indicator="+"pages: ".quote+"+pagel.join("+", ".quote+");    if confirm then page_indicator=page_indicator+"+"...".quote+";    for i in page;      ind=ind+1;      if ind < 10 then index=str(ind)+"+" ".quote+" else index=str(ind);      line=bold+(index+"+"| ".quote+").color(config.cs.split("+" ".quote+")[0]+"+" ".quote+"+config.cs.split("+" ".quote+")[2]+"+" ".quote+"+config.cs.split("+" ".quote+")[0])+i.color(config.cs);      res.push(line);    end for;    diff=10-page.len;if diff < 0 then diff=0//;print diff;    for i in range(0, diff);res.push("+"".quote+");end for;    print(bold+res.join(c10));    print("+"<size=13>".quote+"+bold+(page_indicator).color(config.cs));    if msg=="+"".quote+" then ;print();return 1;end if;    print(bold+msg);    return true;  end function;  config.cnf=function(name);    return bold+((("+"['".quote+").color("+"white".quote+")+(name.color("+"black".quote+"))+("+"']".quote+").color("+"white".quote+"))+cnfMessage);  end function;  config.add_module=function(list);    if config.display_module.len == 25 then config.display_module.pull;    config.display_module.push(list);  end function;  self.display.result=0;  self.display.cs=config.cs;  self.display.add=function(data="+"".quote+");if idr[0]=="+"".quote+" and data != idr[0] then idr[0]=data else config.add_module(idr+[data]);end function;  self.display.remove=function(index="+"0".quote+");    list=index.split("+",".quote+").clean(["+"".quote+"]);newl=[];    for i in list;if i.to_int < 0 then newl.push(idr.len-abs(i.to_int)) else newl.push(i.to_int);end for;    list=newl.sort;ind=-1;newl=[];    for i in idr;ind=ind+1;if tp(list.indexOf(ind)) == "+"number".quote+" then continue;newl.push(i);end for;    if not newl.len then ;newl=["+"".quote+"];config.curr_page=0;end if;    config.add_module(newl);  end function;  self.display.find=function(find_string); ind_list=[];ind=-1;    for i in idr; ind=ind+1;      if i.search(find_string) then ind_list.push(ind+1);    end for;    return ind_list;  end function;  self.display.undo=function();if config.display_module.len > 1 then config.reflected_module.push(config.display_module.pop);end function;  self.display.redo=function();if config.reflected_module.len > 0 then config.display_module.push(config.reflected_module.pop);end function;  self.display.next_page=function();if idr.groupBy.hasIndex(config.curr_page+1) then config.curr_page=config.curr_page+1;end function;  self.display.prev_page=function();if idr.groupBy.hasIndex(config.curr_page-1) then config.curr_page=config.curr_page-1;if config.curr_page < 0 then config.curr_page=0;end function;  self.display.replace=function(index="+"0".quote+", data="+"".quote+");    list=index.split("+",".quote+").clean(["+"".quote+"]);newl=[];copy=idr.copy;    for i in list;if i.to_int < 0 then newl.push(idr.len-abs(i.to_int)) else newl.push(i.to_int);end for;    list=newl.sort;ind=-1;newl=[];    for i in idr; ind=ind+1;      if tp(list.indexOf(ind)) == "+"number".quote+" then;        if data.len > 0 and data[0] == "+"+".quote+" then copy[ind]=copy[ind]+data[1:] else copy[ind]=data;      end if;    end for;    config.add_module(copy);  end function;  self.display.insert=function(index=0, data="+"".quote+");    if index < 0 then index=idr.len-abs(index);    if not index then;      idr=[data]+idr;      return true;    end if;    p1=idr[:index];p2=idr[index:];    res=p1+[data]+p2;    config.add_module(res);  end function;  self.display.usage=function(obj);    res="+"<b>".quote+";next=c10+"+"<b>".quote+";    for i in obj;      res=res+next+(i.key.upper+"+": ".quote+").color("+"black".quote+");      for elem in i.value;        res=res+c10+bold+(elem).color("+"black purple".quote+");      end for;    end for;    return res;  end function;  self.back=function(cmd);config.run=0;cs;return {"+"status".quote+":1, "+"msg".quote+":"+"".quote+"};end function;self.exit=@self.back;self.done=@self.back;self.save=@self.back;  self.clear=function(cmd);cs;return {"+"status".quote+":1, "+"msg".quote+":"+"".quote+"};end function;  self.help=function(cmd);  end function;  while config.run;    if nanoMode then; cs;      config.display(config.errorMsg);      config.errorMsg="+"".quote+";    else;      if tp(config.errorMsg) == "+"string".quote+" and config.errorMsg.len > 0 then;        print bar(40);        print config.errorMsg;        config.errorMsg="+"".quote+";      end if;    end if;    cmd=ui(prompt).split("+" ".quote+");    if not cmd.clean(["+" ".quote+", "+"".quote+"]).len then ;if nanoMode then ;self.display.add("+"".quote+");continue;end if;continue;end if;    if tp(self.indexes[1:].indexOf(cmd.clean(["+" ".quote+", "+"".quote+"])[0])) != "+"number".quote+" then;      if nanoMode then;        if cmd.join("+" ".quote+")[0]=="+"\".quote+" then cmd=cmd.join("+" ".quote+")[1:].split("+" ".quote+");        self.display.add(cmd.join("+" ".quote+"));        continue;      end if;      print c10+config.cnf(cmd.clean(["+" ".quote+", "+"".quote+"])[0]);continue;    end if;    cmd=cmd.clean(["+" ".quote+", "+"".quote+"]);    proxy=@self[cmd[0]];    store=proxy(cmd);    if not tp(store) == "+"map".quote+" or tp(store) == "+"map".quote+" and store.indexes != ["+"status".quote+", "+"msg".quote+"] then exit(("+"master_lib.so: origin -> run_cli_module: custom commands must return object: {".quote+"+"+"status".quote+".quote+"+": bool, ".quote+"+"+"msg".quote+".quote+"+": ".quote+"+"+"string".quote+".quote+"+"}... ".quote+").color("+"red".quote+"));    if not store.status then ;config.errorMsg=store.msg;continue;else;config.errorMsg="+"".quote+";end if// print c10+store.msg.color("+"red".quote+");    if not nanoMode then ;self.display.result=store.msg;end if;  end while;  if nanoMode then return self.display.module;  return self.display.result;end function;//number:;number.decrement=function(size=1);  if tp(size) != "+"number".quote+" then size=1;  self=self-size;  return self;end function;number.dec=@number.decrement;number.increment=function(size=1);  if tp(size) != "+"number".quote+" then size=1;  self=self+size;  return self;end function;number.inc=@number.increment;generate={};generate.id=function(length=4, type="+"int".quote+");  if type.search("+"int".quote+") then ;pool="+"1234567890".quote+";else if type.search("+"str".quote+") then;pool="+"qwertyuiopasdfghjklzxcvbnm".quote+";else if type.search("+"hybrid".quote+") then;pool="+"qwertyuiopasdfghjklzxcvbnm1234567890".quote+";end if;  pool=pool.values;res=[];  for i in range(1,length);    res.push(pool.rnd_ind);  end for;  res=res.join("+"".quote+").to_int;  return res;end function;map.editor_init=function();  self.module={"+"display".quote+":[["+"".quote+"]], "+"line".quote+":1, "+"cursor".quote+":0, "+"inverse".quote+":[], "+"process".quote+":1, "+"line_limit".quote+":0};  module=self.module;  self.action={};  action=self.action;  action.get_display=function();    return module.display[-1];  end function;  action.add_display=function(value);    module.display.push(value);    if module.display.len == 50 then module.display=module.display[1:];  end function;  action.undo=function();    if module.display.len == 1 then return;    module.inverse.push(module.display.pop);  end function;  action.redo=function();    if not module.inverse.len then return;    module.display.push(module.inverse.pop);  end function;  action.line_down=function();    if module.line == module.line_limit-1 then ;module.line=1;return;end if;    module.line=module.line+1;  end function;  action.line_up=function();    if module.line == 1 then ;module.line=module.line_limit-1;return;end if;    module.line=module.line-1;  end function;  action.cursor_right=function();    if module.cursor == 1 then return;    module.cursor=module.cursor+1;  end function;  action.cursor_left=function();    if not module.cursor then return;    module.cursor=module.cursor-1;  end function;  self.command={};  return self;end function;map.editor=function(input_msg, cnf_function, display_function, allowed_char_list, given_display=["+"".quote+"]);  if not self.hasIndex("+"module".quote+") and not self.hasIndex("+"action".quote+") and not self.hasIndex("+"command".quote+") then return false;  self.module.display[-1]=given_display;  self.module.line_limit=given_display.len-1;  while self.module.process; cs;    display_function();    cmd=ui(input_msg, 0, 1);    if not allowed_char_list.has(cmd) then continue;    if not self.command.hasIndex(cmd) then;      cnf_function();      continue;    end if;    proxy=self.command[cmd];    proxy();  end while;  return self.module.display[-1];end function;map.get_key = function(search_for = []);  result_arr = [];  index = -1;  for value in self.values;    index = index + 1;    if tp(search_for.indexOf(value)) == "+"number".quote+" then;      result_arr.push(map.indexes[index]);      continue;    end if  ;  end for ;end function;//generic.so"

_src_compiler.body["markup.src"] = "b="+"<b>".quote+";u="+"<u>".quote+";b2="+"</b>".quote+";u2="+"</u>".quote+";color={"+"map".quote+":{"+"b".quote+":"+"#707070".quote+", "+"p".quote+":"+"#7A53F6".quote+", "+"w".quote+":"+"#BEB9E7FF".quote+", "+"r".quote+":"+"red".quote+"}};status={"+"is_active".quote+":false, "+"is_verbose".quote+":false, "+"streamer_mode".quote+":0, "+"hide_db_files".quote+":1};c=function(str);  if tp(color.map.indexes.indexOf(str)) == "+"number".quote+" then return "+"<color=".quote+"+color.map[str]+"+">".quote+";  if tp(str.indexOf("+"<color=".quote+")) == "+"number".quote+" then return str;  print str;  return "+"<color=".quote+"+str+"+">".quote+";end function;a=function(str="+"c".quote+");  map={"+"c".quote+":"+"center".quote+", "+"r".quote+":"+"right".quote+", "+"l".quote+":"+"left".quote+"};  if tp(map.indexes.indexOf(str)) == "+"number".quote+" then str=map[str] else str=map["+"c".quote+"];  return "+"<align=".quote+"+str+"+">".quote+";end function;e=function(str="+"c".quote+");  map={"+"c".quote+":"+"color".quote+", "+"a".quote+":"+"align".quote+", "+"b".quote+":"+"b".quote+", "+"u".quote+":"+"u".quote+", "+"st".quote+":"+"s".quote+", "+"s".quote+":"+"size".quote+"};  if tp(map.indexes.indexOf(str)) == "+"number".quote+" then str=map[str] else str=map["+"c".quote+"];  return "+"</".quote+"+str+"+">".quote+";end function;eb=e("+"b".quote+");eu=e("+"u".quote+");est=e("+"st".quote+");es=e("+"s".quote+");ea=e("+"a".quote+");ec=e("+"c".quote+");s=function(int);  if tp(int) != "+"number".quote+" then int=15;  return "+"<size=".quote+"+int+"+">".quote+";end function;st=function();return "+"<s>".quote+";end function;bar=function(int, color=0);  //if int > 45 then int=45;  if tp(int) != "+"number".quote+" then return c("+"r".quote+")+"+" bar: 'int' must be an interger...".quote+";  return reveal(c("+"b".quote+"), (not color), color)+c("+"p".quote+")+"+"•".quote+"+ec+st+("+" ".quote+"*int)+est+c("+"p".quote+")+"+"•".quote+";end function;display=function(input_list);  return bar(max(input_list)) + c10 + input_list.join(c10);end function;//wisp=c("+"p".quote+")+"+"•".quote+"+c("+"w".quote+")+st+"+"   ".quote+"+est+c("+"p".quote+")+"+"•".quote+";wisp=c("+"p".quote+")+"+"•".quote+"+c("+"w".quote+")+st+"+" ".quote+"+est+c("+"p".quote+")+"+"•".quote+";reveal=function(str, onCondition=0, elseShow="+"".quote+");if onCondition then return str;return elseShow;end function;box=function(str, opt=0, opt2=0);return c("+"b".quote+")+b+"+"[".quote+"+reveal(u, (not opt), "+" ".quote+")+c("+"p".quote+")+str+c("+"b".quote+")+reveal(u2, (not opt), "+" ".quote+")+"+"]".quote+";end function;next=c10+s(17);add_line=function();print c0;end function;cnf=function(str, add=0);  return reveal(c10, (add))+b+("+"[".quote+".color("+"black".quote+")+("+"'".quote+"+str+"+"'".quote+").color("+"white".quote+")+"+"]: command not found!".quote+".color("+"black".quote+"))+c10;end function;mnf=function(str, add);  return reveal(c10, (add))+b+("+"[".quote+".color("+"black".quote+")+("+"'".quote+"+str+"+"'".quote+").color("+"white".quote+")+"+"]: macro not found!".quote+".color("+"black".quote+"))+c10;end function;yon=function(msg);  op=ui(msg);  print op;  spread=[op.lower.search("+"y".quote+"), op.lower.search("+"n".quote+")];  print spread;  while spread[0]+spread[1] != 1;    op=ui(msg);    spread=[op.lower.search("+"y".quote+"), op.lower.search("+"n".quote+")];  end while;  if spread[0] then return true;  return false;end function;operator=function(symbol, msg);return c("+"r".quote+")+"+"[ ".quote+"+c("+"w".quote+")+b+"+"'".quote+"+symbol+"+"'".quote+"+b2+ec+"+" ]: ".quote+"+msg+"+"...".quote+";end function;notify=function(str, type="+"!".quote+", add=0);return reveal(c10, (add))+box(c("+"w".quote+")+type+ec,1)+wisp+box(str,1);end function;longer=function(f,s);if f.len==s.len then return [f,s];if f.len > s.len then return f else return s;end function;shorter=function(f,s);if f.len==s.len then return [f,s];if f.len > s.len then return f else return s;end function;shorten_path=function(s, add_color=0);  if tp(s) != "+"string".quote+" then return "+"".quote+";  if s[0] == "+"/".quote+" then s=s[1:];sl=s.split("+"/".quote+");  if sl.len <= 3 then return "+"/".quote+"+s;  if not add_color then return "+"/".quote+"+sl[0]+"+"/.../".quote+"+sl[-2:].join("+"/".quote+");  return "+"/".quote+".color("+"white".quote+")+sl[0].color("+"black".quote+")+("+"/".quote+".color("+"white".quote+")+"+"...".quote+".color("+"black".quote+")+"+"/".quote+".color("+"white".quote+"))+(sl[-2:].join("+"/".quote+")).color("+"black black white".quote+");end function;hide_ip=function(s);  if tp(s) != "+"string".quote+" or tp(s) == "+"string".quote+" and s.split("+"\.".quote+").len != 4 then return "+"".quote+";  sl=s.split("+"\.".quote+");  return reveal("+"***.***.".quote+"+sl[2:].join("+".".quote+"), (status.streamer_mode), s);end function;quotes=function(input_str);return "+"".quote+""+"".quote+"+input_str+"+"".quote+""+"".quote+";end function;announce=function(input, data);print b+((input+"+": ".quote+").color("+"purple".quote+"))+b2+data+c0;end function;errorDisplay = function(input) ;  if tp(input) == "+"list".quote+" then input = input[0];  if tp(input) != "+"string".quote+" then return c0;  error =  b+("+"[ ".quote+" + "+"?".quote+".color("+"white".quote+") + "+" ]".quote+" + wisp + "+"[ ".quote+" + (input.color("+"white".quote+")) + "+" ]".quote+").color("+"black".quote+");  print error + c10;  return error;end function ;parse_error=function(input_str, beginning=0, ending=1);  while input_str[-1] == "+".".quote+";input_str=input_str[:-1];end while;  if not tp(input_str) == "+"string".quote+" then return tp(input_str);  input_str=input_str.lower;  if beginning and beginning[-1] != "+"'".quote+" then beginning=beginning+"+"'".quote+";  if input_str.search("+"denied".quote+") then input_str="+"permission denied".quote+";  if ending==1 then return reveal(beginning, (beginning!=0), "+"'".quote+")+reveal(input_str.elipsis+"+"' not found.".quote+", (input_str.len>15), input_str+"+"' not found...".quote+");  if tp(ending)=="+"string".quote+" then return reveal(beginning, (beginning!=0), "+"'".quote+")+reveal(input_str.elipsis+ending, (input_str.len>15), input_str+ending);  if not input_str.split("+"error: ".quote+").len < 2 then input_str=input_str.split("+"error: ".quote+")[1]+"+"...".quote+" else input_str=input_str+"+"...".quote+";  return reveal(beginning, (beginning!=0), "+"".quote+")+input_str;end function;printb=function(input="+"".quote+");  print b+(input)+c0;end function;success=function(add=1);  print b+("+"success".quote+".color("+"purple".quote+"))+reveal(c10, (add))+c0;end function;failed=function(add=1);  print b+("+"failed".quote+".color("+"black".quote+"))+reveal(c10, (add))+c0;end function;logo=function();  return b+(a+s(50)+"+"black".quote+".color("+"black".quote+")+"+"box".quote+".color("+"purple".quote+"))+c10;end function;show_prompt=function(im, il, add=1);  if tp(il) == "+"list".quote+" then il=il.join("+" ".quote+");  if il[-1]=="+":".quote+" then il=il[:-1];  print im.prompt+il.color("+"white".quote+")+c0;  if add then add_line;end function;shorten_dialogue=function(input_str, color=1);  char_count=0;word_count=0;res="+"".quote+";  clean=function(inp_str);    reso="+"".quote+";toggle=0;    for i in inp_str;      if i == "+"<".quote+" then ;toggle=1;continue;end if;      if i == "+">".quote+" then ;toggle=0;continue;end if;      if toggle then continue;      reso=reso+i;    end for;    return reso;  end function;  input_str=clean(input_str);  for word in input_str.split("+" ".quote+");    if char_count > 45 then ;char_count=0;res=res+c10+b+"+" ".quote+"; end if;    if word.len > 9 and char_count > 39 then ;res=res+c10;char_count=0;word_count=0; end if;    res=res+reveal("+" ".quote+", (char_count>0 or not word_count), "+"".quote+")+b+reveal(word.color("+"black black purple".quote+"), (color), word);    char_count=char_count+(word.len+1);word_count=word_count+1;    if word.search(c10) then ;char_count=0;word_count=0;end if;  end for;  return res+c10;end function;usage=function(map);  headers=map.indexes;  result="+"".quote+";head_count=0;  for head in headers;    head_count=head_count+1;    if map[head].len > 0 then;      while map[head][0][0]=="+" ".quote+";map[head][0]=map[head][0][1:];end while;    end if;    if map[head].len > 1 and head == "+"usage".quote+" then;      mini_result="+"".quote+";      for item in map[head];        mini_result=mini_result+b+reveal("+" ".quote+", (item[0]!="+" ".quote+"), "+"".quote+")+item.color("+"black black purple".quote+")+c10;      end for;      result=result+b+(head.upper+"+": ".quote+").color("+"black".quote+")+c10;      result=result+mini_result+c10;      continue;    end if;    //if map[head].len == 1 then print head+"+" : ".quote+"+map[head][0].len;    if map[head].len == 1 and map[head][0].len > 45 then;      result=result+b+(head.upper+"+": ".quote+").color("+"black".quote+")+c10;      result=result+shorten_dialogue(map[head][0])+c10;      continue;    else if map[head].len == 1 and map[head][0].len <= 45 then;      result=result+b+(head.upper+"+": ".quote+").color("+"black".quote+")+map[head][0].color("+"black black purple".quote+")+c10;      continue;    end if;    result=result+reveal(c10, (head_count>1))+b+(head.upper+"+":".quote+").color("+"black".quote+");    result=result+c10;    result=result+shorten_dialogue(map[head]);    if head_count==1 then result=result+c10;  end for;  while result[-1]==c10;result=result[:-1];end while;  print result+c10;end function;generate_prompt=function(val=["+"blbx".quote+"], new_line=0);  res="+"".quote+";count=-1;pointer="+"> ".quote+".color("+"purple".quote+");pointer_color=c("+"b".quote+");  for box_content in val;    count=count+1;    res=reveal(next, (new_line==1), "+"".quote+")+reveal(wisp, (count > 0), "+"".quote+")+box(box_content);  end for;  res=res+next+wisp+box("+"#".quote+")+pointer+pointer_color;  return res;end function;//markup.so;"

_src_compiler.body["prompt.src"] = "Prompt = {};Prompt.current_path = "+"/root".quote+";Prompt.ip_address = "+"local".quote+";Prompt.get_current_path = function();    return self.current_path;end function ;Prompt.get_ip_address = function();    return self.ip_address;end function ;Prompt.set_path = function(new_path);    self.current_path = new_path;end function;Prompt.set_ip_address = function(new_ip_address);    self.ip_address = new_ip_address;end function ;Prompt.message = function();    return box("+"blbx".quote+") + wisp + box(self.get_current_path()) + wisp + box(self.get_ip_address()) + "+"\n".quote+" + "+"-".quote+".c("+"black".quote+") + box("+"#".quote+") + "+":> ".quote+";end function;Prompt.get_message = function();    return self.message();end function ;Prompt.show_message = function(cmd_name, params);    print self.message() + b + (cmd_name + "+" ".quote+" + params).c("+"purple".quote+");end function;Prompt.run_command = function(command_ast, show_error = 1);    if not command.hasIndex(command_ast[0].value) then ;        print;        printb("+"[blbx][sys]: command not found...".quote+".c("+"black black purple".quote+"));        print ;        return _callback.catch("+"".quote+", 0) ;    end if ;  ;    safe_run_result = Session.process.safe_run(command_ast[0].value, command_ast[0].params);    ;    if not safe_run_result.status and show_error then;        print ;        print b + safe_run_result.data.c("+"black black purple".quote+");        print ;    end if;    return safe_run_result;end function ;Prompt.prepare_input = function(input, show_error = 1);    count = -1;    for cmd in input.split("+":".quote+");        count = count + 1;        cmd = cmd.trim;        if count > 0 then print self.get_message() + (cmd).c("+"purple".quote+") ;        command_ast = Parser.ParseCLI(cmd);        if not command_ast then continue;        runtime_result = self.run_command(command_ast, show_error);    end for;    Parser.reset();    return true;end function "

_src_compiler.body["lexer.src"] = "c0 = char(0);c33 = char(33);tp = @typeof;cs = @clear_screen;c10=function(int=1);  if not tp(int) == "+"number".quote+" or (tp(int) == "+"number".quote+" and int==1) then return char(10);  return (char(10)*int);end function;TokenTypes = {"+"Command".quote+": "+"COMMAND".quote+", "+"Float".quote+": "+"FLOAT".quote+", "+"Macro".quote+": "+"MACRO".quote+", "+"Assign".quote+": "+"ASSIGN".quote+", "+"Flag".quote+": "+"FLAG".quote+", "+"Number".quote+": "+"NUMBER".quote+", "+"ParenOpen".quote+": "+"PARENOPEN".quote+", "+"ParenClosed".quote+": "+"PARENCLOSED".quote+", "+"BracketOpen".quote+": "+"BRACKETOPEN".quote+", "+"BracketClosed".quote+": "+"BRACKETCLOSED".quote+", "+"Comma".quote+": "+"COMMA".quote+", "+"String".quote+": "+"STRING".quote+", "+"Pipe".quote+": "+"PIPE".quote+", "+"Dot".quote+": "+"DOT".quote+", "+"Argument".quote+": "+"ARGUMENT".quote+"};Lexer = {};Lexer.input = "+"".quote+";Lexer.position = 0;Lexer.first_token = true;Lexer.token_output = [];Lexer.wipe = function();    self.input = "+"".quote+";    self.position = 0;    self.first_token = true;    self.token_output = [];end function;Lexer.get_input = function();    return self.input;end function ;Lexer.set_input = function(new_input);    self.input = new_input;    return self.input;end function;Lexer.consume = function();    if Lexer.get_input() == "+"".quote+" then return null;    element = Lexer.get_input()[0];    Lexer.set_input(Lexer.get_input()[1:]);    return element;end function;Lexer.next_token = function();    ch = self.consume();    if tp(ch) == "+"null".quote+" then return null;    if ch.is_match("+"\s".quote+") then return self.next_token() // skip whitespace;    if ch.is_match("+"".quote+""+"".quote+"+"+"|'".quote+") then ;        quote = ch;        value = "+"".quote+";        ;         // move past the first character;        while self.position < self.input.len ;            next_char = self.consume();            ;            if next_char == quote then break ;            value = value + next_char;        end while ;        return { "+"type".quote+": TokenTypes.String, "+"value".quote+": value };    end if ;    //Handle flags ;    if ch.is_match("+"\-+".quote+") then ;        flag = ch;        temp_flag = ch;        flag_content = [];        fill_toggle = false;        ;        while self.get_input().len > 0 and (ch.is_match("+"\-+".quote+") or ch.is_match("+"[a-zA-Z0-9_]+".quote+") or ch.is_match("+"\[\d+(,\s?\d+)*\]".quote+"));            temp_flag = temp_flag + self.consume();        end while ;        return { "+"type".quote+": TokenTypes.Flag, "+"value".quote+": temp_flag };    end if ;    if ch == "+"-".quote+" then return { "+"type".quote+": TokenTypes.Flag, "+"value".quote+": ch };    ;    //Handle numbers;    if matches(ch, "+"\d+".quote+").len or matches(ch, "+"\.".quote+").len then ;        number = ch;        while self.get_input().len > 0 and matches(ch, "+"\b\d+\b|\.".quote+");            number = number + self.consume();        end while;        ;        return { "+"type".quote+": TokenTypes.Float, "+"value".quote+": number };    end if;    //Handle commands;    if ch.is_match("+"[a-zA-z_]".quote+") then ;        keyword = ch;        ;        while self.get_input().len > 0 and self.get_input()[self.position].is_match("+"[a-zA-Z0-9_]".quote+");			keyword = keyword + self.consume();        end while ;        if self.first_token then ;            self.first_token = false ;            //print { "+"type".quote+": TokenTypes.Command, "+"value".quote+": keyword };            return { "+"type".quote+": TokenTypes.Command, "+"value".quote+": keyword };        end if ;        //print{ "+"type".quote+": TokenTypes.Argument, "+"value".quote+": keyword };        return { "+"type".quote+": TokenTypes.Argument, "+"value".quote+": keyword };    end if;    //Handle punctuation (including comma for argument separation);    if tp("+"(){}=,|".quote+".values.indexOf(ch)) == "+"number".quote+" then self.consume();    if ch == "+"(".quote+" then return { "+"type".quote+": TokenTypes.ParenOpen, "+"value".quote+": ch };    if ch == "+")".quote+" then return { "+"type".quote+": TokenTypes.ParenClosed, "+"value".quote+": ch };    if ch == "+"{".quote+" then return { "+"type".quote+": TokenTypes.BracketOpen, "+"value".quote+": ch };    if ch == "+"}".quote+" then return { "+"type".quote+": TokenTypes.BracketClosed, "+"value".quote+": ch };    if ch == "+"=".quote+" then return { "+"type".quote+": TokenTypes.Assign, "+"value".quote+": ch };    if ch == "+",".quote+" then return { "+"type".quote+": TokenTypes.Comma, "+"value".quote+": ch };    if ch == "+"|".quote+" then return { "+"type".quote+": TokenTypes.Pipe, "+"value".quote+": ch };    //if ch.is_match("+"\.".quote+") then return { "+"type".quote+": TokenTypes.Dot, "+"value".quote+": ch };    return true; //unexpected token;end function;Lexer.Tokenize = function() ;    self.token_output.push(self.next_token());    if tp(self.token_output[-1]) == "+"null".quote+" then ;        self.token_output = self.token_output[:-1];        return self.token_output.clean([true]);    end if ;    if self.token_output[-1] == true then self.token_output = self.token_output[:-1];	return self.Tokenize();end function;"

_src_compiler.body["json.src"] = "JSON={};JSON.write=function(map=false);	desc="+"<color=purple><b>JSON.write: this function takes any map object and parses it into a string in JSON format. does not support maps objects containing functions.".quote+";	if map == "+"help".quote+" then exit(desc);	if typeof(map) != "+"map".quote+" then return "+"<color=red>inputed arg '".quote+"+map+"+"' is not a map.".quote+";	if map=={} then return "+"{".quote+"+c10+"+"}".quote+";  concat=function(num, str);return (str*num);end function;  this={};  this.toStr=function(string);return "+"".quote+""+"".quote+"+string+"+"".quote+""+"".quote+";end function;  this.pair=function(key,value,extra=false);if not extra then return key+"+": ".quote+"+value+"+",".quote+" else return key+"+": ".quote+"+value;end function;  this.result=["+"{".quote+"];	this.transform=function(map);	 this.toggle=false;this.ind=-1;	 list=map.indexes;    for i in map;			this.ind=this.ind+1;			if this.ind == list.len-1 then this.toggle=true;			if typeof(i.key) == "+"string".quote+" then i.key=self.toStr(i.key);      if [(typeof(i.key) == "+"list".quote+"), (typeof(i.key) == "+"map".quote+"), (typeof(i.key) == "+"function".quote+")].indexOf(true) != null then continue;      if typeof(i.value) == "+"string".quote+" and this.result.indexOf(self.pair(i.key , self.toStr(i.value), this.toggle)) == null then ;self.result.push(self.pair(i.key , self.toStr(i.value), this.toggle));continue;end if;      if typeof(i.value) == "+"number".quote+" and this.result.indexOf(self.pair(i.key , i.value, this.toggle)) == null then ;self.result.push(self.pair(i.key , i.value, this.toggle));continue;end if;      if typeof(i.value) == "+"list".quote+" then;temp=[];for ide in i.value;if typeof(ide) == "+"map".quote+" then continue;temp.push(ide);end for;if self.result.indexOf(self.pair(i.key , temp, this.toggle)) == null then self.result.push(self.pair(i.key , temp, this.toggle));continue;end if;      if typeof(i.value) == "+"map".quote+" then ;self.result.push(i.key+"+": {".quote+");this.transform(i.value);continue;end if;    end for;    this.result.push("+"}".quote+");  end function;  this.transform(map);  indent=0;  newResult=[];  for i in this.result;    v=i.split("+": ".quote+")[0];    line=i.split("+": ".quote+");    if line.len == 1 and v == "+"{".quote+" then ;newResult.push(concat(indent, "+" ".quote+")+i);indent=indent+2;continue;end if;		if line.len == 1 and line[0].search("+"}".quote+") then ;indent=indent-2;newResult.push(concat(indent, "+" ".quote+")+i);continue;end if;    if line.len > 1 and line[1].search("+"{".quote+") then ;newResult.push(concat(indent, "+" ".quote+")+i);indent=indent+2;continue;end if;		newResult.push(concat(indent, "+" ".quote+")+i);  end for;  this.result=newResult.join(c10);  return this.result;end function;JSON.read=function(string="+"{}".quote+");  desc="+"<color=red><b>JSON.read: this function takes a serialized map and reverts it back to a usable map object.".quote+";  if string == "+"help".quote+" then exit(desc);  if (tp(string) != "+"string".quote+") then return "+"<color=red>inputed arg '".quote+"+string+"+"' is not a string.".quote+";  if string == "+"{}".quote+" or string=="+"{".quote+"+c10+"+"}".quote+" or string.values.clean(["+" ".quote+", "+"".quote+"]).len==0 then return {};  if string[0]!="+"{".quote+" then string="+"{".quote+"+string;  if string[-1] != "+"}".quote+" then string=string+"+"}".quote+";  get_indent=function(string);count=0;while string[0]=="+" ".quote+";string=string[1:];count=count+1;end while;return count;end function;	group_it=function(input_list);		l=[];ignore=0;temp=input_list;		if temp[0] == "+"{".quote+" then temp=temp[1:];		while temp.len > 0;			i=temp.pull;			if ignore>0 then ;ignore=ignore-1;continue;end if;			if i.search("+": {".quote+") and get_indent(i) == 2 then;				ind2=temp.indexOf("+"  }".quote+");				newl=temp[0:ind2];				while i[0] == "+" ".quote+";i=i[1:];end while;				l.push([i]+newl);				ignore=newl.len;				continue;			end if;			l.push(i);		end while;		return l;	end function;  compile=function(mainl, gll, indent=4);ignore=0;		get_indent=function(s);count=0;while s[0]=="+" ".quote+";s=s[1:];count=count+1;end while;return count;end function;		recursive_build=function(list, pouch);			ignore=0;			if not list.len then return pouch;			while list.len > 0;				i=list.pull;				if ignore > 0 then ;ignore=ignore-1;continue;end if;				if i.search("+": {".quote+") then;					if i.search("+": {}".quote+") then; pouch.push([i[:-1]]) ;continue;end if;					ind2=list.indexOf(("+" ".quote+"*get_indent(i))+"+"}".quote+");					newl=list[0:ind2];					ignore=newl.len;					while i[0] == "+" ".quote+";i=i[1:];end while;					pouch.push(recursive_build(newl, [i]));					if pouch[-1] == [] then pouch[-1].pop;					continue;				end if;				while i[0] == "+" ".quote+";i=i[1:];end while;				if i[-1] == "+",".quote+" then i=i[:-1];				if i.search("+"}".quote+") then continue;				pouch.push(i);			end while;			return pouch;		end function;		check_nested=function(list);if list.join("+"".quote+").search("+": {".quote+") then return true;return false;end function;		for i in mainl;			if tp(i) == "+"list".quote+" then//["+"foo: {".quote+", ["+"bar: {".quote+"]] == {..."+"foo".quote+": {"+"bar".quote+":{}}...};				if not check_nested(i[1:]) then; gll.push(compile(i[1:], [i[0]])) ;continue;end if;				gll.push(recursive_build(i[1:], [i[0]]));				continue;			end if;			if tp(i) == "+"string".quote+" and i.search("+": {}".quote+") then; gll.push([i[:-1]]) ;continue;end if;			if i.split("+": ".quote+").len < 2 then continue;			gll.push(i);		end for;		return gll;  end function;	inputClean=function(l);ll=[];for i in l;if i == "+" ".quote+" or i == "+"".quote+" then continue;ll.push(i);end for;return ll;end function;  main=inputClean(string.split(c10));  glm={};  get_str=function(str);news="+"".quote+";for i in str;if i == "+"".quote+""+"".quote+" then continue;news=news+i;end for;return news;end function;  get_head=function(str);if tp(str.to_int) == "+"number".quote+" then return str.to_int;return get_str(str);end function;  parse=function(mainl, input_map, fp=1)//this function is recursive;		if fp then fp=0;		if not mainl.len then return input_map;		for i in mainl;			while i[0] == "+" ".quote+";i=i[1:];end while;			if i[-1] == "+",".quote+" then i=i[:-1];			if tp(i) == "+"list".quote+" then;				if not i.len then continue;				head=get_head(i[0].split("+": ".quote+")[0]);if tp(head.to_int) == "+"number".quote+" then head=head.to_int;				newl=i[1:];				input_map[head]=parse(newl, {}, 0);				continue;      end if;			if not i.split("+": ".quote+").len > 1 then continue;      head=get_head(i.split("+": ".quote+")[0]);tail=i.split("+": ".quote+")[1];			if tp(head) != "+"number".quote+" and tp(head.to_int) == "+"number".quote+" then head=head.to_int;			if tail.search("+"[".quote+") then;				temp=i.split("+": ".quote+")[-1];				temp=temp.replace("+"\[".quote+", "+"".quote+");temp=temp.replace("+"\]".quote+", "+"".quote+");				chain=temp.split("+", ".quote+");newl=[];ignore=0;				for ide in chain;					if ide.search("+"[]".quote+") then ;newl.push([]);continue;end if;					if ide.search("+"]".quote+") then ;ignore=0;continue;end if;					if ignore then continue;					if ide.search("+"".quote+""+"".quote+") then ;newl.push(get_str(ide));continue;end if;					if not ide.search("+"".quote+""+"".quote+") and tp(ide.to_int)=="+"number".quote+" then ;newl.push(ide.to_int);continue;end if;					if not ide.search("+"".quote+""+"".quote+") and tp(ide.to_int)!="+"number".quote+" then;if ide=="+"true".quote+" then;newl.push(1);else if ide=="+"false".quote+" then;newl.push(0);else;newl.push(ide);end if;continue;end if;					if ide.search("+"[".quote+") then ignore=1;				end for;				input_map[head]=newl;				continue;			end if;      if tail.search("+"".quote+""+"".quote+") then;if get_str(tail)=="+"true".quote+" then input_map[head]=1;if get_str(tail)=="+"false".quote+" then input_map[head]=0;if tail.search("+"".quote+""+"".quote+") then input_map[head]=get_str(tail);continue;end if;			if not tail.search("+"".quote+""+"".quote+") and tp(tail.to_int)=="+"number".quote+" then ;input_map[head]=tail.to_int;continue;end if;			if not tail.search("+"".quote+""+"".quote+") and tp(tail.to_int) != "+"number".quote+" then;				if tail=="+"true".quote+" then;input_map[head]=1;else if tail == "+"false".quote+" then;input_map[head]=0;else;input_map[head]=tail;end if;				continue;			end if;		end for;		return input_map;  end function;	raw_compile=group_it(main);	glm=parse(compile(raw_compile, []), {});	//print glm;  return glm;end function;//testf=hc.File("+"/root/blackbox/db/.exploit/.exploit-1".quote+");//print testf.get_content+c10+c10;//JSON.read(testf.get_content);//exit;//json.so;"

_src_compiler.body["dict.src"] = "String={};String.capitalize=function(string);  if tp(string) == list then string=string.join("+"".quote+");  if string.len<2 then return string.upper;  string=string[0].upper+string[1:].lower//;print("+"string:".quote+" +string);  return string;end function;String.strip=function(t,s);  if not t then return "+"".quote+";  for b in range(0,t.len-1);    if s.indexOf(t[b])==null then break;  end for;  if s.indexOf(t[b])>=0 then return "+"".quote+";  for e in range(-1,-1*t.len);    if s.indexOf(t[e])==null then break;  end for;  if e==-1 then return t[b:];  return t[b:e+1];end function;// pwgen v0.4 author unkown, modifications by Plu70;PasswordGenerator={};PasswordGenerator.PASSWORDSB="+"fifteen,abgDw32fhGu58k,sfuzzer,1111,2222,3333,00000,4444,5555,55555555,4fb426abgDw32fHG,6666,thx1138,7777,8888,9999,0000,oicu812,1337,8008,4hpu79htgbr,80085,007007,43110,69696969,t23t49k21af3,evkfdhgbv78ery,6h057,h4ck,h4ckg4m3,g01ng,p0st4l,g01ngp0st4l,81rd,7074g,35sk1m0,pr0n,n00b,nu8,suxor,hazorz,5uxzorz,owned,pwnd,0wnd,p0wn3d,w00t,woo7,woot,w007,10100111001,teh,meh,lol,brb,afk,wyd,gtfo,lmao,lmfao,gitgud,lawl,troll,bawl,epic,54321,987654321,88888888,555555,1234567890,1973,147147,151515,1515,101010,202020,21122112,12341234,74lk,dir7y,53nP4I,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,1,2,3,4,5,6,7,8,9,0,le375p34k,420420,11111111,112233,h4f4jf53fk74,123abc,1234qwer,123321,5y4hpu79htgbrub,ncc1701e,7777777,51505150,000000,5150,222222,999999,252525,77777777,98765432,poop,polyamorous,zelda,password,6gtr43,123456,12345678,1234,qwerty,12345,dragon,baseball,football,letmein,monkey,696969,abc123,mustang,michael,shadow,master,jennifer,111111,2000,jordan,superman,harley,1234567,hunter,trustno1,ranger,buster,thomas,tigger,robert,soccer,batman,test,pass,hockey,george,charlie,andrew,michelle,love,sunshine,jessica,6969,pepper,daniel,access,123456789,654321,joshua,maggie,starwars,silver,william,dallas,yankees,123123,ashley,666666,hello,amanda,orange,biteme,freedom,computer,sexy,thunder,nicole,ginger,heather,hammer,summer,corvette,taylor,swift,austin,1111,merlin,matthew,121212,golfer,cheese,princess,martin,chelsea,patrick,richard,diamond,yellow,bigdog,secret,asdfgh,sparky,cowboy,camaro,anthony,matrix,falcon,iloveyou,bailey,guitar,jackson,purple,scooter,phoenix,aaaaaa,morgan,tigers,porsche,mickey,maverick,cookie,nascar,peanut,justin,131313,money,horny,samantha,panties,steelers,joseph,snoopy,boomer,whatever,iceman,smokey,gateway,dakota,cowboys,eagles,chicken,black,zxcvbn,please,pharoa,andrea,ferrari,knight,hardcore,porn,ass,love,sex,hooker,blow,coke,melissa,compaq,coffee,booboo,bitch,johnny,bulldog,xxxxxx,welcome,james,player,ncc1701,wizard,scooby,charles,junior,internet,mike,brandy,tennis,banana,monster,spider,lakers,miller,rabbit,enter,mercedes,brandon,steven,fender,john,yamaha,diablo,chris,boston,tiger,marine,chicago,rangers,gandalf,winter,bigtits,barney,edward,raiders,porn,badboy,blowme,spanky,bigdaddy,johnson,chester,london,midnight,blue,fishing,hannah,slayer,rachel,sexsex,redsox,asdf,marlboro,panther,zxcvbnm,arsenal,oliver,qazwsx,mother,victoria,jasper,angel,david,winner,crystal,golden,butthead,viking,jack,iwantu,shannon,murphy,angels,prince,cameron,girls,madison,wilson,carlos,hooters,willie,startrek,captain,maddog,jasmine,butter,booger,angela,golf,lauren,rocket,tiffany,theman,dennis,liverpoo,flower,forever,green,jackie,muffin,turtle,sophie,danielle,redskins,toyota,jason,sierra,winston,debbie,giants,packers,newyork,jeremy,casper,bubba,dracula,sandra,lovers,mountain,united,cooper,driver,tucker,helpme,pookie,lucky,maxwell,8675309,bear,suckit,gators,shithead,jaguar,monica,fred,happy,hotdog,tits,gemini,lover,xxxxxxxx,777777,canada,nathan,victor,florida,nicholas,rosebud,metallic,doctor,trouble,success,stupid,tomcat,warrior,peaches,apples,fish,qwertyui,magic,buddy,dolphins,rainbow,gunner,987654,freddy,alexis,braves,2112,1212,xavier,dolphin,testing,bond007,member,calvin,voodoo,7777,samson,alex,apollo,fire,tester,chess,walter,beavis,voyager,peter,porno,bonnie,rush2112,beer,apple,scorpio,jonathan,skippy,sydney,scott,red123,power,gordon,travis,beaver,star,flyers,232323,zzzzzz,steve,rebecca,scorpion,doggie,legend,ou812,yankee,blazer,bill,runner,birdie,bitches,parker,topgun,asdfasdf,heaven,viper,animal,bigboy,arthur,baby,private,godzilla,donald,williams,lifehack,phantom,dave,rock,august,sammy,cool,brian,platinum,jake,bronco,paul,mark,frank,heka6w2,copper,billy,cumshot,garfield,willow,cunt,little,carter,slut,albert,kitten,super,jordan23,eagle1,shelby,america,11111,jessie,house,free,chevy,bullshit,white,broncos,horney,surfer,nissan,saturn,airborne,elephant,marvin,shit,action,adidas,qwert,kevin,1313,explorer,walker,police,christin,december,benjamin,wolf,sweet,therock,king,online,brooklyn,teresa,cricket,sharon,dexter,racing,penis,gregory,0000,teens,redwings,dreams,michigan,hentai,magnum,87654321,nothing,donkey,trinity,digital,333333,ramsesii,stella,cartman,guinness,speedy,buffalo,kitty,pimpin,eagle,einstein,kelly,nelson,nirvana,vampire,xxxx,playboy,louise,pumpkin,snowball,test123,girl,sucker,mexico,beatles,fantasy,ford,gibson,celtic,marcus,cherry,cassie,888888,natasha,sniper,chance,genesis,hotrod,reddog,alexande,college,jester,passw0rd,smith,lasvegas,carmen,slipknot,death,kimberly,1q2w3e,eclipse,1q2w3e4r,stanley,samuel,drummer,homer,montana,music,aaaa,spencer,jimmy,carolina,colorado,creative,hello1,rocky,goober,friday,AceofSpades,bollocks,scotty,abcdef,bubbles,hawaii,asakista,fluffy,mine,stephen,horses,thumper,darkness,asdfghjk,pamela,boobies,buddha,vanessa,sandman,naughty,douglas,honda,matt,azerty,6666,shorty,money1,beach,loveme,4321,simple,poohbear,444444,badass,destiny,sarah,denise,vikings,lizard,melanie,assman,sabrina,nintendo,water,good,howard,time,123qwe,november,xxxxx,october,zxcv,shamrock,atlantis,warren,wordpass,julian,mariah,rommel,1010,harris,predator,sylvia,massive,cats,sammy1,mister,stud,marathon,rubber,ding,trunks,desire,montreal,justme,faster,kathleen,irish,1999,bertha,jessica1,alpine,sammie,diamonds,tristan,swinger,shan,stallion,pitbull,letmein2,roberto,ready,april,palmer,ming,shadow1,audrey,chong,clitoris,wang,shirley,jackoff,bluesky,sundance,renegade,hollywoo,bernard,wolfman,soldier,picture,pierre,ling,goddess,manager,nikita,76hj93DB3wsa2,sweety,titans,hang,fang,ficken,niners,bottom,bubble,hello123,ibanez,webster,sweetpea,stocking,freeman,french,mongoose,speed,dddddd,hong,henry,hungry,yang,catdog,cheng,ghost,gogogo,randy,tottenha,curious,butterfl,mission,january,singer,sherman,shark,techno,lancer,lalala,autumn,chichi,orion,trixie,clifford,delta,bobbob,bomber,holden,kang,kiss,1968,spunky,liquid,mary,beagle,granny,network,bond,kkkkkk,millie,biggie,beetle,teacher,susan,toronto,anakin,genius,dream,dang,bush,nyx".quote+".split("+",".quote+");PasswordGenerator.PASSWORDSA="+"323232,osint,msfconsole,Bd5gHie89YA,tornado,lindsey,content,bruce,buck,aragorn,griffin,chen,campbell,trojan,christop,newman,wayne,tina,rockstar,father,geronimo,pascal,crimson,brooks,hector,penny,anna,camera,chandler,fatcat,lovelove,cody,cunts,waters,stimpy,finger,cindy,wheels,viper1,latin,robin,greenday,creampie,brendan,hiphop,willy,snapper,funtime,duck,trombone,adult,cotton,cookies,kaiser,mulder,westham,latino,jeep,ravens,aurora,drizzt,madness,hermit,energy,kinky,314159,leather,bastard,young,,extreme,hard,password1,vincent,lacrosse,hotmail,spooky,amateur,alaska,badger,paradise,maryjane,soup,crazy,mozart,video,russell,vagina,spitfire,anderson,norman,otaku,eric,cherokee,cougar,barbara,long,family,horse,enigma,allison,raider,brazil,blonde,jones,55555,dude,drowssap,jeff,school,marshall,lovely,1qaz2wsx,jeffrey,caroline,franklin,booty,molly,snickers,leslie,nipples,courtney,diesel,rocks,eminem,westside,suzuki,daddy,passion,hummer,ladies,Azachary,frankie,elvis,reggie,alpha,suckme,simpson,patricia,pirate,tommy,semperfi,jupiter,redrum,freeuser,wanker,stinky,ducati,paris,natalie,babygirl,bishop,windows,spirit,tiktok,thot,pantera,monday,patches,brutus,houston,smooth,penguin,marley,forest,cream,212121,flash,maximus,nipple,bobby,bradley,vision,pokemon,champion,fireman,indian,softball,picard,system,clinton,cobra,enjoy,lucky1,claire,claudia,boogie,timothy,marines,security,dirty,admin,wildcats,pimp,dancer,hardon,veronica,abcd1234,abcdefg,ironman,wolverin,remember,great,freepass,bigred,squirt,justice,francis,hobbes,kermit,pearljam,mercury,domino,9999,denver,brooke,rascal,hitman,mistress,simon,tony,bbbbbb,friend,peekaboo,naked,budlight,electric,sluts,stargate,saints,bondage,brittany,bigman,zombie,swimming,duke,qwerty1,babes,scotland,disney,rooster,brenda,mookie,swordfis,candy,duncan,olivia,hunting,blink182,alicia,8888,samsung,bubba1,whore,virginia,general,passport,aaaaaaaa,erotic,liberty,arizona,jesus,abcd,newport,skipper,rolltide,balls,happy1,galore,christ,weasel,242424,wombat,digger,classic,bulldogs,poopoo,accord,popcorn,turkey,jenny,amber,bunny,mouse,titanic,liverpool,dreamer,everton,friends,chevelle,carrie,gabriel,psycho,nemesis,burton,pontiac,connor,eatme,lickme,roland,cumming,mitchell,ireland,lincoln,arnold,spiderma,patriots,goblue,devils,eugene,empire,asdfg,cardinal,brown,shaggy,froggy,qwer,kawasaki,kodiak,people,phpbb,light,kramer,chopper,hooker,honey,whynot,lisa,baxter,adam,snake,ncc1701d,qqqqqq,airplane,britney,avalon,sandy,sugar,sublime,stewart,wildcat,raven,scarface,elizabet,123654,trucks,wolfpack,lawrence,raymond,american,alyssa,bambam,movie,woody,shaved,snowman,tiger1,chicks,raptor,1969,stingray,shooter,france,stars,madmax,kristen,sports,jerry,789456,garcia,simpsons,lights,ryan,looking,chronic,alison,hahaha,packard,hendrix,perfect,service,spring,srinivas,spike,katie,oscar,brother,bigmac,suck,single,cannon,georgia,popeye,tattoo,texas,party,bullet,taurus,sailor,wolves,panthers,japan,strike,flowers,pussycat,chris1,loverboy,berlin,sticky,marina,tarheels,fisher,russia,connie,wolfgang,testtest,mature,bass,catch22,juice,michael1,159753,women,alpha1,trooper,hawkeye,head,freaky,dodgers,pakistan,machine,pyramid,vegeta,katana,moose,tinker,coyote,infinity,inside,letmein1,bang,control,hercules,morris,james1,tickle,outlaw,browns,billybob,pickle,test1,michele,antonio,sucks,pavilion,changeme,caesar,prelude,tanner,adrian,darkside,bowling,wutang,sunset,robbie,alabama,danger,zeppelin,juan,rusty,pppppp,nick,2001,ping,darkstar,madonna,qwe123,bigone,casino,cheryl,charlie1,mmmmmm,integra,wrangler,apache,tweety,qwerty12,bobafett,simone,none,business,sterling,trevor,transam,dustin,harvey,england,2323,seattle,ssssss,rose,harry,openup,pandora,trucker,wallace,indigo,storm,malibu,weed,review,babydoll,doggy,dilbert,pegasus,joker,catfish,flipper,valerie,herman,detroit,kenneth,cheyenne,bruins,stacey,smoke,joey,seven,marino,fetish,xfiles,wonder,stinger,pizza,babe,pretty,stealth,manutd,gracie,gundam,cessna,longhorn,presario,mnbvcxz,wicked,mustang1,victory,shelly,awesome,athena,q1w2e3r4,help,holiday,knicks,street,redneck,casey,gizmo,scully,dragon1,devildog,triumph,eddie,bluebird,shotgun,peewee,hubris,ronnie,angel1,daisy,special,metallica,madman,country,impala,lennon,roscoe,omega,access14,enterpri,miranda,search,smitty,blizzard,unicorn,tight,rick,ronald,asdf1234,harrison,trigger,truck,danny,home,winnie,beauty,thailand,cadillac,castle,tyler,bobcat,buddy1,sunny,stones,asian,freddie,chuck,butt,loveyou,norton,hellfire,hotsex,indiana,short,panzer,lonewolf,trumpet,colors,blaster,12121212,fireball,logan,precious,aaron,elaine,jungle,masamune,atlanta,gold,corona,curtis,nikki,polaris,timber,theone,baller,chipper,orlando,island,skyline,dragons,dogs,benson,licker,goldie,engineer,kong,pencil,basketba,open,hornet,world,linda,barbie,chan,farmer,valentin,indians,larry,redman,foobar,travel,morpheus,bernie,target,141414,hotstuff,photos,laura,savage,holly,rocky1,dollar,turbo,design,newton,hottie,moon,blondes,4128,lestat,avatar,future,goforit,random,abgrtyu,jjjjjj,q1w2e3,smiley,goldberg,express,zipper,wrinkle1,stone,andy,babylon,dong,powers,consumer,dudley,Aster,monkey1,serenity,samurai,99999999,skeeter,lindsay,joejoe,master1,aaaaa,chocolat,christia,birthday,stephani,tang,alfred,ball,maria,sexual,maxima,sampson,buckeye,highland,kristin,seminole,reaper,bassman,nugget,lucifer,airforce,nasty,watson,warlock,2121,philip,always,dodge,chrissy,burger,bird,snatch,missy,pink,gang,maddie,holmes,huskers,piglet,photo,joanne,hamilton,dodger,paladin,christy,chubby,buckeyes,hamlet,abcdefgh,bigfoot,sunday,manson,goldfish,garden,deftones,icecream,blondie,spartan,julie,harold,charger,brandi,stormy,sherry,pleasure,juventus,rodney,galaxy,holland,escort,zxcvb,planet,jerome,wesley,blues,song,peace,david1,1966,cavalier,gambit,karen,sidney,ripper,jamie,sister,marie,martha,nylons,aardvark,nadine,minnie,whiskey,bing,plastic,anal,babylon5,chang,savannah,loser,racecar,insane,yankees1,mememe,hansolo,chiefs,fredfred,freak,frog,salmon,concrete,yvonne,sophia,stefan,8a1n80w,slick,rocker,opensesame,onessnap".quote+".split("+",".quote+");PasswordGenerator.PASSWORDS = PasswordGenerator.PASSWORDSA + PasswordGenerator.PASSWORDSB;PasswordGenerator.init=function(samples);  self.s=[];  self.c={};  for string in samples;    string=string.trim.upper;    if string.len>3 then self.s.push(string);  end for;  for string in self.s;    for ind in range(0,string.len-4);      k=string[ind:ind+3];      if self.c.hasIndex(k) then;        if self.c[k].indexOf(string[ind+3])==null then self.c[k].push(string[ind+3]);      else;        self.c[k]=[string[ind+3]];      end if;    end for;  end for;end function;PasswordGenerator.r=function(length,snip,object);  suffix=snip[snip.len-3:];  if self.c.hasIndex(suffix) and snip.len<length then;    for char in self.c[suffix];      self.r(length,(snip+char),object);    end for;  else;    object[snip]=1;  end if;end function;PasswordGenerator.AllPasswords=function();  r={};  for string in self.s;    for i in range(0,string.len-4);      self.r(string.len,string[i:(i+3)],r);    end for;  end for;  sub=[];final=[];final2=[];  for s in r.indexes;    if sub.indexes.len == 3 then ;o=o+sub;sub={}; end if;    s=inputClean(s);    if s.indexOf("+"".quote+")>=0 then;    n=s.split("+"".quote+");    for i in range(0,n.len-1);    n[i]=String.capitalize(n[i]);    end for;s=n.join("+"".quote+");    else;    s=String.capitalize(s);    end if;    if s.len<5 then continue;    a=s[0];    b=s[1];    if a.lower==b or "+"hrl'aeiou".quote+".indexOf(b)==null and "+"AEIOUS".quote+".indexOf(a)==null and [Ch,Mc].indexOf(a+b)==null then s=String.capitalize(s[1:]);    s=String.strip(s,"+"'-".quote+");    sub.push(s);    sub.push(s.lower);    str_len=str(sub.len);    if str_len.len > 3 and str_len[-3:].search(000) then ;final.push(sub);final2=final2+sub;sub=[];continue;end if;  end for;  return final;end function;//PasswordGenerator.init(PasswordGenerator.PASSWORDS);//dict.so"

_src_compiler.body["internal.src"] = "Directory = {};;Directory.find_file_memory = [];;Directory.find_file = function(file_obj, file_path = 0, file_name = 0, return_all = 0, is_first_pass = 1);    if is_first_pass then ;        if file_path == "+"".quote+" then file_path = "+"/".quote+";        find_file_memory = [];        is_first_pass = 0 ;    end if ;;    if tp(file_path) == "+"string".quote+" and file_path == "+"/".quote+" then return file_obj;    if tp(file_path) == "+"string".quote+" and path[0] != "+"/".quote+" then path = "+"/".quote+" + path;    if tp(file_path) == "+"string".quote+" and path[-1] == "+"/".quote+" then path = path[:-1];    if tp(file_path) == "+"string".quote+" then file_path = file_path.lower;    if tp(file_name) == "+"string".quote+" then file_name = file_name.lower;;    target_file = false;;    for object in file_obj.get_folders + file_obj.get_files;        if tp(object) != "+"file".quote+" then continue;        if not return_all and tp(target_file) == "+"file".quote+" then ;            self.find_file_memory = [];            return target_file;        end if ;        ;        if return_all and [file_path, file_name] == [0, 0] then ;            self.find_file_memory.push([object, object.name, object.get_content, {"+"is_folder".quote+": object.is_folder, "+"is_binary".quote+": object.is_binary}, object.size, object.permissions, object.owner, object.group]);            continue ;        end if ;;        if (return_all and tp(file_name) == "+"string".quote+") and object.name.lower == file_name.lower then ;            self.find_file_memory.push([object, object.name, object.get_content, {"+"is_folder".quote+": object.is_folder, "+"is_binary".quote+": object.is_binary}, object.size, object.permissions, object.owner, object.group]);            continue;        end if ;;        if (tp(file_path) == "+"string".quote+" and not return_all) and object.path.lower == file_path.lower then ;            target_file = object ;            continue;        end if ;        ;        if (tp(file_name) == "+"string".quote+" and not return_all) and object.name.lower.search(file_name) then ;            target_file = object ;            continue;        end if ;;        if ([file_path, file_name, return_all] == [0, 0, 0]) then ;            self.find_file_memory.push([object, object.name, object.path, object.get_content, {"+"is_folder".quote+": object.is_folder, "+"is_binary".quote+": object.is_binary}, object.size, object.permissions, object.owner, object.group]);            continue;        end if ;        if object.is_folder then target_file = self.find_file(object, file_path, file_name, return_all, is_first_pass);    end for ;;    if ([file_path, file_name, return_all] == [0, 0, 0]) or return_all then return self.find_file_memory;    self.find_file_memory = [] ;   ;    return target_file;end function;;Directory.validate_file = function(root_file, cmd_name, param_token, only_folders = 0);    param_token_value = param_token[0].value;    param_token_type = param_token[0].type;    target_file = false;    ;    is_keyword = true ;    if param_token_value.split("+"/".quote+").len > 1 then is_keyword = false;    ;    if not tp(root_file) == "+"file".quote+" then return _callback.catch("+"[blbx][".quote+"+cmd_name+"+"][err]: remote session has no file objects...".quote+");    ;    if is_keyword then ;        target_file = Directory.find_file(root_file, 0, param_token_value);        if not tp(target_file) == "+"file".quote+" then return _callback.catch("+"[blbx][".quote+"+cmd_name+"+"][err]: could not find target file by name...".quote+");        return _callback.catch(target_file, 1);    end if;;    target_file = Directory.find_file(root_file, param_token_value, 0);    if not tp(target_file) == "+"file".quote+" then return _callback.catch("+"[blbx][".quote+"+cmd_name+"+"][err]: could not find target file by name...".quote+");    if not target_file.is_folder and only_folders then return _callback.catch("+"[blbx][".quote+"+cmd_name+"+"][err]: object must be a folder...".quote+");;    return _callback.catch(target_file, 1);end function ;;;Session = {};;Session.process = {};;;Session.process.safe_run = function(cmd_name, parameters);    if tp(command.indexes.indexOf(cmd_name)) != "+"number".quote+" then return false;    command_syntax_proxy = command[cmd_name];    return command_syntax_proxy(parameters);end function;;Session.process.status = true;Session.process.connected = false;;Session.process.is_running = function();    return self.status;end function ;;Session.process.set_status = function(new_status);    self.status = new_status;    return self.status;end function;;Session.process.is_connected = function();    return self.connected;end function ;;Session.process.set_connected = function(new_connected);    self.connected = new_connected;    return self.status;end function;;Session.db = {};Session.db.items = {};Session.db.root_folder = "+"/root/blackbox/db/".quote+";;Session.db.get_path = function(table_name);    return self.root_folder + "+".".quote+" + table_name;end function;;Session.db.init_database = function(table_name);    get_shell.host_computer.touch(self.get_path(table_name), "+"init_blbx_db.json".quote+");    init_path = self.get_path(table_name) + "+"/init_blbx_db.json".quote+";    init_file = Directory.find_file(get_shell.host_computer.File("+"/".quote+"), init_path);    ;    if not tp(init_file) == "+"file".quote+" then return false;    init_file.set_content(JSON.write({"+"name".quote+": table_name, "+"entries".quote+": 0}));    ;    init_file.chmod("+"u-rwx".quote+");    init_file.chmod("+"g-rwx".quote+");    init_file.chmod("+"o-rwx".quote+");end function;;Session.db.select = function(table_name);    if table_name.split("+"/".quote+").len == 1 then table_name = self.get_path(table_name);    print "+"internal 137: ".quote+"+ table_name;    target_directory = Directory.find_file(get_shell.host_computer.File("+"/".quote+"), table_name);    print "+"internal 138: ".quote+"+ target_directory;    if not tp(target_directory) == "+"file".quote+" then return false;    return target_directory;end function ;;Session.db.add_file = function(table_name);    database = self.select(table_name);    if not database then return false ;    entry_name = "+".".quote+" + table_name + "+"-".quote+" + str(database.get_files.len);    create_entry_file = get_shell.host_computer.touch(database.path, entry_name);    if not create_entry_file then return false;    check_entry = Directory.find_file(get_shell.host_computer.File("+"/".quote+"), database.path + "+"/".quote+" + entry_name);    check_entry.set_content(JSON.write({}));    return check_entry;end function;;Session.db.create = function(table_name) ;    self.init_database(table_name);    self.add_file(table_name);end function;;Session.db.parse = function(table_name);    database = self.select(table_name);    print "+"internal 160: ".quote+"+ database;    if tp(database) != "+"file".quote+" then return false ;    database = database.get_files;;    result = {};    for entry_file in database ;        if entry_file.name.lower.search("+"init_blbx_db.json".quote+") then continue ;        result = result + JSON.read(entry_file.get_content);    end for ;    return result ;end function;;Session.db.split_map = function(map, max_size = 10000);    temp = map ;    master = {"+"0".quote+": {}};    index1 = -1;    index2 = -1;;    total_length = function();        count = 0;        for element in master.values ;            count = count + element.len ;        end for ;        return count ;    end function ;;    while not total_length() >= map.len ;        recent_child_object = master.values[-1];        index1 = index1 + 1;        if not master.hasIndex(str(index)) then ;            master[str(index)] = {} ;            continue ;        end if ;        while recent_child_object.len < max_size;            index2 = index2 + 1;            if index2 >= max_size then break ;            wait(.1);            temp_indexes = temp.indexes[:1];            temp_values = temp.values[:1];            recent_child_object[temp_indexes[0]] = temp_values[0];            temp.pop;        end while ;        index1 = index1 + 1;        master[str(index1)] = {};    end while ;    return master;end function ;;Session.db.add_to = function(incoming_data = [], table_name);    if not incoming_data.len then return true ;    if tp(incoming_data) != "+"map".quote+" and tp(incoming_data) != "+"list".quote+" then return false;    database = self.select(table_name);    if not database then return false;    database = database.get_files;    if not database.len then self.init_database(table_name);    if database.len == 1 then ;        self.add_file(table_name);        database = self.select(table_name).get_files;    end if ;    ;    entry_file = database[-1];;    if tp(incoming_data) == "+"list".quote+" then ;        if entry_file.get_content.len >= 30000 then ;            self.add_file(table_name);            self.add_to(incoming_data, table_name);            break ;        end if ;;        while incoming_data.len > 0;            entry = incoming_data[0];            if entry_file.get_content.len >= 30000 then ;                self.add_file(table_name);                self.add_to(incoming_data, table_name);                break;            end if ;            try = entry_file.set_content(entry_file.get_content + fif((not entry_file.get_content.len), "+"".quote+", "+" ".quote+") + entry.join("+" ".quote+"));            incoming_data.pull;        end while ;        return true;    end if;;    map_content = JSON.read(entry_file.get_content);    if incoming_data.len >= 10000 then ;        entry = self.split_map(incoming_data);        entry_arr = entry.values ;;        for entry in entry_arr ;            if entrentry_y_file.get_content.len >= 30000 then ;                self.add_file(table_name);                self.add_to(entry, table_name);            end if ;        end for ;    end if ;    map_content = map_content + incoming_data;    entry_file.set_content(JSON.write(map_content));    return true;end function ;;Session.db.reset = function(table_name);    database = self.select(table_name);    if not database then return false ;    database = database.get_files;    for entry_file in database;        if entry_file.name.lower.search("+"init_blbx_db.json".quote+") then continue ;        entry_file.delete;    end for ;    return true  ;end function ;;Session.db.set = function(incoming_data, table_name);    database = self.select(table_name);    if tp(database) != "+"file".quote+" then return false ;    if tp(incoming_data) == "+"list".quote+" then ;        incoming_data = incoming_data.combine;        if not incoming_data.len then return false;    end if ;    store = self.reset(table_name);    self.add_file(table_name);    if not store then return false ;    self.add_to(incoming_data, table_name) ;    return true;end function ;;Session.db.has_entry = function(entry, table_name);    database = self.select(table_name);    if tp(database) != "+"file".quote+" then return false ;    database = database.get_files ;    temp = {};    for entry_file in database ;        if entry.file.name.lower.search("+"init_blbx_db.json".quote+") then continue ;        temp = temp + JSON.read(file.get_content);    end for ;    if temp == {} then return false ;    if temp.hasIndex(entry) or tp(temp.indexes.indexOf(entry)) == "+"number".quote+" or tp(temp.values.indexOf(entry)) == "+"number".quote+" then return true;    return false;end function;;Session.db.has = function(table_name);    database = self.select(table_name);    if not database then return false ;    return true;end function ;;Session.macro = {};Session.macro.extract_db = function();;end function ;;Session.dict = {};Session.dict.extract_db = function();;end function ;;Session.exploits = {};Session.exploits.extract_db = function();;end function;;Session.rpc = {} // Remote Procedure Call - look it up;Session.rpc.hand_shake = get_custom_object();;Session.rpc.get_hand_shake = function();    return self.hand_shake;end function ;;Session.rpc.wipe_hand_shake = function();    self.hand_shake = get_custom_object();    return self.hand_shake;end function ;;;Session.rpc.get_access = function(file_instance);    for machine_file in file_instance.get_folders;        if machine_file.has_permission("+"w".quote+") and machine_file.has_permission("+"x".quote+") then return machine_file;;        result = self.get_access(machine_file);        if not result then continue ;        return result ;    end for ;    return false;end function ;;Session.rpc.set_endpoint = function(shell_instance, src_file_name, src_file_content);    comp_instance = shell_instance.host_computer;    file_instance = comp_instance.File("+"/".quote+");    ;    accessed_file = self.get_access(file_instance);    if not accessed_file then return _callback.catch("+"[session][rpc][endp]: no accessable directories found...".quote+");    accessed_file_path = fif((accessed_file.path == "+"/".quote+"), "+"".quote+", accessed_file.path);    src_file_name = "+".".quote+" + src_file_name ;    src_file_path = accessed_file_path + "+"/".quote+" + src_file_name;;    try_touch = comp_instance.touch(fif(accessed_file_path == "+"".quote+"), "+"/".quote+", src_file_name);    if not try_touch then return _callback.catch("+"[session][rpc][endp]: failed to create '".quote+"+src_file_name+"+"', permission denied...".quote+");    touched_file = comp_instance.File(src_file_path);    if not touched_file then return _callback.catch("+"[session][rpc][endp]: source file '".quote+"+src_file_name+"+"' created but not found...".quote+");    touched_file.set_content(src_file_content.split("+";".quote+").join(char(10)));    ;    store = shell_instance.build(touched_file.path, fif((accessed_file_path == "+"".quote+"), "+"/".quote+", accessed_file_path));;    binary_name = src_file_name[:-1] // removes '.src';    if tp(store) == "+"string".quote+" and store.len > 0 then return _callback.catch("+"[session][rpc][endp]: ".quote+" + store);    binary_file = comp_instance.File(accessed_file_path + "+"/".quote+" + binary_name);    if not tp(binary_file) == "+"file".quote+" then return _callback.catch("+"[session][rpc][endp]: binary file '".quote+"+binary_name+"+"' created but not found...".quote+");    ;    return _callback.catch(binary_file.path, 1);end function;;Session.rpc.data = {} // organizes RPC data for sending and recieving;;Session.rpc.data.catch = function(callback);    return callback(get_custom_obj());end function;;Session.rpc.data.send = function(shell_instance, program_path = "+"".quote+", program_prompt = "+"".quote+", data = {}, delete = 0);    self.get_hand_shake().data = data;;    try_rpc = shell_instance.launch(program_path, program_prompt.trim);    if tp(try) == "+"string".quote+" then return _callback.catch("+"[session][rpc][send]: ".quote+" + try_rpc);    return true;end function;;;Session.machine = {};Session.machine.ip = {};Session.machine.ip.lan_address = "+"".quote+";Session.machine.ip.pub_address = "+"".quote+";Session.machine.ip.lan_address_arr = [];Session.machine.ip.pub_address_arr = [];;Session.machine.ip.get_lan = function();    return self.lan_address;end function;;Session.machine.ip.set_lan = function(new_lan_address);    self.lan_address = new_lan_address;    return self.lan_address;end function;;Session.machine.ip.get_pub = function();    return self.pub_address;end function ;;Session.machine.ip.set_pub = function(new_pub_address);    self.pub_address = new_pub_address;    return self.pub_address;end function ;;Session.machine.ip.add_lan_address = function(new_lan_address);    self.lan_address_arr.push(new_lan_address);    return new_lan_address;end function ;;Session.machine.ip.set_lan_address_arr = function(new_lan_address_arr);    self.lan_address_arr = new_lan_address_arr;    return self.lan_address_arr;end function ;;Session.machine.ip.get_lan_address_arr = function();    return self.lan_address_arr;end function ;;Session.machine.ip.get_lan_address = function();    return self.lan_address;end function ;;Session.machine.ip.add_pub_address = function(new_pub_address);    self.pub_address_arr.push(new_pub_address);    return new_pub_address;end function ;;Session.machine.ip.set_pub_address_arr = function(new_pub_address_arr);    self.pub_address_arr = new_pub_address_arr;    return self.pub_address_arr;end function ;;Session.machine.ip.get_pub_address_arr = function;    return self.pub_address_arr;end function ;;;Session.machine.user = {"+"tree".quote+": {}};Session.machine.user.current = {"+"name".quote+": "+"".quote+"};;Session.machine.user.get_name = function();    return self.current.name;end function;;Session.machine.user.set_name = function(new_user_name);    self.current.name = new_user_name;    return self.current.name;end function ;;Session.machine.user.wipe = function() ;    self.current = {"+"name".quote+": "+"".quote+"};end function;;Session.object = {};;Session.object.rshell = {"+"list".quote+": []};Session.object.shell = {"+"list".quote+": []};Session.object.computer = {"+"list".quote+": []};Session.object.file = {"+"list".quote+": []};;Session.parse_object = function(object_list, lan_address, as_user = 0, return_all = 0);    if not object_list.len then return false ;    user_dict = {"+"root".quote+": [], "+"guest".quote+": [], "+"unknown".quote+": [], "+"usr".quote+": []};    for object_arr in object_list;        object = object_arr[0];        username = object_arr[1];        lanip = object_arr[2];;        if as_user then ;            if username.lower.search(us_user.lower) then user_dict.usr.push(object);            continue;        end if;;        if username == "+"root".quote+" then user_dict.root.push(object);        if username == "+"guest".quote+" then user_dict.guest.push(object);        if username == "+"unknown".quote+" then user_dict.unknown.push(object);        if not tp(user_dict.usr.indexOf(isername)) == "+"number".quote+" then user_dict.usr.push(object);    end for ;;    if not as_user and lan_address and return_all then return user_dict.root + user_dict.guest + user_dict.unknown + user_dict.usr;    if user_dict.root.len > 0 then return user_dict.root[0];    if user_dict.usr.len > 0 then return user_dict.usr[0];    if user_dict.unknown.len > 0 then return user_dict.unknown[0];    if user_dict.guest.len > 0 then return user_dict.guest[0];;    return false;end function;;Session.is_empty = function(object_name);    if not self.object[object_name].list.len then return true ;    return false ;end function ;;Session.get_object_arr = function(object_type);    return self.object[object_type];end function;;Session.borrow = function(object_name, as_user = 0);    if self.is_empty(object_name) then return false;;    object = self.parse_object(self.object[object_name].list, self.machine.ip.get_lan(), as_user);    if not object then return false ;    return object ;end function ;;Session.allocate = function(object, lanip);    if tp(["+"shell".quote+", "+"computer".quote+", "+"file".quote+"].indexOf(tp(object)) == "+"number".quote+") then printb(tp(object).c("+"purple".quote+"));    if tp(object) == "+"shell".quote+" or tp(object) == "+"rshell".quote+" then ;        self.add(object, lanip);        self.add(object.host_computer, lanip);        self.add(object.host_computer.File("+"/".quote+"), lanip);    end if ;    if tp(object) == "+"computer".quote+" then ;        self.add(object, lanip);        self.add(object.File("+"/".quote+"), lanip);    end if ;    if tp(object) == "+"file".quote+" then ;        while object.path != "+"/".quote+" ;            object = object.path ;        end while ;        self.add(object, lanip);    end if ;end function;;Session.get_user = function(object);    if tp(object) == "+"shell".quote+" then object = object.host_computer ;    if tp(object) == "+"computer".quote+" then object = object.File("+"/".quote+");;    if not tp(Directory.find_file(object, "+"/root".quote+")) == "+"file".quote+" then file = [Directory.find_file(object, "+"/boot/System.map".quote+"), Directory.find_file(object, "+"/home".quote+")] else file = [Directory.find_file(object, "+"/root".quote+"), Directory.find_file(object, "+"/home".quote+")];    if not tp(file[0]) == "+"file".quote+" and file[0].has_permission("+"w".quote+") then return root;    if tp(file[1]) == "+"file".quote+" then file_list = file[1].get_folders else return false ;    users = [] ;    result = [];;    for file in file_list ;       if file.has_permission("+"w".quote+") then users.push(file.name);    end for ;;    if users.hasIndex(1) then return users[0];    if tp(users.indexOf("+"guest".quote+")) == "+"number".quote+" then return "+"guest".quote+";    return "+"unknown".quote+";end function;;Session.add = function(object, lanip);    self.object[tp(object)].list.push([object, self.get_user(object), lanip, tp(object)]);    if tp(object) == "+"shell".quote+" then return self.add(object.host_computer, lanip);    if tp(object) == "+"computer".quote+" then return self.add(object.File("+"/".quote+"), lanip);end function ;;Session.wipe = function();    self.object.number = {"+"list".quote+": []};    self.object.rshell = {"+"list".quote+": []};    self.object.shell = {"+"list".quote+": []};    self.object.comp = {"+"list".quote+": []};    self.object.file = {"+"list".quote+": []};end function;;;Exploit = {};;Exploit.net_session = false ;Exploit.change_password = false;Exploit.scan_library = false ;;Exploit.get_net_session = function();    return self.net_session;end function ;;Exploit.set_net_session = function(new_net_session);    self.net_session = new_net_session;end function ;;Exploit.is_change_pass = function();    return self.change_password;end function ;;Exploit.set_change_pass = function(new_pass_bool);    self.change_password = new_pass_bool;    return self.change_password;end function    ;;Exploit.is_scan_mode = function();    return self.scan_library;end function ;;Exploit.set_scan_mode = function(new_mode_bool);    self.scan_library = new_mode_bool;    return self.scan_library;end function;;Exploit.device = {};;Exploit.device.tree = {};Exploit.device.current = {};Exploit.device.user_map = {};Exploit.device.serialized_tree = "+"".quote+";;Exploit.device.get_current = function();    return self.current;end function;;Exploit.device.set_current = function(new_current_device);    self.current = new_current_device;    return self.current;end function;;Exploit.device.add = function(lan_address);    output_object = {};    output_object.lan_address = lan_address;;    output_object.shells = Session.parse_object(Session.get_object_arr("+"shell".quote+"), lan_address, 0, 1);    output_object.computers = Session.parse_object(Session.get_object_arr("+"computer".quote+"), lan_address, 0, 1);    output_object.files = Session.parse_object(Session.get_object_arr("+"file".quote+"), lan_address, 0, 1);;    total_users = [];;    for object_arr in output_object.shells + output_object.computers + output_object.files;        try_user = object_arr[1];        if tp(total_users.indexOf(try_user)) == "+"number".quote+" then continue;        total_users.push(try_user);    end for ;;    output_object.user_arr = total_users;    self.tree[lan_address] = output_object;    ;    return output_object;end function ;;Exploit.device.has = function(lan_address);    return self.tree.hasIndex(lan_address);end function;;Exploit.device.get = function(lan_address);    if not self.has(lan_address) then return false ;    return self.device.tree[lan_address];end function ;;Exploit.device.add_user = function(lan_address, username = 0);    if not self.user_map.hasIndex(lan_address) then self.user_map[lan_address] = [];    user_arr = self.user_map[lan_address];    if username then user_arr.push(username);    return true ;end function;;Exploit.device.has_user = function(username, lan_address);    if not self.user_map.hasIndex(lan_address) then return false;    return tp(self.user_map[lan_address].indexOf(username)) == "+"number".quote+";end function ;;Exploit.device.get_user = function(username, lan_address);    full_username = false;    if not self.has_user(username, lan_address) then return false;    for user in self.device.user_map[lan_address];        if user.lower.search(username.lower) then ;            full_username = user ;            break ;        end if ;    end for ;    return full_username;end function;;Exploit.device.get_user_arr = function(lan_address);    if not self.user_map.indexes.hasIndex(lan_address) then return false ;    return self.user_map[lan_address];end function ;;Exploit.device.collect = function();    for lan_address in Session.machine.ip.get_lan_address_arr();        if not self.has(lan_address) then self.add(lan_address);        if not self.user_map.hasIndex(lan_address) then self.add_user(lan_address);        ;        for obj in Session.object.shell.list + Session.object.computer.list + Session.object.file.list;            if lan_address != obj[2] then continue;            username = obj[1];            if not self.has_user(username, lan_address) then self.add_user(lan_address, username);        end for  ;;        self.add_user(lan_address);    end for ;end function ;;Exploit.module = {};Exploit.module.library = {};;Exploit.module.get_payloads = function(library, check = 0, find_memory = 0);    database = Session.db.parse("+"exploit".quote+");    library_name = library.lib_name ;    library_version = library.version ;    if not database.len then return false ;    if not database.hasIndex(library_name) then return false ;    if database.hasIndex(library_name) and not database[library_name].hasIndex(library_version) then return false;    if check then return true ;    ;    owned_memory_array = database[library_name][library_version].indexes;    mathes = [];    payload = [];    for memory_address in owned_memory_array;        if not find_memory then ;            payload = payload + database[lib_name][library_version][memory_address];            continue ;        end if ;;        if memory_address == find_memory then ;            payload = database[library_name][library_version][memory_address];            break ;        end if ;    end for ;;    return payload;end function;;Exploit.module.create_exploit = function(payload_arr, memory_address, library_name, library_version);    return {library_version: {memory_address: payload_arr}};end function;;Exploit.module.add_exploit = function(database_entry, library);    add_line ;    printb(("+"storing to ".quote+" + library.lib_name + "+" v".quote+" + library.version).c("+"black black purple".quote+"));    ;    saved_database = Session.db.parse("+"exploit".quote+");    library_name = library.lib_name;    library_version = library.version ;    ;    for entry in database_entry ;        ;        print "+"internal 710: saved_database: ".quote+"+ saved_database;        if not saved_database.len or (saved_database.len > 0 and not saved_database.hasIndex(library_name)) then saved_database[library_name] = {};        print "+"internal 712: saved_database[library_name]: ".quote+"+ saved_database[library_name];        if not saved_database[library_name].len or (saved_database[library_name].len > 0 and not saved_database[library_name].hasIndex(library_version)) then saved_database[library_name][library_version] = {};        print "+"internal 714: saved_database[library_name][library_version]: ".quote+"+ saved_database[library_name][library_version];        //print not saved_database[library_name].len or (not saved_database[library_name].hasIndex(library_version));        print saved_database[library_name].hasIndex(library_version);        ;        print entry.value;        printb((("+"adding ".quote+" + str(entry.indexes.len) + "+" exploits to ".quote+" + library_name + "+" v".quote+" + library_version).c("+"purple".quote+")).c("+"purple".quote+"));        //saved_database[library_name][library_version] = entry.value ;;        for memory_address in saved_database[library_name][library_version];            saved_database[library_name][library_version][memory_address] = (saved_database[library_name][library_version][memory_address] + entry.value[memory_address]).remove_repeats;        end for ;;    end for ;    Session.db.set(saved_database, "+"exploit".quote+");    return true ;end function ;;Exploit.module.get_local_lib = function(library_name);    try_library_arr = Directory.find_file(get_shell.host_computer.File("+"/".quote+"), 0, library_name, 1);    ;    if not try_library_arr.len then return false ;    result = false ;    for library_file in try_library_arr ;        library_file = library_file[0];        if library_file.name == library_name then ;            try_library = include_lib(library_file.path);            if tp(["+"null".quote+", "+"number".quote+"].indexOf(tp(try_library))) == "+"number".quote+" then continue;            result = try_library;            break ;        end if ;    end for ;;    return result;end function ;;;Exploit.module.library.get_metax = function();    return Exploit.module.get_local_lib("+"metaxploit.so".quote+");end function ;;Exploit.module.library.get_crypto = function();    return Exploit.module.get_local_lib("+"crypto.so".quote+");end function ;;Exploit.module.parse_exploits = function(library, scan_library = 0);    exploit_map = {};    ;    if not scan_library then ;        database = Session.db.parse("+"exploit".quote+");        print "+"internal 751: ".quote+"+ database;        if not database then return false;        if not database.hasIndex(library.lib_name) then return false ;        if not database[library.lib_name].hasIndex(library.version) then return false;        memory_address_arr = database[library.lib_name][library.version].indexes;        ;        for address in memory_address_arr ;            unsafe_value_arr = Exploit.module.get_payloads(library, 0, address);            exploit_map[address] = unsafe_value_arr;        end for ;;        return exploit_map;    end if ;;    memory_address_arr = Exploit.module.library.get_metax().scan(library);    ;    for address in memory_address_arr;        unsafe_value_arr = [];        output = Exploit.module.library.get_metax().scan_address(library, address);        for line in output.split(c10);            if tp(line.indexOf("+"</b>.".quote+")) == "+"number".quote+" then unsafe_value_arr.push(slice(line, line.indexOf("+"<b>".quote+"), line.indexOf("+"</b>".quote+"))[3:]);        end for ;        print "+"internal 776: ".quote+"+ unsafe_value_arr;        exploit_map[address] = unsafe_value_arr;    end for ;;    return exploit_map;end function ;;Exploit.module.run_exploits = function(payload_arr = [], memory_address, lan_address, library, change_password = 0);    if not payload_arr.len then return false ;    third_arg = false ;;    if change_password then third_arg = change_password;;    for payload in payload_arr;        if third_arg then object = library.overflow(memory_address, payload, third_arg) else object = library.overflow(memory_address, payload);        if tp(object) == "+"null".quote+" then continue ;        if tp(object) == "+"number".quote+" then ;            printb("+"password changed or firewall bypassed...".quote+".c("+"black".quote+"));            printb(("+"new password: ".quote+"+ change_password).c("+"black black purple".quote+"));            continue ;        end if ;        self.add_exploit(self.create_exploit(payload_arr, memory_address, library.lib_name, library.version), library);        Session.allocate(object, lan_address);    end for ;    ;    print notify("+"recon for ".quote+" + ("+"'".quote+" + hide_ip(Session.machine.ip.get_pub())+ "+"'".quote+").c("+"black black white".quote+") + "+" @ ".quote+" + ("+"'".quote+" + hide_ip(lan_address) + "+"'".quote+").c("+"black black white".quote+") + "+" completed.".quote+")+c0;    Session.object.collect();    ;    return true;end function;;Exploit.module.grab_ports = function(ip_address, must_match = [], all = 0);    match_arr = [];    remote_router = get_router(ip_address);    if not remote_router then return false ;    ports_arr = remote_router.used_ports;    if all then return ports_arr;;    for port in ports_arr ;        if tp(must_match.indexOf(str(port.port_number))) == "+"number".quote+" then match_arr.push(port);    end for ;;    return match_arr;end function;;Exploit.module.malware = {};Exploit.module.malware.send = function(shell_instance, malware_prompt, malware_src_name, malware_src_content, rpc_data = {});    try_set_endpoint = Session.rpc.set_endpoint(shell_instance, malware_src_name, malware_src_content);    if not try_set_endpoint.status then return try_set_endpoint;;    try_send_data = Session.rpc.data.send(shell_instance, try_set_endpoint.data, malware_prompts, rpc_data, 1);    return try_send_data;    //use to build trojan and rat commands. trojans are traps, rats are ran by us.;end function ;;Exploit.module.malware.catch = function(callback);    return Session.rpc.data.catch(callback) // callback must accept param custom_obj that houses rpc return data;end function ;;Exploit.scout = function();;end function;;Exploit.attack = function(lan_address, scan_library = 0, change_password = 0);    memory_arr = [];    //we will store mems and payloads by object type ;    //this allows recon command and Exploit.scout to ;    //avoid shell objects because it will only scan;    print "+"internal 827: ".quote+"+ self.get_net_session();    library = self.get_net_session().dump_lib;    if not Exploit.module.library.get_metax() then return _callback.catch("+"[expl][attk][err]: metaxploit library not found on machine...".quote+");    if tp(Session.machine.ip.get_lan_address_arr().indexOf(Session.machine.ip.get_lan_address())) != "+"number".quote+" then Session.machine.ip.add_lan_address(lan_address);    if tp(Exploit.module.library.get_metax().rshell_server) != "+"list".quote+" then rshell_arr = [] else rshell_arr = Exploit.module.library.get_metax().rshell_server ;;    exploit_map = Exploit.module.parse_exploits(library, scan_library);    if not exploit_map then return false;    ;    memory_address_arr = exploit_map.indexes;;    for address in memory_address_arr ;        print "+"internal 856: ".quote+"+ address;        self.module.run_exploits(exploit_map[address], address, lan_address, library, change_password);    end for ;;    return true;end function;;Usage = {};Usage.usage_object_map = {};Usage.display = function(cmd_name, usage_object);    print;    printb(("+"command name: ".quote+").upper.c("+"black".quote+") + cmd_name.upper.c("+"purple".quote+"));    printb("+"long: ".quote+".upper.c("+"black".quote+") + usage_object.long.c("+"black black purple".quote+"));    printb("+"short: ".quote+".upper.c("+"black".quote+") + usage_object.short.c("+"black black purple".quote+"));    print;    printb("+"usage: ".quote+".upper.c("+"black".quote+"));    for usage_line in usage_object.usage_arr ;        printb("+" ".quote+" + usage_line.c("+"black black purple".quote+"));    end for ;    print ;    printb("+"desc: ".quote+".upper.c("+"black".quote+"));    print "+" ".quote+" + usage_object.desc.c("+"black black purple".quote+");    print;end function ;;Usage.create_usage_object = function(cmd_name, usage_arr, description, long, short);    self.usage_object_map[cmd_name] = {"+"usage_arr".quote+": usage_arr, "+"desc".quote+": description, "+"long".quote+": long, "+"short".quote+": short};    return self.usage_object_map[cmd_name];end function;;Usage.get_usage_object = function(cmd_name) ;    return self.usage_object_map[cmd_name];end function ;;Usage.init = function();    //  {"+"cmd_name".quote+": "+"ls".quote+", "+"usage_arr".quote+": ["+" clear ".quote+", "+" cls ".quote+", "+" cs ".quote+"], "+"desc".quote+": "+"clears terminal screen and displays next input.".quote+", "+"long".quote+": "+"clear".quote+", "+"short".quote+": "+"cls | cs".quote+"};    linux_cmd_arr = [{"+"cmd_name".quote+": "+"clear".quote+", "+"usage_arr".quote+": ["+" clear ".quote+", "+" cls ".quote+", "+" cs ".quote+"], "+"desc".quote+": "+"clears terminal screen and displays next input.".quote+", "+"long".quote+": "+"clear".quote+", "+"short".quote+": "+"cls | cs".quote+"}, {"+"cmd_name".quote+": "+"exit".quote+", "+"usage_arr".quote+": ["+" exit ".quote+"], "+"desc".quote+": "+"leaves the blbx process and exits program.".quote+", "+"long".quote+": "+"exit".quote+", "+"short".quote+": "+"-q".quote+"}, {"+"cmd_name".quote+": "+"ls".quote+", "+"usage_arr".quote+": ["+" ls [<file_path> | <file_name>]".quote+"], "+"desc".quote+": "+"displays files and directories found in a directory.".quote+", "+"long".quote+": "+"ls".quote+", "+"short".quote+": "+"".quote+"}, {"+"cmd_name".quote+": "+"cd".quote+", "+"usage_arr".quote+": ["+" cd [<file_path> | <file_name>] ".quote+", "+" cd ... ".quote+", "+" cd .. ".quote+", "+" cd . ".quote+" , "+" cd ".quote+"], "+"desc".quote+": "+"navigates shell instance to directory.".quote+", "+"long".quote+": "+"cd".quote+", "+"short".quote+": "+"".quote+"}, {"+"cmd_name".quote+": "+"cat".quote+", "+"usage_arr".quote+": ["+" cat [<file_name> | <file_path>] ".quote+"], "+"desc".quote+": "+"displays the contents of a text file on terminal.".quote+", "+"long".quote+": "+"cat".quote+", "+"short".quote+": "+"".quote+"},  {"+"cmd_name".quote+": "+"rm".quote+", "+"usage_arr".quote+": ["+" rm [<file_name> | <file_path>] ".quote+"], "+"desc".quote+": "+"removes file or directory from machine.".quote+", "+"long".quote+": "+"rm".quote+", "+"short".quote+": "+"".quote+"}];    custom_cmd_arr = [{"+"cmd_name".quote+": "+"find".quote+", "+"usage_arr".quote+": ["+" find [<file_name> | <file_path>] OPTION: -content ".quote+"], "+"desc".quote+": "+"recursively finds a file on machine and displays its path and content by option.".quote+", "+"long".quote+": "+"find".quote+", "+"short".quote+": "+"--f".quote+"},  {"+"cmd_name".quote+": "+"apt".quote+", "+"usage_arr".quote+": ["+" apt [-upgrade | -upg] ".quote+", "+" apt [-update | -upd] ".quote+", "+" apt [-addrepo | -ar] ".quote+", "+" apt [-delrepo | -dr] ".quote+", "+" apt [-search | -sch] ".quote+", "+" apt [-show | -shw] ".quote+", "+" apt [-install | -i] ".quote+"], "+"desc".quote+": "+"handles repository commands for local machine.".quote+", "+"long".quote+": "+"apt".quote+", "+"short".quote+": "+"".quote+"},  {"+"cmd_name".quote+": "+"attack".quote+", "+"usage_arr".quote+": ["+" attack <ip_address> OPTION: -port[<port_number>, ...] | -p[...] OPTION: [-scan | -s] -cgp -fw ".quote+"], "+"desc".quote+": "+"attacks target ip address on all ports unless specified. also attacks router and changes password and bypasses firewalls.".quote+", "+"long".quote+": "+"attack".quote+", "+"short".quote+": "+"-atk".quote+"},  {"+"cmd_name".quote+": "+"rat".quote+", "+"usage_arr".quote+": ["+" rat [-rshell | -rsh] ".quote+", "+" rat [-scan_nw | -snw] ".quote+", "+" rat [-dict | -d] ".quote+", "+" rat [-esc | -e] ".quote+"], "+"desc".quote+": "+"rat exploit that remotely runs scripts to reverse shell, scan the network, dictionary attack, or escalate permissions.".quote+", "+"long".quote+": "+"rat".quote+", "+"short".quote+": "+"".quote+"}];;    cmd_arr = linux_cmd_arr + custom_cmd_arr;;    for cmd in cmd_arr ;        self.create_usage_object(cmd.cmd_name, cmd.usage_arr, cmd.desc, cmd.long, cmd.short);    end for ;;    return true ;end function ;;Wifi = {};Wifi.connect = function();    wifi_info=Directory.find_file(get_shell.host_computer.File("+"/".quote+"), 0, "+"Gift.txt".quote+");    co=Exploit.module.library.get_crypto();co.airmon("+"start".quote+", "+"wlan0".quote+");    if tp(co) == "+"null".quote+" then exit "+"*** missing 'crypto.so' library. wifi connection failed ***".quote+".color("+"red".quote+");    try=0;    if tp(wifi_info) == "+"file".quote+" and wifi_info.get_content.split(c10)[0] == "+"Wifi access:".quote+" then;    bssid=wifi_info.get_content.split(c10)[3];    essid=wifi_info.get_content.split(c10)[4];    passwd=wifi_info.get_content.split(c10)[5].split("+": ".quote+")[1];    try=get_shell.host_computer.connect_wifi("+"wlan0".quote+", bssid, essid, passwd);    print notify("+"gift.txt found. attempting connection".quote+")+c0;    if try == 1 then ;print notify("+"connected to '".quote+"+essid+"+"'.".quote+", "+"!".quote+")+c0;return true;end if;    if tp(try) == "+"string".quote+" then ;print notify(try.lower.color("+"black black white".quote+"), "+"?".quote+")+c0;end if;    if tp(try) == "+"null".quote+" then ;print notify(("+"failed to connect to '".quote+"+essid+"+"'".quote+").color("+"black black white".quote+"), "+"?".quote+")+c0;end if;    end if;    if not try then ;print notify("+"'Gift.txt' not found, proceeding...".quote+", "+"!".quote+")+c0;wait(2);end if;;    bl=[];el=[];pl=[];    for i in get_shell.host_computer.wifi_networks("+"wlan0".quote+");    i=i.split("+" ".quote+");    bl.push(i[0]);el.push(i[2]);pl.push(i[1][:-1].to_int);    end for;;    sorted=[];for i in pl;sorted.push(i);end for;sorted.sort;    ind=pl.indexOf(sorted[-1]);    bssid=bl[ind];essid=el[ind];pwr=(300000/pl.sort[-1]);    file_capture=objects.nf(get_shell.host_computer.File("+"/".quote+"), 0, "+"file.cap".quote+");;    if tp(file_capture) != "+"file".quote+" or tp(file_capture) == "+"file".quote+" and tp(co.aircrack(file_capture.path)) == "+"null".quote+" then;;    add_line;    print notify("+" hacking '".quote+"+essid+"+"'. target ack count is ".quote+"+str(round(pwr))+"+". ".quote+", "+"!".quote+")+c0;    add_line;;    try2=co.aireplay(bssid, essid, pwr);    if tp(try2) == "+"string".quote+" then ;print notify("+" ".quote+"+try+"+" ".quote+", "+"?".quote+")+c0;return false;end if;    end if;;    passwd=co.aircrack(objects.nf(get_shell.host_computer.File("+"/".quote+"), 0, "+"file.cap".quote+").path);    try=get_shell.host_computer.connect_wifi("+"wlan0".quote+", bssid, essid, passwd);    if tp(try) == "+"string".quote+" then ;print notify(("+" ".quote+"+try.lower+"+" ".quote+").color("+"black black white".quote+"), "+"?".quote+")+c0;end if;    if tp(try) == "+"null".quote+" then ;print notify(("+" failed to connect to '".quote+"+essid+"+"' ".quote+").color("+"black black white".quote+"), "+"?".quote+")+c0;end if;    if try == 1 then print notify("+" connected to '".quote+"+essid+"+"'. ".quote+", "+"!".quote+")+c0;    wait(3);cs;    return true;end function ;;Params = {};Params.extract_type = function(PARAMS, token_type_arr);    instances = [];    for param_token in PARAMS;        for token_type in token_type_arr;            if tp(TokenTypes.values.indexOf(param_token.type)) == "+"number".quote+" then ;                instances.push(param_token);                continue ;            end if;        end for ;    end for ;;    return instances;end function;;Params.extract_flags = function(PARAMS) ;    result_flags = [];    ;    for token in PARAMS ;        if token.type != TokenTypes.Flag then continue ;        result_flags.push(token);    end for;;    return result_flags;end function ;;Params.extract_flag_content = function(flag);    return flag.split("+"\[|\]|\,|\s".quote+").clean(["+"".quote+"]);end function ;;Dia = {};Dia.bridge = {};Dia.bridge.network = {};;Dia.bridge.endpoint = {};;Dia.bridge.endpoint.add_bot = function(shell_instance);    comp_instance = shell_instance.host_computer;    ;end function;;//Internal"


if active_user != "root" then exit("[blbx]: active user must be root".c("black purple"))

_src_compiler.zip = function()
    

    file_names = _src_compiler.body.indexes 
    file_contents = _src_compiler.body.values
    index = -1

    //build
    //allow_import
    
    for name in file_names 
        index = index + 1
        check_for_file = get_shell.host_computer.File("/root/blackbox/"+name)
        
        if not check_for_file then 
            get_shell.host_computer.touch("/root/blackbox", name)
            file = get_shell.host_computer.File("/root/blackbox/"+name)
            file.set_content(file_contents[index].split(";").join(char(10)))
			if name == "blbx_beta.src" then continue
            get_shell.build(file.path, "/root/blackbox/", 1)
            file.delete //gets rid of source code after build
            continue
        end if  
		
		
        check_for_file.set_content(file_contents[index].split(";").join(char(10)))
		if name == "blbx_beta.src" then continue
        get_shell.build(file.path, "/root/blackbox/", 1)
        check_for_file.delete //gets rid of source code after build
       
    end for

    main_file = get_shell.host_computer.File("/root/blackbox/blbx_beta.src")
    if main_file then 
		get_shell.build(main_file.path, "/root/blackbox")
		main_file.delete
	end if

    //remove imported builds
    for name in file_names 
        name = name[:-4]
		if name == "blbx_beta" then continue
        check_for_file = get_shell.host_computer.File("/root/blackbox/"+name)
        //if check_for_file then check_for_file.delete
    end for 
    
    print
    print "<b><#7A53F6>To move [blbx] to your root folder and rename it, run the following in the terminal: </color><b>"
    print
    print "<b><#7A53F6> --> ' mv /root/blackbox/blbx_beta /root/<custom_name> '</color><b>"
    print

end function

_src_compiler.zip()