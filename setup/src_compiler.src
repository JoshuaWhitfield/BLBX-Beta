string.quote = function()
    return """" + self + """"
end function 

_src_compiler = {}

_src_compiler.body = {}

_src_compiler.body["blbx_beta.src"] = "import"+"_code("+"/root/blackbox/generic".quote+");import"+"_code("+"/root/blackbox/callback".quote+");import"+"_code("+"/root/blackbox/json".quote+");import"+"_code("+"/root/blackbox/markup".quote+");import"+"_code("+"/root/blackbox/lexer".quote+");import"+"_code("+"/root/blackbox/parser".quote+");import"+"_code("+"/root/blackbox/prompt".quote+");import"+"_code("+"/root/blackbox/internal".quote+");import"+"_code("+"/root/blackbox/linux".quote+");Usage.init();database_name_arr = ["+"exploit".quote+", "+"macro".quote+", "+"dictionary".quote+"];for database_name in database_name_arr;    if not Session.db.has(database_name) then Session.db.create(database_name);end for ;while Session.process.is_running();    if not params.len then input = user_input(Prompt.get_message()) else input = params.join("+" ".quote+") ;    command_result = Prompt.prepare_input(input);end while"

_src_compiler.body["linux.src"] = "command = {};;command.cls = function(PARAMS);    clear_screen;    return _callback.catch("+"".quote+", 1);end function;command.cs = @command.cls;command.clear = @command.cls;;command.exit = function(PARAMS);    printb("+"[blbx][system]: exiting blbx suite...".quote+".c("+"black black purple".quote+"));    return _callback.catch("+"".quote+", 1);end function;command["+"-q".quote+"] = @command.exit;;command.ls = function(PARAMS) ;    store = {"+"root_file".quote+": false, "+"target_file".quote+":false};    init = function();;        store.root_file = fif(Session.process.is_connected(), Session.borrow("+"file".quote+", Session.machine.ip.get_lan()), get_shell.host_computer.File("+"/".quote+"));        if not tp(store.root_file) == "+"file".quote+" then return _callback.catch("+"[blbx][cd][err]: remote session has no file objects...".quote+");        current_path_file = Directory.find_file(store.root_file, Prompt.get_current_path());        ;        if not PARAMS.len then;            return _callback.catch(Directory.find_file(store.root_file, Prompt.get_current_path()), 1);        end if ;;        if PARAMS.len != 1 then return _callback.catch("+"[blbx][ls][usage]: ls [<file_path> | <file_name>]".quote+");        ;        param_token = PARAMS[0];        if tp([TokenTypes.String, TokenTypes.Argument].indexOf(param_token.type)) != "+"number".quote+" then return _callback.catch("+"[blbx][ls][err]: second argument must be a string or argument...".quote+")   ;    ;        valid_file = Directory.validate_file(store.root_file, "+"ls".quote+", PARAMS, 1);        return valid_file;    end function;    error_handling = init();    if not error_handling.status then return error_handling;;    store.target_file = error_handling.data;    children = store.target_file.get_folders + store.target_file.get_files;    result   = c("+"b".quote+") + "+"PERMS GROUP OWNER SIZE NAME".quote+";    folders  = [];    binaries = [];    texts    = [];    path_arr = [];;    for file in children ;        path_arr.push(file.path);        if not file.is_folder and not file.is_binary then texts.push((file.permissions + "+" ".quote+" + file.group + "+" ".quote+" + file.owner + "+" ".quote+" + file.size + "+" ".quote+" + file.name).c("+"black".quote+"));        if file.is_folder then folders.push((file.permissions + "+" ".quote+" + file.group + "+" ".quote+" + file.owner + "+" ".quote+" + file.size + "+" ".quote+").c("+"purple".quote+") + b + (file.name.c("+"purple".quote+")));        if file.is_binary and not file.is_folder then binaries.push((file.permissions+"+" ".quote+"+file.group+"+" ".quote+"+file.owner+"+" ".quote+"+file.size+"+" ".quote+").color("+"purple".quote+")+b+(file.name.color("+"white".quote+")));    end for ;;    print;    ([result] + folders + binaries + texts).format_columns;    print ;    ;    return _callback.catch(path_arr, 1);end function;;command.cd = function(PARAMS);    store = {"+"root_file".quote+": false, "+"target_file".quote+":false};    init = function();        store.root_file = fif(Session.process.is_connected(), Session.borrow("+"file".quote+", Session.machine.ip.get_lan()), get_shell.host_computer.File("+"/".quote+"));        if not tp(store.root_file) == "+"file".quote+" then return _callback.catch("+"[blbx][cd][err]: remote session has no file objects...".quote+");        ;        current_path_file = Directory.find_file(store.root_file, Prompt.get_current_path());        ;        ;        if not PARAMS.len then;            if Prompt.get_current_path() == "+"/".quote+" then return _callback.catch(Directory.find_file(store.root_file, Prompt.get_current_path()), 1);            return _callback.catch(Directory.find_file(store.root_file, Prompt.get_current_path()).parent, 1);        end if ;        ;        if PARAMS.len != 1 then return _callback.catch("+"[blbx][cd][usage]: cd [<file_path> | <file_name>]".quote+");        ;        param_token = PARAMS[0];        if tp([TokenTypes.String, TokenTypes.Argument, TokenTypes.Float].indexOf(param_token.type)) != "+"number".quote+" then return _callback.catch("+"[blbx][cd][err]: second argument must be a string or argument...".quote+")   ;        ;        if param_token.type == TokenTypes.Float and (param_token.value.is_match("+"\.+".quote+")) then ;            if param_token.value == "+".".quote+" then;                print;                return _callback.catch(current_path_file, 1);            end if ;;            if param_token.value == "+"..".quote+" then ;                print;                return _callback.catch(current_path_file.parent, 1);            end if ;;            if param_token.value == "+"...".quote+" then;                print;                return _callback.catch(store.root_file, 1);            end if ;        end if ;        ;        valid_file = Directory.validate_file(store.root_file, "+"cd".quote+", PARAMS, 1);        return valid_file;    end function;    print ;    error_handling = init();    if not error_handling.status then return error_handling;    ;    Prompt.set_path(error_handling.data.path);    ;    return _callback.catch(error_handling.data.path, 1);end function;;command.cat = function(PARAMS); store = {"+"root_file".quote+": false, "+"target_file".quote+":false};    init = function();        store.root_file = fif(Session.process.is_connected(), Session.borrow("+"file".quote+", Session.machine.ip.get_lan()), get_shell.host_computer.File("+"/".quote+"));        if not tp(store.root_file) == "+"file".quote+" then return _callback.catch("+"[blbx][cd][err]: remote session has no file objects...".quote+");;        if not PARAMS.len then ;            store.target_file = Directory.find_file(store.root_file, Prompt.get_current_path()).parent;            return _callback.catch("+"".quote+", 1);        end if ;;        param_token = PARAMS[0];        if tp([TokenTypes.String, TokenTypes.Argument].indexOf(param_token.type)) != "+"number".quote+" then return _callback.catch("+"[blbx][cd][err]: second argument must be a string or argument...".quote+")   ;;        valid_file = Directory.validate_file(store.root_file, "+"cat".quote+", PARAMS);        if not valid_file.status then return valid_file;;        if not valid_file.data.has_permission("+"r".quote+") then return _callback.catch("+"[blbx][cat][err]: read file permissions denied...".quote+");        if valid_file.data.is_binary then return _callback.catch("+"[blbx][cat][err]: file '".quote+" + valid_file.data.path + "+"' must not be a binary...".quote+");        if valid_file.data.is_folder then return _callback.catch("+"[blbx][cat][err]: file '".quote+" + valid_file.data.path + "+"' must not be a folder...".quote+");;        return valid_file;    end function;    error_handling = init();    if not error_handling.status then return error_handling;    store.target_file = error_handling.data;;    print ;    print store.target_file.get_content.c("+"black black purple".quote+");    print ;;    return _callback.catch("+"".quote+", 1);end function;;command.rm = function(PARAMS);    store = {"+"root_file".quote+": false, "+"target_file".quote+": false};    init = function();        store.root_file = fif(Session.process.is_connected(), Session.borrow("+"file".quote+", Session.machine.ip.get_lan()), get_shell.host_computer.File("+"/".quote+"));        if not tp(store.root_file) == "+"file".quote+" then return _callback.catch("+"[blbx][cd][err]: remote session has no file objects...".quote+");        current_path_file = Directory.find_file(store.root_file, Prompt.get_current_path());;        if not PARAMS.len then;            return _callback.catch(Directory.find_file(store.root_file, Prompt.get_current_path()), 1);        end if ;;        if PARAMS.len != 1 then return _callback.catch("+"[blbx][ls][usage]: ls [<file_path> | <file_name>]".quote+");        ;        param_token = PARAMS[0];        if tp([TokenTypes.String, TokenTypes.Argument].indexOf(param_token.type)) != "+"number".quote+" then return _callback.catch("+"[blbx][ls][err]: second argument must be a string or argument...".quote+")   ;    ;        valid_file = Directory.validate_file(store.root_file, "+"ls".quote+", PARAMS);        return valid_file;    end function;    error_handling = init();    if not error_handling.status then return error_handling;;    error_handling.data.delete ;;    return _callback.catch("+"".quote+", 1);end function ;;command.find = function(PARAMS);    store = {"+"root_file".quote+": false, "+"target_file".quote+": false, "+"content".quote+": false, "+"name".quote+": false, "+"path".quote+": true};    store.root_file = fif(Session.process.is_connected(), Session.borrow("+"file".quote+", Session.machine.ip.get_lan()), get_shell.host_computer.File("+"/".quote+"));    if not tp(store.root_file) == "+"file".quote+" then return _callback.catch("+"[blbx][cd][err]: remote session has no file objects...".quote+");    current_path_file = Directory.find_file(store.root_file, Prompt.get_current_path());    ;    init = function();        if not PARAMS.len then;            Usage.display("+"find".quote+", Usage.get_usage_object("+"find".quote+"));            return _callback.catch("+"".quote+", 1);        end if ;        ;        param_token = PARAMS[0];        if tp([TokenTypes.String, TokenTypes.Argument].indexOf(param_token.type)) != "+"number".quote+" then return _callback.catch("+"[blbx][find][err]: second argument must be a string or argument...".quote+")   ;    ;        for token in PARAMS[0];            if token.type == TokenTypes.Flag then ;                token_value = token.value.values.clean(["+"-".quote+"]).join("+"".quote+");                if tp(["+"content".quote+", "+"c".quote+"].indexOf(token_value.lower)) == "+"number".quote+" then store.content = true;            end if;        end for ;;        valid_file = Directory.validate_file(store.root_file, "+"ls".quote+", PARAMS);        return valid_file;    end function;    error_handling = init();    if not error_handling.status then return error_handling;;    ;;    return ;end function ;command["+"--f".quote+"] = @command.find;;command.apt = function(PARAMS);    config = {"+"apt_client".quote+": false};    run = {"+"upgrade".quote+": 0, "+"update".quote+": 0, "+"addrepo".quote+": 0, "+"delrepo".quote+": 0, "+"search".quote+": 0, "+"show".quote+": 0, "+"install".quote+": 0};    init = function();        config.apt_client = Exploit.module.get_local_lib("+"aptclient.so".quote+");        if not (config.apt_client) == "+"aptclientLib".quote+" then return _callback.catch("+"[blbx][apt][err]: 'aptclient.so' library not found on machine...".quote+");        ;        if PARAMS.len < 1 then ;            Usage.display("+"apt".quote+", Usage.get_usage_object("+"apt".quote+"));            return _callback.catch("+"".quote+", 1);        end if ;;        flags_arr = Params.extract_type(PARAMS, [TokenTypes.Flag]);;        for flag_token in flags_arr ;            if tp(["+"update".quote+", "+"upd".quote+"].indexOf(flag_token.value.values.clean(["+"-".quote+"]).join("+"".quote+"))) == "+"number".quote+" then run.update = 1;            if tp(["+"upgrade".quote+", "+"upg".quote+"].indexOf(flag_token.value.values.clean(["+"-".quote+"]).join("+"".quote+"))) == "+"number".quote+" then run.upgrade = 1;            if tp(["+"addrepo".quote+", "+"adr".quote+"].indexOf(flag_token.value.values.clean(["+"-".quote+"]).join("+"".quote+"))) == "+"number".quote+" then run.addrepo = 1;            if tp(["+"delrpo".quote+", "+"dlr".quote+"].indexOf(flag_token.value.values.clean(["+"-".quote+"]).join("+"".quote+"))) == "+"number".quote+" then run.delrepo = 1;            if tp(["+"search".quote+", "+"sch".quote+"].indexOf(flag_token.value.values.clean(["+"-".quote+"]).join("+"".quote+"))) == "+"number".quote+" then run.search = 1;            if tp(["+"show".quote+", "+"shw".quote+"].indexOf(flag_token.value.values.clean(["+"-".quote+"]).join("+"".quote+"))) == "+"number".quote+" then run.show = 1;            if tp(["+"install".quote+", "+"i".quote+"].indexOf(flag_token.value.values.clean(["+"-".quote+"]).join("+"".quote+"))) == "+"number".quote+" then run.install = 1;        end for ;;        return _callback.catch("+"".quote+", 1);    end function ;    error_handling = init();    if not error_handling.status then return error_handling;;    print tp(config.apt_client);;    handle = {};    handle["+"upgrade".quote+"] = function();        print ;        printb("+"*** installing library metaxploit.so ***".quote+".c("+"purple".quote+"));        config.apt_client.install("+"metaxploit.so".quote+");        print;        printb("+"*** installing library crypto.so ***".quote+".c("+"purple".quote+"));        config.apt_client.install("+"crypto.so".quote+");        print;;        return _callback.catch("+"".quote+", 1) ;    end function ;;    handle["+"update".quote+"] = function(PARAMS);        printb("+"updating package lists...".quote+".c("+"black".quote+"));        output = config.apt_client.update ;        if tp(output) == "+"string".quote+" and output.len > 0 then return _callback.catch("+"[blbx][apt][err]: ".quote+" + output);        success ;;        return _callback.catch("+"".quote+", 1);    end function;;    handle["+"addrepo".quote+"] = function(PARAMS);        ip_address = Params.extract_type(PARAMS, [TokenTypes.Float])[0];        if not ip_address then return _callback.catch("+"[blbx][apt][err]: must include ip address argument...".quote+");        if not is_valid_ip(ip_address) then return _callback.catch("+"[blbx][apt][err]: ip address '".quote+" + ip_address + "+"' is invalid...".quote+");;        output = config.apt_client.add_repo(ip_address);        if tp(output) == "+"string".quote+" and output.len > 0 then return _callback.catch("+"[blbx][apt][err]: ".quote+" + output);        ;        config.apt_client.update;        print ;        return _callback.catch("+"".quote+", 1);    end function  ;;    handle["+"delrepo".quote+"] = function(PARAMS);        ip_address = Params.extract_type(PARAMS, [TokenTypes.Float])[0];        if not ip_address then return _callback.catch("+"[blbx][apt][err]: must include ip address argument...".quote+");        if not is_valid_ip(ip_address) then return _callback.catch("+"[blbx][apt][err]: ip address '".quote+" + ip_address + "+"' is invalid...".quote+");;        output = config.apt_client.del_repo(ip_address);        if tp(output) == "+"string".quote+" and output.len > 0 then return _callback.catch("+"[blbx][apt][err]: ".quote+" + output);        ;        config.apt_client.update;        print ;        return _callback.catch("+"".quote+", 1);    end function;;    handle["+"search".quote+"] = function(PARAMS);        program_name = Params.extract_type(PARAMS, [TokenTypes.String, TokenTypes.Argument])[0];        if not program_name then return _callback.catch("+"[blbx][apt][err]: must include program name argument...".quote+");;        output = config.apt_client.search(program_name);        new_output = output.split("+"<b>|</b>".quote+").clean(["+"".quote+"]);;        for line in new_output ;            line = line.replace(c10, "+"".quote+");            if line.split("+" ".quote+").len == 1 then ;                printb(line.c("+"purple".quote+") + "+": ".quote+".c("+"black".quote+"));                continue ;            end if ;            printb(short_dialogue(line));            print;        end for ;    end function ;;    handle["+"show".quote+"] = function(PARAMS);        program_name = Params.extract_type(PARAMS, [TokenTypes.String, TokenTypes.Argument])[0];        if not program_name then return _callback.catch("+"[blbx][apt][err]: must include program name argument...".quote+");;        output = config.apt_client.search(program_name);        new_output = output.split("+"<b>|</b>".quote+").clean(["+"".quote+"]);;        for line in new_output;            line = line.replace(c10, "+"".quote+");            while line[0] == "+" ".quote+";                line = line[1:];            end while ;            if line.split("+" ".quote+").len == 1 then ;                printb(line.c("+"purple".quote+") + "+": ".quote+".c("+"black".quote+"));                continue ;            end if ;            printb(shorten_dialogue(line));            print;        end for ;;        return _callback.catch("+"".quote+", 1);    end function ;;    handle["+"install".quote+"] = function(PARAMS);        program_name = Params.extract_type(PARAMS, [TokenTypes.String, TokenTypes.Argument])[0];        if not program_name then return _callback.catch("+"[blbx][apt][err]: must include program name argument...".quote+");;        output = config.apt_client.install(program_name);        if tp(output) == "+"string".quote+" then return _callback.catch("+"[blbx][apt][err]: ".quote+" + output);;        printb("+"downloaded: ".quote+".c("+"black".quote+") + program_name.c("+"purple".quote+"));        print ;        ;        return _callback.catch("+"".quote+", 1);    end function ;;    for func_name in handle.indexes ;        if not run[func_name] then continue ;        proxy = handle[func_name];;        return proxy();    end for;;    return _callback.catch("+"".quote+", 1);end function ;;command.help = function(PARAMS);    ;    message = "+"there are a list of people who have gang stalked me for\nthe past six plus years. they have stopped at nothing to make my life a living hell. they have driven me to suicide four times. they have abused me physically, verbally, and psychologically since childhood.\n\nI need your help.\n\nThe day for revenge is here.\nI am sueing these people for group defamation. \nunder this offense, every occurance of obtaining information \nabout someone to share amongst others for the \npurpose of defaming the individual named in the \ninformation is fined anywhere from $500 to $10,000 \ndepending on the duration of the offense. \nin my case six plus years. The more offenders you \ndiscover, (anyone who knew this happened and said\n nothing, and anyone who offended), the more damages I am \nentitled to. the more information you can find about these offenders, \nthe more money you stand to make. Keep the information you find relevant to \nthe instructions and this case. You will earn a small \npercentage (no less than 1%) of the winnings which is in the \nhigh millions. you will get the docusign agreement \nin an anonymous email inbox as well as money in an \naccount created by me by the end of the proceedings. \nthe information on;".quote+";;    print message;;    return _callback.catch("+"".quote+", 1);end function ;;command.show = function(PARAMS);    init = function();        return _callback.catch("+"".quote+", 1);    end function ;    error_handling = init();    if not error_handling.status then return error_handling;    if not (Session.object.shell.list + Session.object.computer.list + Session.object.file.list).len then return _callback.catch("+"".quote+", 1);    ;    Exploit.device.show_tree();;    return _callback.catch("+"".quote+", 1);end function ;;command.nmap = function(PARAMS, data = 0);    config = {"+"rhost".quote+": 0};    init = function();        if not PARAMS.len then ;            Usage.display("+"nmap".quote+", Usage.get_usage_object("+"nmap".quote+"));            return _callback.catch("+"".quote+", 0);        end if ;;        ip_address = Params.extract_type(PARAMS , [TokenTypes.Float, TokenTypes.String])[0];        if not ip_address then return _callback.catch("+"[blbx][nmap][err]: must include an ip address argument...".quote+");        ip_address = ip_address.value;        if not is_valid_ip(ip_address) then _callback.catch("+"[blbx][nmap][err]: invalid ip address '".quote+" + ip_address + "+"'...".quote+");        config.rhost = ip_address;;        return _callback.catch("+"".quote+", 1);    end function;;    error_handling = init();    if not error_handling.status then return error_handling;;    remote_router = get_router(config.rhost);    if not remote_router then return _callback.catch("+"[blbx][nmap][err]: ip address '".quote+" + config.rhost + "+"' is not reachable...".quote+");    remote_ports = remote_router.used_ports;    printb(("+"scanning ports at: ".quote+").c("+"black black purple".quote+") + (hide_ip(config.rhost) + "+" ".quote+").c("+"purple".quote+") + current_date.c("+"black black purple".quote+")+ c0) ;    if not remote_ports.len then;        printb("+"interrupter. no open ports...".quote+".c("+"black".quote+") + c0);        return _callback("+"".quote+", 0);    end if;    info = ["+"PORT STATE SERVICE VERSION LAN".quote+".c("+"black".quote+")];    s = "+" ".quote+";;    for port in remote_ports;        service_info = remote_router.port_info(port);        lan_address = port.get_lan_ip ;        if port.is_closed then status = "+"closed".quote+".c("+"black".quote+") else status = "+"open".quote+".c("+"purple".quote+");        info.push((str(port.port_number).c("+"purple".quote+") + s + status + s + service_info.c("+"black".quote+") + s + lan_address.c("+"black black purple".quote+")));    end for ;;    print;    info.format_columns;    print ;;    return _callback.catch("+"".quote+", 1) ;end function ;;command.sweep = function(PARAMS);    config = {"+"amount".quote+": 1, "+"ports".quote+": [], "+"rhost".quote+": 0};    init = function();        // sweep <target amount> OPTION: -port[<port_number>, ...];        if not PARAMS.len then ;            Usage.display("+"sweep".quote+", Usage.get_usage_object("+"sweep".quote+"));            return _callback.catch("+"".quote+", 0);        end if ;;        target_amount = Params.extract_type(PARAMS, [TokenTypes.Float])[0];        if not target_amount then target_amount = 1 else target_amount = target_amount.value;;        target_ports = Params.extract_flags(PARAMS);        if target_ports.len then ;            for flag in target_ports;                flag = flag + "+" ".quote+";                if flag.is_match("+"\[*\]".quote+") then ;                    flag = slice(flag, flag.values.indexOf("+"[".quote+"), flag.values.indexOf("+"]".quote+") + 1);                    target_ports = Params.extract_flag_content(flag);                end if;            end for;        end if;        if not target_ports then target_ports = [];;        config.amount = target_amount ;        config.ports = target_ports;;        return _callback.catch("+"".quote+", 1);    end function;    error_handling = init();    if not error_handling.status then return error_handling;    ;    count = 0;    matching_ip_address_arr = [];    ;    while count < config.amount.to_int;        config.rhost = Session.machine.ip.random_ip();        target_ports = Exploit.module.grab_ports(config.rhost, config.ports, fif(config.ports.len, 0, 1));;        if not target_ports or not target_ports.len then continue ;;        found = [] ;        for port in target_ports ;            for check_port in config.ports ;                if check_port.to_int == port.port_number then found.push(port);            end for ;        end for ;        ;        if not found.len == config.ports.len then continue ;        ;        matching_ip_address_arr.push(config.rhost);        Prompt.prepare_input(("+"nmap ".quote+" + config.rhost));        count = count + 1;    end while ;;;;    return _callback.catch(matching_ip_address_arr, 1);end function;command.sw = @command.sweep;;command.attack = function(PARAMS, data = 0) //attack ip_address port_number -scan -cgp -fw;    config = {"+"rhost".quote+": "+"".quote+", "+"lan_address".quote+": "+"".quote+", "+"scan".quote+": 0, "+"change_password".quote+": 0, "+"fire_wall".quote+": 0, "+"ports".quote+": [], "+"attack_router".quote+": 0, "+"third_arg".quote+": "+"1234".quote+"};    init = function();        if not PARAMS.len then;            Usage.display("+"attack".quote+", Usage.get_usage_object("+"attack".quote+"));            return _callback.catch("+"".quote+", 1);        end if ;;        config.rhost = Params.extract_type(PARAMS[:1], [TokenTypes.Float, TokenTypes.String]);        if not config.rhost then return _callback.catch("+"[blbx][attack][err]: must enter a valid ip address...".quote+");        config.rhost = config.rhost[0].value;        if not is_valid_ip(config.rhost) then return _callback.catch("+"[blbx][attack][err]: invalid public ip address...".quote+");        ;        flags_arr = Params.extract_flags(PARAMS[1:]);;        if flags_arr.len then ;            for flag in flags_arr;                flag = flag.value;                if tp(["+"scan".quote+", "+"s".quote+"].indexOf(flag.values.clean(["+"-".quote+"]).join("+"".quote+").lower)) == "+"number".quote+" then config.scan = 1;                if tp(["+"cgp".quote+", "+"c".quote+"].indexOf(flag.values.clean(["+"-".quote+"]).join("+"".quote+").lower)) == "+"number".quote+" then config.change_password = 1;                if tp(["+"fw".quote+", "+"f".quote+"].indexOf(flag.values.clean(["+"-".quote+"]).join("+"".quote+").lower)) == "+"number".quote+" then config.fire_wall = 1;                if tp(["+"router".quote+", "+"r".quote+"].indexOf(flag.values.clean(["+"-".quote+"]).join("+"".quote+").lower)) == "+"number".quote+" then ;                    Exploit.set_net_session(Exploit.module.get_local_lib("+"metaxploit.so".quote+"));                    Exploit.get_net_session().net_use(config.rhost);                    config.attack_router = 1;                end if ;                flag = flag + "+" ".quote+";                if flag.is_match("+"\[*\]".quote+") then ;                    print "+"linux 503: ".quote+"+ slice(flag.values.clean("+"-".quote+"), 0, flag.values.clean("+"-".quote+").indexOf("+"[".quote+")).join("+"".quote+");                    print "+"linux 504: ".quote+"+ tp(["+"port".quote+", "+"p".quote+"].indexOf(slice(flag.values.clean("+"-".quote+"), 0, flag.values.clean("+"-".quote+").indexOf("+"[".quote+")).join("+"".quote+"))) == "+"number".quote+";                    ;                    if tp(["+"port".quote+", "+"p".quote+"].indexOf(slice(flag.values.clean("+"-".quote+"), 0, flag.values.clean("+"-".quote+").indexOf("+"[".quote+")).join("+"".quote+"))) == "+"number".quote+" then ;                        flag = slice(flag, flag.values.indexOf("+"[".quote+"), flag.values.indexOf("+"]".quote+") + 1);                        config.ports = Params.extract_flag_content(flag);                    end if;                    if tp(["+"bounce".quote+", "+"b".quote+"].indexOf(slice(flag.values.clean("+"-".quote+"), 0, flag.values.clean("+"-".quote+").indexOf("+"[".quote+")).join("+"".quote+"))) == "+"number".quote+" then ;                        if flag.is_match("+"\[*\]".quote+") then config.third_arg = flag.values.clean(["+"-".quote+"]).join("+"".quote+").lower.split("+"\[|\,|\s|\]".quote+")[1:][0];                        print "+"linux 498: ".quote+"+ flag.is_match("+"\[*\]".quote+");                        print"+"linux 499: ".quote+"+ config.third_arg;                    end if;                end if;            end for;        end if;;        return _callback.catch("+"".quote+", 1);    end function;;    error_handling = init();    if not error_handling.status then return error_handling;;    handle_bool_flags = function();        return fif((config.change_password), 1, fif((config.fire_wall), 1, 0));    end function;;    if config.attack_router then ;        Session.machine.ip.add_pub_address(config.rhost);        Exploit.set_scan_mode(config.scan);        Exploit.set_net_session(Exploit.module.get_local_lib("+"metaxploit.so".quote+").net_use(config.rhost));        config.lan_address = get_router(config.rhost).local_ip;        ;        attack_result = Exploit.attack(fif((config.third_arg == "+"1234".quote+"), config.lan_address, config.third_arg), handle_bool_flags(), config.third_arg);        if not attack_result.status then ;            print            ;            printb(attack_result.data.c("+"black black purple".quote+"));            print;            return _callback.catch("+"".quote+", 0);        end if ;;        if success then Prompt.prepare_input("+"show".quote+");;        return _callback.catch("+"".quote+", 1);    end if ;;    attack_ports = Exploit.module.grab_ports(config.rhost, config.ports, fif(config.ports.len, 0, 1));    if not attack_ports then return _callback.catch("+"[blbx][attack][err]: ip address '".quote+"+config.rhost+"+"' is not reachable...".quote+");;    success = false;;    for port in attack_ports;        if port.is_closed then continue ;        if not Exploit.module.get_local_lib("+"metaxploit.so".quote+") then return _callback.catch("+"[blbx][attack][err]: 'metaxploit.so' library not found on local machine... ".quote+");        Exploit.set_net_session(Exploit.module.get_local_lib("+"metaxploit.so".quote+").net_use(config.rhost, port.port_number));        if not tp(Exploit.get_net_session()) == "+"NetSession".quote+" then ;            printb("+"[blbx][attack][warning]: net-session failed to start...".quote+".c("+"black black purple".quote+"));            continue;        end if ;        config.lan_address = port.get_lan_ip ;        ;;;        Session.machine.ip.add_pub_address(config.rhost);        Exploit.set_scan_mode(config.scan);        attack_result = Exploit.attack(config.lan_address, handle_bool_flags());        ;        if not attack_result.status then ;            print            ;            printb(attack_result.data.c("+"black black purple".quote+"));            print;            continue;        end if ;;        success = true;    end for ;;    if success then Prompt.prepare_input("+"show".quote+");;    return _callback.catch("+"".quote+", 1);end function ;command["+"atk".quote+"] = @command.attack;;command.connect = function(PARAMS);    config = {"+"lan_address".quote+": 0, "+"as_user".quote+": 0};    init = function();        if not PARAMS.len then ;            Usage.display("+"connect".quote+", Usage.get_usage_object("+"connect".quote+"));            return _callback.catch("+"".quote+", 0);        end if ;;        lan_address = Params.extract_type(PARAMS, [TokenTypes.Float]);        username = Params.extract_type(PARAMS, [TokenTypes.String, TokenTypes.Argument]);        if not lan_address then return _callback.catch("+"[blbx][connect][err]: must include a lan address argument...".quote+");        lan_address = lan_address[0];        if not is_lan_ip(lan_address.value) then return _callback.catch("+"[blbx][connect][err]: invalid lan address '".quote+" + lan_address.value + "+"'...".quote+");        if not Exploit.device.has(lan_address.value) then return _callback.catch("+"[blbx][connect][err]: device map does not contain lan address '".quote+" + lan_address.value + "+"'...".quote+");        config.lan_address = lan_address.value;;        username_arr = Exploit.device.user_map[config.lan_address];;        if username then ;            username = username[0].value;            found_user = false;            for user in username_arr ;                if user.lower.search(username) then ;                    found_user = user;                    break ;                end if ;            end for;            if not found_user then return _callback.catch("+"[blbx][connect][err]: username not found in device '".quote+" + config.lan_address + "+"'...".quote+");            config.as_user = found_user;        else ;            if tp(username_arr.indexOf("+"root".quote+")) == "+"number".quote+" then config.as_user = "+"root".quote+";            if username_arr.len and (tp(username_arr.indexOf("+"root".quote+")) != "+"number".quote+" and tp(username_arr.indexOf("+"guest".quote+")) != "+"number".quote+") then config.as_user = username_arr[0];            if tp(username_arr.indexOf("+"guest".quote+")) == "+"number".quote+" then config.username = "+"guest".quote+";        end if;        ;        if not config.as_user then return _callback.catch("+"[blbx][connect][err]: username not found in device '".quote+" + config.lan_address + "+"'...".quote+");;        return _callback.catch("+"".quote+", 1);    end function;    error_handling = init();    if not error_handling.status then return error_handling;;    Exploit.device.set_current(Exploit.device.get(config.lan_address));    Session.machine.user.set_name(config.as_user);    Prompt.set_username(config.as_user);    Session.machine.ip.set_lan(config.lan_address);    Prompt.set_ip_address(hide_ip(Session.machine.ip.get_pub()));    Session.process.set_connected(true);;    success;;    return _callback.catch("+"".quote+", 1);end function ;command.c = @command.connect;;command.disconnect = function(PARAMS);    config = {"+"lan_address".quote+": 0};    init = function();        flags_arr = Params.extract_flags(PARAMS);;        for flag_token in flags_arr ;            if tp(["+"help".quote+", "+"h".quote+"].indexOf(flag.values.clean(["+"-".quote+"]).join("+"".quote+").lower)) == "+"number".quote+" then;                Usage.display("+"disconnect".quote+", Usage.get_usage_object("+"disconnect".quote+"));                return _callback.catch("+"".quote+", 0);            end if ;        end for ;;        return _callback.catch("+"".quote+", 1);    end function;    error_handling = init();    if not error_handling.status then return error_handling;;    Session.machine.user.wipe();    Session.machine.user.set_name("+"blbx".quote+");    Prompt.set_username("+"blbx".quote+");    Session.machine.ip.set_lan("+"".quote+");    Prompt.set_ip_address("+"local".quote+");    Session.process.set_connected(false);;    success ;;    return _callback.catch("+"".quote+", 1);end function ;command.dc = @command.disconnect ;;command.wipe = function(PARAMS);    init = function();        flags_arr = Params.extract_flags(PARAMS);;        for flag_token in flags_arr ;            if tp(["+"help".quote+", "+"h".quote+"].indexOf(flag.values.clean(["+"-".quote+"]).join("+"".quote+").lower)) == "+"number".quote+" then;                Usage.display("+"disconnect".quote+", Usage.get_usage_object("+"disconnect".quote+"));                return _callback.catch("+"".quote+", 0);            end if ;        end for ;;        return _callback.catch("+"".quote+", 1);    end function ;    error_handling = init();    if not error_handling.status then return error_handling;;    Session.wipe();    Exploit.device.wipe();    Prompt.prepare_input("+"disconnect".quote+");;    return _callback.catch("+"".quote+", 1);end function ;;command.rat = function(PARAMS);    config = {"+"scan_nw".quote+": 0, "+"rshell".quote+": 0, "+"dict".quote+": 0, "+"bounce".quote+": 0};    bounce = {"+"library_name".quote+": "+"aptclient.so".quote+", "+"lan_address".quote+": 0};    init = function();        if not Session.process.is_connected() then return _callback.catch("+"[blbx][rat][err]: must [connect] to a target to use [rat] exploit...".quote+");        ;        if not PARAMS.len > 0 then ;            Usage.display("+"rat".quote+", Usage.get_usage_object("+"rat".quote+"));            return _callback.catch("+"".quote+", 0);        end if ;;        flag_tokens = Params.extract_type(PARAMS, [TokenTypes.Flag]);        if not flag_tokens then ;            Usage.display("+"rat".quote+", Usage.get_usage_object("+"rat".quote+"));            return _callback.catch("+"".quote+", 0);        end if ;        ;        for flag_token in flag_tokens ;            print "+"linux 688: ".quote+"+ flag_token;            print "+"linux 689: ".quote+"+ flag_token.value.values.clean(["+"-".quote+"]).join("+"".quote+");            if tp(["+"scan_nw".quote+", "+"snw".quote+"].indexOf(flag_token.value.values.clean(["+"-".quote+"]).join("+"".quote+"))) == "+"number".quote+" then config.scan_nw = 1;            if tp(["+"rshell".quote+", "+"rsh".quote+"].indexOf(flag_token.value.values.clean(["+"-".quote+"]).join("+"".quote+"))) == "+"number".quote+" then config.rshell = 1;            if tp(["+"dict".quote+", "+"d".quote+"].indexOf(flag_token.value.values.clean(["+"-".quote+"]).join("+"".quote+"))) == "+"number".quote+" then config.dict = 1;            flag_token = flag_token.value;            if flag_token.is_match("+"\[".quote+") and flag_token.is_match("+"\]".quote+") then ;                flag_token = flag_token.split("+", ".quote+");                if not flag_token.len > 1 then;                    Usage.display("+"rat".quote+", Usage.get_usage_object("+"rat".quote+"));                    return _callback.catch("+"".quote+", 0);                end if;                flag_token = flag_token.join("+",".quote+");                print "+"internal 724: ".quote+"+ flag_token;                if tp(["+"bounce".quote+", "+"b".quote+"].indexOf(slice(flag_token.values.clean("+"-".quote+"), 0, flag_token.values.clean("+"-".quote+").indexOf("+"[".quote+")).join("+"".quote+"))) == "+"number".quote+" then ;                    if flag_token.is_match("+"\[".quote+") and flag_token.is_match("+"\]".quote+") then;                        if not flag_token.values.clean(["+"-".quote+"]).join("+"".quote+").lower.split("+"\[|\,|\s|\]".quote+")[1:].len > 1 then ;                            Usage.display("+"rat".quote+", Usage.get_usage_object("+"rat".quote+"));                            return _callback.catch("+"".quote+", 0);                        end if;                        ;                        config.bounce = 1;                        bounce.lan_address = flag_token.values.clean(["+"-".quote+"]).join("+"".quote+").lower.split("+"\[|\,|\s|\]".quote+")[1:][0];                        bounce.library_name = flag_token.values.clean(["+"-".quote+"]).join("+"".quote+").lower.split("+"\[|\,|\s|\]".quote+")[1:][1];;                        if not is_lan_ip(bounce.lan_address) then return _callback.catch("+"[blbx][rat][err]: lan address '".quote+" + bounce.lan_address + "+"' is invalid...".quote+");    ;                        available_libs = ["+"aptclient.so".quote+", "+"kernel_router.so".quote+", "+"kernel_module.so".quote+", "+"net.so".quote+", "+"init.so".quote+", "+"crypto.so".quote+", "+"librshell".quote+", "+"libhttp.so".quote+", "+"libssh.so".quote+", "+"libftp.so".quote+", "+"libsmtp.so".quote+", "+"librepository.so".quote+"];                        found = false;                        for library_name in available_libs;                            if library_name.lower.search(bounce.library_name.lower) then ;                                bounce.library_name = library_name;                                found = true;                                break ;                            end if;                        end for ;                        if not found then return _callback.catch("+"[blbx][rat][err]: library '".quote+" + bounce.library_name + "+"' not found...".quote+");                    end if ;                end if;            end if;        end for ;;        return _callback.catch("+"".quote+", 1);    end function ;    error_handling = init();    if not error_handling.status then return error_handling;    ;    handle = {};    handle["+"scan_nw".quote+"] = function();        init = function();            shell_instance = fif(Session.process.is_connected(), Session.borrow("+"shell".quote+", Session.machine.ip.get_lan()), get_shell);            try_send_data = Exploit.module.malware.send(shell_instance, "+"blbx_scan_nw.src".quote+", "+"".quote+", Session.rpc.src.scan_nw(), {"+"_callback".quote+": _callback});            return try_send_data;        end function ;        error_handling = init();        if not error_handling.status then return error_handling;;        data_catch = Exploit.module.malware.catch().data;;        return _callback.catch(data_catch, 1);    end function ;;    handle["+"rshell".quote+"] = function();        init = function();            shell_instance = fif(Session.process.is_connected(), Session.borrow("+"shell".quote+", Session.machine.ip.get_lan()), get_shell);            try_send_data = Exploit.module.malware.send(shell_instance, "+"blbx_rshell.src".quote+", "+"".quote+", Session.rpc.src.rshell(), {"+"_callback".quote+": _callback, "+"Directory".quote+": Directory, "+"host_ip_address".quote+": get_shell.host_computer.public_ip});            return try_send_data;        end function ;        error_handling = init();        if not error_handling.status then return error_handling;;        data_catch = Exploit.module.malware.catch();        if data_catch.data.hasIndex("+"rshell".quote+") then ;            rshell = data_catch.data.rshell //yeah i know what the hell ;            print "+"linux 726: ".quote+"+ rshell //see the bullshit here;            Session.allocate(rshell, rshell.host_computer.local_ip);            Exploit.device.add(rshell, rshell.host_computer.local_ip);            printb("+"*** reverse shell connection from '".quote+" + rshell.host_computer.local_ip + "+"' intercepted ***".quote+");        else ;            printb("+"*** please start a rshell port forward at the router on '".quote+" + get_shell.host_computer.public_ip + "+"' ***".quote+");        end if;        return _callback.catch(data_catch.data.data.rshell, 1);    end function ;;    handle["+"bounce".quote+"] = function();        config = {"+"metax".quote+": 0};        shell_instance = fif(Session.process.is_connected(), Session.borrow("+"shell".quote+", Session.machine.ip.get_lan()), get_shell);        file_instance = shell_instance.host_computer.File("+"/".quote+");        try_remote_library = function(bounce);            return Directory.find_file(file_instance, 0, bounce.library_name);        end function;;        init = function(bounce);            if not config.metax then ;                printb("+"*** 'metaxploit.so' library missing on target machine ***".quote+".c("+"purple".quote+"));                printb("+"planting...".quote+".c("+"purple".quote+"));;                local_metax_lib = Directory.find_file(get_shell.host_computer.File("+"/".quote+"), 0, "+"metaxploit.so".quote+");                if not tp(local_metax_lib) == "+"file".quote+" then return _callback.catch("+"[blbx][rat][err]: metaxploit library not found on machine...".quote+");;                access_dir = Session.rpc.get_access(file_instance);                if not tp(access_dir) == "+"file".quote+" then return _callback.catch("+"[blbx][rat][err]: no vulnerable directory available on remote target...".quote+") ;;                print ;                printb("+"vulnerable directory found '".quote+" + access_dir.path + "+"'".quote+");                try_send_metax = get_shell.scp(local_metax_lib.path, access_dir.path, shell_instance);                if tp(try_send_metax) == "+"string".quote+" then return _callback.catch(("+"[blbx][rat][err]: ".quote+" + try_send_metax));            end if;            ;            if not tp(try_remote_library(bounce)) == "+"file".quote+" then ;                printb("+"*** '".quote+" + bounce.library_name + "+"' library missing on target machine ***".quote+".c("+"purple".quote+"));                printb("+"planting...".quote+".c("+"purple".quote+"));                local_library_file = Directory.find_file(get_shell.host_computer.File("+"/".quote+"), 0, bounce.library_name);                print "+"linux 822: ".quote+"+ bounce.library_name;                if not tp(local_library_file) == "+"file".quote+" then return _callback.catch("+"[blbx][rat][err]: library '".quote+" + bounce.library_name + "+"' not found on machine. cannot plant for exploitation....".quote+");;                access_dir = Session.rpc.get_access(file_instance);                if not tp(access_dir) == "+"file".quote+" then return _callback.catch("+"[blbx][rat][err]: no vulnerable directory available on remote target...".quote+") ;;                print ;                printb("+"vulnerable directory found '".quote+" + access_dir.path + "+"'".quote+");                try_send_local_library = get_shell.scp(local_library_file.path, access_dir.path, shell_instance);                if tp(try_send_local_library) == "+"string".quote+" then return _callback.catch(("+"[blbx][rat][err]: ".quote+" + try_send_metax));            end if ;;            try_send_data = Exploit.module.malware.send(shell_instance, "+"blbx_bounce.src".quote+", "+"".quote+", Session.rpc.src.bounce(), {"+"_callback".quote+": _callback, "+"Directory".quote+": Directory, "+"Exploit".quote+": Exploit, "+"string".quote+": string, "+"Session".quote+": Session, "+"library_name".quote+": Directory.find_file(file_instance, 0, bounce.library_name).path, "+"lan_address".quote+": bounce.lan_address, "+"database".quote+": Session.db.parse("+"exploit".quote+"), "+"notify".quote+": @notify, "+"hide_ip".quote+": @hide_ip});            return try_send_data;        end function ;        error_handling = init(bounce);        if not error_handling.status then return error_handling;;        data_catch = Exploit.module.malware.catch().data ;        if not data_catch.hasIndex("+"shell".quote+") then return _callback.catch(data_catch.data);;        for object_arr in data_catch.shell.list + data_catch.computer.list + data_catch.file.list;            object = object_arr[0];            Session.allocate(object, bounce.lan_address);            Exploit.device.add(object, bounce.lan_address);        end for ;;        config.metax.delete;        try_remote_library(bounce).delete;;        return _callback.catch("+"".quote+", 1);    end function;;    return_data = [];;    for func_name in config.indexes;        if config[func_name] then ;            func_syntax_proxy = @handle[func_name];            return_data.push(func_syntax_proxy());        end if ;    end for ;;    print "+"linux 828: ".quote+"+ return_data;    if not return_data.len then return _callback.catch("+"".quote+", 1);    if not return_data[0].status then return _callback.catch(return_data[0]);;    return _callback.catch(return_data[0], 1);end function  ;;command.rshells = function(PARAMS);    init = function();;        return _callback.catch("+"".quote+", 1);    end function ;    error_handling = init();    if not error_handling.status then return error_handling;;    print Exploit.module.get_local_lib("+"metaxploit.so".quote+").rshell_server;;    return _callback.catch("+"".quote+", 1);end function ;;command.ps = function(PARAMS);;end function ;;command.obtain = function(PARAMS);    config = {"+"ssh_ip".quote+": 0, "+"ssh_passwd".quote+": 0, "+"rhost".quote+": 0, "+"flag".quote+": 0, "+"target_amount".quote+": 1};    init = function();        if not PARAMS.len then ;            Usage.display("+"build".quote+", Usage.get_usage_object("+"build".quote+"));            return _callback.catch("+"".quote+", 0);        end if ;;        token_string = Params.extract_type(PARAMS, [TokenTypes.String]);        if token_string then ;            string_value = token_string[0].value;            ssh_components = string_value.split("+" ".quote+");            if not ssh_components.len > 1 then;                Usage.display("+"build".quote+", Usage.get_usage_object("+"build".quote+"));                return _callback.catch("+"".quote+", 0);            end if   ;;            config.ssh_ip = ssh_components[0];            config.ssh_passwd = ssh_components[1];;            return _callback.catch("+"".quote+", 1);        end if ;;        flag_token = Params.extract_type(PARAMS, [TokenTypes.Flag])[0];        if not flag_token then ;            Usage.display("+"build".quote+", Usage.get_usage_object("+"build".quote+"));            return _callback.catch("+"".quote+", 0);        end if ;        if tp(["+"port".quote+", "+"p".quote+"].indexOf(flag_token.value.values.clean(["+"-".quote+"].join("+"".quote+")))) == "+"number".quote+" then config.flag = flag_token.value;;        return _callback.catch("+"".quote+", 1);    end function ;    error_handling = init();    if not error_handling.status then return error_handling;;;;    return _callback.catch("+"".quote+", 1);end function ;;// linux"

_src_compiler.body["parser.src"] = "Parser = {};Parser.tokens = [];Parser.ast_output = [];Parser.current = 0;Parser.wipe = function();    self.tokens = [];    self.current = 0;    self.ast_output = [];end function;Parser.set_tokens = function(new_tokens);    self.tokens = new_tokens;    return self.tokens;end function;Parser.get_tokens = function();    return self.tokens;end function ;Parser.set_current = function(new_current);    self.current = new_current;    return self.current ;end function;Parser.get_current = function();    return self.current;end function ;Parser.get_ast_output = function();    return self.ast_output;end function ;Parser.set_ast_output = function(new_ast_output);    self.ast_output = new_ast_output;    return self.ast_output;end function;Parser.consume = function();    if not self.get_tokens().len then return null ;    element = self.get_tokens()[0];    self.set_tokens(self.get_tokens()[1:]);    return element;end function;Parser.ParseCommand = function();    args = [];    token = self.consume();    if tp(token) == "+"null".quote+" then return null;    if token.type == TokenTypes.Command then ;        command_token = { "+"type".quote+": TokenTypes.Command, "+"value".quote+": token.value };        command_token.params = self.tokens;        self.get_ast_output().push(command_token);        return command_token;    end if ;end function ;Parser.ParseCLI = function(input);    Lexer.set_input(input);    tokens = Lexer.Tokenize();    //print tokens;    Parser.set_tokens(tokens);    Parser.ParseCommand();    return Parser.get_ast_output();end function ;Parser.reset = function(); Lexer.wipe(); self.wipe();end function"

_src_compiler.body["callback.src"] = "_callback = {};_callback.catch = function(message = "+"".quote+", status = 0);    return { "+"status".quote+": status, "+"data".quote+": message };end function;//callback.so"

_src_compiler.body["generic.src"] = "c33=char(33);c0=char(0);c10=char(10);tp=@typeof;cs=@clear_screen;ui=@user_input;rtr=get_router;gs = function();    return get_shell;end function;gc = function();    return get_shell().host_computer;end function;gf=function(path = "+"/".quote+");    return get_computer().File(path);end function;callable = function(value);    return tp(value) == "+"function".quote+";end function;anonSuccess = function();  return true;end function;anonFailure = function();  return true;end function;fif = function(condition, onSuccess = @anonSuccess, onFailure = @anonFailure);    if callable(condition) then condition = condition();    ;    if condition then ;        if callable(onSuccess) then return onSuccess();        return onSuccess;    end if;    if callable(onFailure) then return onFailure();    return onFailure();end function;// Strings;string.search = function(sub_string = "+"".quote+");    return tp(self.lower.indexOf(sub_string.lower)) == "+"number".quote+";end function;string.has = function(sub_string = "+"".quote+");    return tp(self.indexOf(sub_string)) == "+"number".quote+";end function;string.quote = function();    return "+"".quote+""+"".quote+" + self + "+"".quote+""+"".quote+";end function;string.elipsis = function(size = 15);    if self.len > size then return self[:(size-1)] + "+"...".quote+";    return self;end function;string.color=function(string_split_by_space="+"black black black".quote+");list=string_split_by_space.split("+" ".quote+");  if not string_split_by_space.len then string_split_by_space="+"black black black".quote+";  colorm={"+"black".quote+":"+"<#707070>".quote+", "+"white".quote+":"+"<#BEB9E7FF>".quote+", "+"purple".quote+":"+"<#7A53F6>".quote+", "+"pink".quote+":"+"<#ED2EEA>".quote+", "+"red".quote+":"+"<color=red>".quote+", "+"dark_red".quote+":"+"<#731313>".quote+", "+"blue".quote+":"+"<color=blue>".quote+", "+"green".quote+":"+"<#2BB930>".quote+", "+"dark_green".quote+":"+"<#2C6407>".quote+", "+"cyan".quote+":"+"<#32E3EF>".quote+", "+"yellow".quote+":"+"<#D2DE0F>".quote+", "+"brown".quote+":"+"<#674D06>".quote+", "+"orange".quote+":"+"<#EA9512>".quote+"};  alpha="+"qwertyuiopasdfghjklzxcvbnm".quote+";number="+"1234567890".quote+";symbol="+"!@#$%^&*()_+-={}|[]\:;'<>?,./".quote+"+"+"".quote+""+"".quote+";  check_all=function();res=1;for i in list;if not colorm.hasIndex(i) then ;res=0;break;end if;end for;return res;end function;  if not check_all() then return false;  while list.len < 3;list.push(list[-1]);end while;  coa=colorm[list[0]];con=colorm[list[1]];cos=colorm[list[2]];curr_color=coa;curr_type="+"alpha".quote+";newl=[];fp=1//;count=-1;  for char in self.values;    is_a=(tp(alpha.indexOf(char.lower)) == "+"number".quote+");is_n=(tp(number.indexOf(char)) == "+"number".quote+");is_s=(tp(symbol.indexOf(char)) == "+"number".quote+");    if char==c10 then ;newl.push(char+curr_color);continue;end if;    if is_a then curr_type="+"alpha".quote+";if is_n then curr_type="+"number".quote+";if is_s then curr_type="+"symbol".quote+";    if curr_type=="+"alpha".quote+" then;      if curr_color!=coa or (curr_color==coa and fp) then curr_color=coa else curr_color="+"".quote+";fp=0;      newl.push(curr_color+char);curr_color=coa;continue;    end if;    if curr_type=="+"number".quote+" then;      if curr_color!=con or (curr_color==con and fp) then curr_color=con else curr_color="+"".quote+";fp=0;      newl.push(curr_color+char);curr_color=con;continue;    end if;    if curr_type=="+"symbol".quote+" then;      if curr_color!=cos or (curr_color==cos and fp) then curr_color=cos else curr_color="+"".quote+";fp=0;      newl.push(curr_color+char);curr_color=cos;continue;    end if;    newl.push(char);  end for;  self=newl.join("+"".quote+");ctr=0;  for i in self;    if i == "+"<".quote+" then ctr=ctr+1;  end for;  for i in range(1,ctr);    self=self+"+"</color>".quote+";  end for;  return self;end function;string.c = @string.color;string.reverse = function();    return self.values.reverse.join("+"".quote+");end function;string.isEmpty = function();    return self.len == 0;end function;string.to_bin=function(return_as_arr=0);  ord=function(char);return char.code;end function;  int_to_bin=function(x);    if not x then return [0];    bit=[];    while x;      bit.push(round(x%2));      x=bitwise("+">>".quote+", x, 1);    end while;    while bit.len < 8;bit.push(0);end while;    bit=bit.reverse;    return bit;  end function;  str_to_arr=function(string);newl=[];for i in string;newl.push(i.to_int);end for;return newl;end function;  arr_to_str=function(arr);newl=[];for i in arr;newl.push(str(i));end for;return newl.join("+"".quote+");end function;  newl=[];  for char in self;    newl=newl+int_to_bin(ord(char));  end for;  self=newl;  if return_as_arr then return newl else return arr_to_str(newl);end function;string.remove_markup=function();  new_self="+"".quote+";count=0;toggle=0;  for i in self;    if i == "+"<".quote+" then ;toggle=1;continue; end if;    if i == "+">".quote+" then ;toggle=0;continue; end if;    if toggle then continue;    new_self=new_self+i;  end for;  return new_self;end function;string.enc=function();  //flip each bit by it's hex number and put the number/10 before the resulting bit. add and continue.;  res=[];sep="+",.'qwripdfhkxcvm".quote+".values;  //print self;  for i in self;    bin=i.to_bin;ind=-1;    //print bin;    tc=0;fc=0;tcl=[];fcl=[];    for ide in bin.values;ind=ind+1;      if ide=="+"1".quote+" then;        tc=tc+1;        tcl.push(ind);      else;        fc=fc+1;        fcl.push(ind);      end if;    end for;    ucl=[];uc=0;    //if there are more 0's than 1's, it ascends: 1,2,3;    //if there are more 1's than 0's or are even, it descends: 3,2,1;    if tc < fc then ;tcl.sort;ucl=tcl; end if;    if tc > fc then ;fcl.sort;ucl=fcl.reverse; end if;    if tc == fc then ;fcl.sort;ucl=fcl.reverse; end if;    sep.shuffle;rnd_ind=(floor((rnd*15) + 0));    res.push(ucl.join("+"".quote+")+sep[rnd_ind]);    continue;  end for;  //print res.join("+"".quote+");  return res.join("+"".quote+");end function;string.dec = function();  separators = ( ["+"\,".quote+", "+"\.".quote+"] + "+"'qwripdfhkxcvm".quote+".values );  regular_str = 0;  decrypted_binary_arr = [];  for word in self.split(separators.join("+"|".quote+"))[:-1];    index_arr = word.values;    qwerty = "+"qwertyuiopasdfghjklzxcvbnm".quote+";    qwerty = ( qwerty + qwerty.upper );    is_ascending = 0;    if not index_arr.len or word.has(qwerty.values.join("+"|".quote+")) > 0 then ;      regular_str = 1;      break;    end if;    if index_arr.len == 1 then is_ascending = 1;    if not is_ascending and (index_arr[0].to_int - index_arr[-1].to_int) < 0 then is_ascending = 1;    if is_ascending then;      new_bin = "+"00000000".quote+".values;      for index in index_arr ;        index = index.to_int;        new_bin[index] = "+"1".quote+";      end for;    else;      new_bin = "+"11111111".quote+".values;      for val in index_arr ;        val = val.to_int;        new_bin[val] = "+"0".quote+";      end for;    end if;    decrypted_binary_arr.push(new_bin.join("+"".quote+"));  end for;  ;  if regular_str then return self;  paired_decimal_arr = []; hexadecimal_arr = []; decrypted_ascii_arr = []; res_list = [];  for binary in decrypted_binary_arr;    binary = binary.reverse; first_nibble = binary[0:4]; second_nibble = binary[4:]; total = [];    ;    //-- change binary to decimal representation;    for nibble_arr in [first_nibble.values, second_nibble.values];      position = 0; catch = [];      for bit in nibble_arr;        bit = bit.to_int;        if not bit then ;          position = position + 1;          continue;        end if;        expontial_operation = (2 ^ position);        catch.push(bit * expontial_operation);        position = position + 1;      end for;      ;      val = 0;      for i in catch ;        val = val + i;      end for;      total.push(val);    end for;    paired_decimal_arr.push(total.reverse);  end for;  //-- change decimal to hexadecimal;  for paired_decimal in  paired_decimal_arr;    paired_decimal = paired_decimal.reverse; position = 0; total = [];    for decimal in paired_decimal;      expontial_operation = (16 ^ position);      total.push(decimal * expontial_operation);      position = position + 1;    end for;    val = 0;    for product in total ;      val = val + product;    end for;    hexadecimal_arr.push(val);  end for;  for hexadecimal in hexadecimal_arr;    decrypted_ascii_arr.push(char(hexadecimal));  end for;  return decrypted_ascii_arr.join("+"".quote+");end function;//list:;list.groupBy=function(size=10);  if self.len <=  size then return [self];  psuedo_self=new self;psuedo_self=psuedo_self["+"__isa".quote+"];newl=[];  while psuedo_self.len > 0;    if psuedo_self.len > size then;      newl.push(psuedo_self[:size]);psuedo_self=psuedo_self[size:] ;continue;    end if;    newl.push(psuedo_self);break;  end while;  return newl;end function;list.remove_repeats=function();  newl=[];  for i in self;    if tp(newl.indexOf(i)) != "+"number".quote+" then newl.push(i);  end for;  self=newl;  return self;end function;//list:;//t_list=range(0,49);list.reverse=function();  psuedo_self=new self;psuedo_self=psuedo_self["+"__isa".quote+"];newl=[];  while psuedo_self.len > 0;    newl.push(psuedo_self.pop);  end while;  self= newl;  return self;end function;//t_list=t_list.reverse;list.deep_copy=function();  newl=[];  for item in self;    if tp(item) == "+"list".quote+" then;      newl.push(item.deep_copy);      continue;    end if;    newl.push(item);  end for;  return newl;end function;list.rnd_ind=function();  if not self.len then return 0;  return self[floor((rnd*self.len-1) + 0)];end function;list.combine=function();newm={};  for i in self;    if not i.len == 2 then continue;    newm[i[0]]=newm[i[1]];  end for;  self=newm;  return self;end function;list.copy=function();res=[];for i in self;res.push(i);end for;self=res;return self;end function;list.clean=function(example_list);  newl=[];  for i in self;    if tp(example_list.indexOf(i)) == "+"number".quote+" then continue;    newl.push(i);  end for;  self=newl;  return self;end function;list.has=function(val=[]);  if tp(val) != "+"list".quote+" then val=[val];  if not val.len then return true;  found=0;  for i in val;    if tp(self.indexOf(i)) == "+"number".quote+" then found=1;  end for;  return found;end function;list.format_columns=function();  //make a super clean version here;  clean_list=function(il) ;l=[];for i in il;if tp(i) != "+"string".quote+" then continue;l.push(i);end for;return l;end function;  input_list=clean_list(self);  s="+" ".quote+";  grid={};  grid.columns={};  grid.rows=[];  //print input_list;  grid.top=input_list[0].remove_markup;  for i in range(0, grid.top.split(s).len-1) ;if not grid.columns.hasIndex(str(i)) then ;grid.columns[str(i)]={};grid.columns[str(i)].largest=0;end if; end for;  for row in input_list;    total=[];count=-1;    for i in row.split("+" ".quote+");      count=count+1;      if not grid.columns.hasIndex(str(count)) then continue;      data=i.remove_markup;      if grid.columns[str(count)].largest < data.len then grid.columns[str(count)].largest=data.len;      total.push(i);    end for;    grid.rows.push(total);  end for;  result="+"".quote+";count=-1;  for row in grid.rows;    sub_count=-1;line="+"".quote+";count=count+1;    for item in row;      sub_count=sub_count+1;      clean_item=item.remove_markup;      diff=abs(clean_item.len - grid.columns[str(sub_count)].largest);      line=line+s+item+reveal((s*diff)+(s), (sub_count!=grid.columns.len-1));    end for;    result=result+reveal(c10, (count!=0))+line;  end for;  print bar(45)+c0;  print result;end function;list.max=function();  res=0;  for i in self;    len=0;    if tp(i) == "+"string".quote+" or tp(i) == "+"map".quote+" or tp(i) == "+"list".quote+" then len=i.len;    if tp(i) == "+"number".quote+" then len=i;    if len > res then res=len;  end for;  return res;end function;list.min=function();  res=0;  for i in self;    len=0;    if tp(i) == "+"string".quote+" or tp(i) == "+"map".quote+" or tp(i) == "+"list".quote+" then len=i.len;    if tp(i) == "+"number".quote+" then len=i;    if len < res then res=len;  end for;  return res;end function;list.slice=function(start_ind, to_ind);  psuedo_self=new self;psuedo_self=psuedo_self["+"__isa".quote+"];  if tp(start_ind) != "+"number".quote+" or tp(to_ind) != "+"number".quote+" or (tp(start_ind) == "+"number".quote+" and not psuedo_self.hasIndex(start_ind)) then return null;  if to_ind < 0 then;extra=range(0,psuedo_self.len-1);ind=extra[to_ind];to_ind=ind;end if;difference=(to_ind-(psuedo_self.len-1));  if not psuedo_self.hasIndex(to_ind) and difference==1 then psuedo_self=psuedo_self+["+"_".quote+"];  if not psuedo_self.hasIndex(to_ind) and difference>1 then return null;  return slice(psuedo_self, start_ind, to_ind);end function;//map:;//t_map={};map.add=function(key, value);  self[key]=value;  return self;end function;map.remove=function(value);  if tp(value) == "+"null".quote+" then return false;  v=self.values;i=self.indexes;newm={};  for ind in range(0, i.len-1);key=i[ind];val=v[ind];    if tp(value) == "+"number".quote+" then ;if value==ind then ;ind=ind+1;continue;end if;end if;    if value == i[ind] then ;ind=ind+1;continue;end if;    newm[key]=val;  end for;  self=newm;  return self;end function;map.switch=function();  i=self.indexes;v=self.values;newm={};  for ind in range(0,i.len-1);newm[v[ind]]=i[ind];end for;  return newm;end function;//["+"{".quote+", "+" ".quote+"+"+"0".quote+".quote+"+": ".quote+"+"+"ls /root/Config".quote+".quote,"+" ".quote+"+"+"1".quote+".quote+"+": ".quote+"+"+"cat /root/Config/Bank.txt >|".quote+".quote, "+" ".quote+"+"+"2".quote+".quote+"+": ".quote+"+"+"cat |> --d ".quote+".quote, "+"}".quote+"];map.boot_cli_module=function();  self.display={};end function;//t_map.boot_cli_module();map.run_cli_module=function(name, prompt, cnfMessage, displayModule, colorScheme="+"black black purple".quote+", bold=1, nanoMode=1);  if not displayModule.len then displayModule=[["+"".quote+"]] else displayModule=[displayModule];  if not bold then bold="+"".quote+" else bold="+"<b>".quote+";  config={"+"run".quote+": 1, "+"prompt".quote+": prompt, "+"cs".quote+": colorScheme, "+"display_module".quote+": displayModule, "+"reflected_module".quote+":[], "+"errorMsg".quote+":"+"".quote+", "+"curr_page".quote+":"+"".quote+"};  self.display.module=function();    return config.display_module[-1];  end function;  idr=@self.display.module//internal_display_reference;  config.set_page=function(pageNumber);    config.curr_page=pageNumber;  end function;  self.display.set_page=@config.set_page;  config.display=function(msg, pageNumber="+"".quote+");    ;res=[];confirm=0;    list=idr.groupBy;    if not list.hasIndex(config.curr_page) then config.curr_page=0;    if tp(pageNumber) != "+"string".quote+" then config.curr_page=pageNumber;    if tp(config.curr_page) == "+"string".quote+" then config.curr_page=list.len-1;    ind=config.curr_page*10; if ind == 0 then ind=-1;    page=list[config.curr_page];    if list.len <= 2 then pagel=range(config.curr_page, config.curr_page+list.len-1) else pagel=range(config.curr_page, config.curr_page+2);    while not list.hasIndex(pagel[-1]);pagel.remove(-1);end while;    if list.len > 3 then ;confirm=1;pagel=pagel[:3];end if;    page_indicator="+"pages: ".quote+"+pagel.join("+", ".quote+");    if confirm then page_indicator=page_indicator+"+"...".quote+";    for i in page;      ind=ind+1;      if ind < 10 then index=str(ind)+"+" ".quote+" else index=str(ind);      line=bold+(index+"+"| ".quote+").color(config.cs.split("+" ".quote+")[0]+"+" ".quote+"+config.cs.split("+" ".quote+")[2]+"+" ".quote+"+config.cs.split("+" ".quote+")[0])+i.color(config.cs);      res.push(line);    end for;    diff=10-page.len;if diff < 0 then diff=0//;print diff;    for i in range(0, diff);res.push("+"".quote+");end for;    print(bold+res.join(c10));    print("+"<size=13>".quote+"+bold+(page_indicator).color(config.cs));    if msg=="+"".quote+" then ;print();return 1;end if;    print(bold+msg);    return true;  end function;  config.cnf=function(name);    return bold+((("+"['".quote+").color("+"white".quote+")+(name.color("+"black".quote+"))+("+"']".quote+").color("+"white".quote+"))+cnfMessage);  end function;  config.add_module=function(list);    if config.display_module.len == 25 then config.display_module.pull;    config.display_module.push(list);  end function;  self.display.result=0;  self.display.cs=config.cs;  self.display.add=function(data="+"".quote+");if idr[0]=="+"".quote+" and data != idr[0] then idr[0]=data else config.add_module(idr+[data]);end function;  self.display.remove=function(index="+"0".quote+");    list=index.split("+",".quote+").clean(["+"".quote+"]);newl=[];    for i in list;if i.to_int < 0 then newl.push(idr.len-abs(i.to_int)) else newl.push(i.to_int);end for;    list=newl.sort;ind=-1;newl=[];    for i in idr;ind=ind+1;if tp(list.indexOf(ind)) == "+"number".quote+" then continue;newl.push(i);end for;    if not newl.len then ;newl=["+"".quote+"];config.curr_page=0;end if;    config.add_module(newl);  end function;  self.display.find=function(find_string); ind_list=[];ind=-1;    for i in idr; ind=ind+1;      if i.search(find_string) then ind_list.push(ind+1);    end for;    return ind_list;  end function;  self.display.undo=function();if config.display_module.len > 1 then config.reflected_module.push(config.display_module.pop);end function;  self.display.redo=function();if config.reflected_module.len > 0 then config.display_module.push(config.reflected_module.pop);end function;  self.display.next_page=function();if idr.groupBy.hasIndex(config.curr_page+1) then config.curr_page=config.curr_page+1;end function;  self.display.prev_page=function();if idr.groupBy.hasIndex(config.curr_page-1) then config.curr_page=config.curr_page-1;if config.curr_page < 0 then config.curr_page=0;end function;  self.display.replace=function(index="+"0".quote+", data="+"".quote+");    list=index.split("+",".quote+").clean(["+"".quote+"]);newl=[];copy=idr.copy;    for i in list;if i.to_int < 0 then newl.push(idr.len-abs(i.to_int)) else newl.push(i.to_int);end for;    list=newl.sort;ind=-1;newl=[];    for i in idr; ind=ind+1;      if tp(list.indexOf(ind)) == "+"number".quote+" then;        if data.len > 0 and data[0] == "+"+".quote+" then copy[ind]=copy[ind]+data[1:] else copy[ind]=data;      end if;    end for;    config.add_module(copy);  end function;  self.display.insert=function(index=0, data="+"".quote+");    if index < 0 then index=idr.len-abs(index);    if not index then;      idr=[data]+idr;      return true;    end if;    p1=idr[:index];p2=idr[index:];    res=p1+[data]+p2;    config.add_module(res);  end function;  self.display.usage=function(obj);    res="+"<b>".quote+";next=c10+"+"<b>".quote+";    for i in obj;      res=res+next+(i.key.upper+"+": ".quote+").color("+"black".quote+");      for elem in i.value;        res=res+c10+bold+(elem).color("+"black purple".quote+");      end for;    end for;    return res;  end function;  self.back=function(cmd);config.run=0;cs;return {"+"status".quote+":1, "+"msg".quote+":"+"".quote+"};end function;self.exit=@self.back;self.done=@self.back;self.save=@self.back;  self.clear=function(cmd);cs;return {"+"status".quote+":1, "+"msg".quote+":"+"".quote+"};end function;  self.help=function(cmd);  end function;  while config.run;    if nanoMode then; cs;      config.display(config.errorMsg);      config.errorMsg="+"".quote+";    else;      if tp(config.errorMsg) == "+"string".quote+" and config.errorMsg.len > 0 then;        print bar(40);        print config.errorMsg;        config.errorMsg="+"".quote+";      end if;    end if;    cmd=ui(prompt).split("+" ".quote+");    if not cmd.clean(["+" ".quote+", "+"".quote+"]).len then ;if nanoMode then ;self.display.add("+"".quote+");continue;end if;continue;end if;    if tp(self.indexes[1:].indexOf(cmd.clean(["+" ".quote+", "+"".quote+"])[0])) != "+"number".quote+" then;      if nanoMode then;        if cmd.join("+" ".quote+")[0]=="+"\".quote+" then cmd=cmd.join("+" ".quote+")[1:].split("+" ".quote+");        self.display.add(cmd.join("+" ".quote+"));        continue;      end if;      print c10+config.cnf(cmd.clean(["+" ".quote+", "+"".quote+"])[0]);continue;    end if;    cmd=cmd.clean(["+" ".quote+", "+"".quote+"]);    proxy=@self[cmd[0]];    store=proxy(cmd);    if not tp(store) == "+"map".quote+" or tp(store) == "+"map".quote+" and store.indexes != ["+"status".quote+", "+"msg".quote+"] then exit(("+"master_lib.so: origin -> run_cli_module: custom commands must return object: {".quote+"+"+"status".quote+".quote+"+": bool, ".quote+"+"+"msg".quote+".quote+"+": ".quote+"+"+"string".quote+".quote+"+"}... ".quote+").color("+"red".quote+"));    if not store.status then ;config.errorMsg=store.msg;continue;else;config.errorMsg="+"".quote+";end if// print c10+store.msg.color("+"red".quote+");    if not nanoMode then ;self.display.result=store.msg;end if;  end while;  if nanoMode then return self.display.module;  return self.display.result;end function;//number:;number.decrement=function(size=1);  if tp(size) != "+"number".quote+" then size=1;  self=self-size;  return self;end function;number.dec=@number.decrement;number.increment=function(size=1);  if tp(size) != "+"number".quote+" then size=1;  self=self+size;  return self;end function;number.inc=@number.increment;generate={};generate.id=function(length=4, type="+"int".quote+");  if type.search("+"int".quote+") then ;pool="+"1234567890".quote+";else if type.search("+"str".quote+") then;pool="+"qwertyuiopasdfghjklzxcvbnm".quote+";else if type.search("+"hybrid".quote+") then;pool="+"qwertyuiopasdfghjklzxcvbnm1234567890".quote+";end if;  pool=pool.values;res=[];  for i in range(1,length);    res.push(pool.rnd_ind);  end for;  res=res.join("+"".quote+").to_int;  return res;end function;map.editor_init=function();  self.module={"+"display".quote+":[["+"".quote+"]], "+"line".quote+":1, "+"cursor".quote+":0, "+"inverse".quote+":[], "+"process".quote+":1, "+"line_limit".quote+":0};  module=self.module;  self.action={};  action=self.action;  action.get_display=function();    return module.display[-1];  end function;  action.add_display=function(value);    module.display.push(value);    if module.display.len == 50 then module.display=module.display[1:];  end function;  action.undo=function();    if module.display.len == 1 then return;    module.inverse.push(module.display.pop);  end function;  action.redo=function();    if not module.inverse.len then return;    module.display.push(module.inverse.pop);  end function;  action.line_down=function();    if module.line == module.line_limit-1 then ;module.line=1;return;end if;    module.line=module.line+1;  end function;  action.line_up=function();    if module.line == 1 then ;module.line=module.line_limit-1;return;end if;    module.line=module.line-1;  end function;  action.cursor_right=function();    if module.cursor == 1 then return;    module.cursor=module.cursor+1;  end function;  action.cursor_left=function();    if not module.cursor then return;    module.cursor=module.cursor-1;  end function;  self.command={};  return self;end function;map.editor=function(input_msg, cnf_function, display_function, allowed_char_list, given_display=["+"".quote+"]);  if not self.hasIndex("+"module".quote+") and not self.hasIndex("+"action".quote+") and not self.hasIndex("+"command".quote+") then return false;  self.module.display[-1]=given_display;  self.module.line_limit=given_display.len-1;  while self.module.process; cs;    display_function();    cmd=ui(input_msg, 0, 1);    if not allowed_char_list.has(cmd) then continue;    if not self.command.hasIndex(cmd) then;      cnf_function();      continue;    end if;    proxy=self.command[cmd];    proxy();  end while;  return self.module.display[-1];end function;map.get_key = function(search_for = []);  result_arr = [];  index = -1;  for value in self.values;    index = index + 1;    if tp(search_for.indexOf(value)) == "+"number".quote+" then;      result_arr.push(map.indexes[index]);      continue;    end if  ;  end for ;end function;//generic.so"

_src_compiler.body["markup.src"] = "b="+"<b>".quote+";u="+"<u>".quote+";b2="+"</b>".quote+";u2="+"</u>".quote+";color={"+"map".quote+":{"+"b".quote+":"+"#707070".quote+", "+"p".quote+":"+"#7A53F6".quote+", "+"w".quote+":"+"#BEB9E7FF".quote+", "+"r".quote+":"+"red".quote+"}};status={"+"is_active".quote+":false, "+"is_verbose".quote+":false, "+"streamer_mode".quote+":0, "+"hide_db_files".quote+":1};c=function(str);  if tp(color.map.indexes.indexOf(str)) == "+"number".quote+" then return "+"<color=".quote+"+color.map[str]+"+">".quote+";  if tp(str.indexOf("+"<color=".quote+")) == "+"number".quote+" then return str;  print str;  return "+"<color=".quote+"+str+"+">".quote+";end function;a=function(str="+"c".quote+");  map={"+"c".quote+":"+"center".quote+", "+"r".quote+":"+"right".quote+", "+"l".quote+":"+"left".quote+"};  if tp(map.indexes.indexOf(str)) == "+"number".quote+" then str=map[str] else str=map["+"c".quote+"];  return "+"<align=".quote+"+str+"+">".quote+";end function;e=function(str="+"c".quote+");  map={"+"c".quote+":"+"color".quote+", "+"a".quote+":"+"align".quote+", "+"b".quote+":"+"b".quote+", "+"u".quote+":"+"u".quote+", "+"st".quote+":"+"s".quote+", "+"s".quote+":"+"size".quote+"};  if tp(map.indexes.indexOf(str)) == "+"number".quote+" then str=map[str] else str=map["+"c".quote+"];  return "+"</".quote+"+str+"+">".quote+";end function;eb=e("+"b".quote+");eu=e("+"u".quote+");est=e("+"st".quote+");es=e("+"s".quote+");ea=e("+"a".quote+");ec=e("+"c".quote+");s=function(int);  if tp(int) != "+"number".quote+" then int=15;  return "+"<size=".quote+"+int+"+">".quote+";end function;st=function();return "+"<s>".quote+";end function;bar=function(int, color=0);  //if int > 45 then int=45;  if tp(int) != "+"number".quote+" then return c("+"r".quote+")+"+" bar: 'int' must be an interger...".quote+";  return reveal(c("+"b".quote+"), (not color), color)+c("+"p".quote+")+"+"".quote+"+ec+st+("+" ".quote+"*int)+est+c("+"p".quote+")+"+"".quote+";end function;display=function(input_list);  return bar(max(input_list)) + c10 + input_list.join(c10);end function;//wisp=c("+"p".quote+")+"+"".quote+"+c("+"w".quote+")+st+"+"   ".quote+"+est+c("+"p".quote+")+"+"".quote+";wisp=c("+"p".quote+")+"+"".quote+"+c("+"w".quote+")+st+"+" ".quote+"+est+c("+"p".quote+")+"+"".quote+";reveal=function(str, onCondition=0, elseShow="+"".quote+");if onCondition then return str;return elseShow;end function;box=function(str, opt=0, opt2=0);return c("+"b".quote+")+b+"+"[".quote+"+reveal(u, (not opt), "+" ".quote+")+c("+"p".quote+")+str+c("+"b".quote+")+reveal(u2, (not opt), "+" ".quote+")+"+"]".quote+";end function;next=c10+s(17);add_line=function();print c0;end function;cnf=function(str, add=0);  return reveal(c10, (add))+b+("+"[".quote+".color("+"black".quote+")+("+"'".quote+"+str+"+"'".quote+").color("+"white".quote+")+"+"]: command not found!".quote+".color("+"black".quote+"))+c10;end function;mnf=function(str, add);  return reveal(c10, (add))+b+("+"[".quote+".color("+"black".quote+")+("+"'".quote+"+str+"+"'".quote+").color("+"white".quote+")+"+"]: macro not found!".quote+".color("+"black".quote+"))+c10;end function;yon=function(msg);  op=ui(msg);  print op;  spread=[op.lower.search("+"y".quote+"), op.lower.search("+"n".quote+")];  print spread;  while spread[0]+spread[1] != 1;    op=ui(msg);    spread=[op.lower.search("+"y".quote+"), op.lower.search("+"n".quote+")];  end while;  if spread[0] then return true;  return false;end function;operator=function(symbol, msg);return c("+"r".quote+")+"+"[ ".quote+"+c("+"w".quote+")+b+"+"'".quote+"+symbol+"+"'".quote+"+b2+ec+"+" ]: ".quote+"+msg+"+"...".quote+";end function;notify=function(str, type="+"!".quote+", add=0);return reveal(c10, (add))+box(c("+"w".quote+")+type+ec,1)+wisp+box(str,1);end function;longer=function(f,s);if f.len==s.len then return [f,s];if f.len > s.len then return f else return s;end function;shorter=function(f,s);if f.len==s.len then return [f,s];if f.len > s.len then return f else return s;end function;shorten_path=function(s, add_color=0);  if tp(s) != "+"string".quote+" then return "+"".quote+";  if s[0] == "+"/".quote+" then s=s[1:];sl=s.split("+"/".quote+");  if sl.len <= 3 then return "+"/".quote+"+s;  if not add_color then return "+"/".quote+"+sl[0]+"+"/.../".quote+"+sl[-2:].join("+"/".quote+");  return "+"/".quote+".color("+"white".quote+")+sl[0].color("+"black".quote+")+("+"/".quote+".color("+"white".quote+")+"+"...".quote+".color("+"black".quote+")+"+"/".quote+".color("+"white".quote+"))+(sl[-2:].join("+"/".quote+")).color("+"black black white".quote+");end function;hide_ip=function(s);  if tp(s) != "+"string".quote+" or tp(s) == "+"string".quote+" and s.split("+"\.".quote+").len != 4 then return "+"".quote+";  sl=s.split("+"\.".quote+");  return reveal("+"***.***.".quote+"+sl[2:].join("+".".quote+"), (status.streamer_mode), s);end function;quotes=function(input_str);return "+"".quote+""+"".quote+"+input_str+"+"".quote+""+"".quote+";end function;announce=function(input, data);print b+((input+"+": ".quote+").color("+"purple".quote+"))+b2+data+c0;end function;errorDisplay = function(input) ;  if tp(input) == "+"list".quote+" then input = input[0];  if tp(input) != "+"string".quote+" then return c0;  error =  b+("+"[ ".quote+" + "+"?".quote+".color("+"white".quote+") + "+" ]".quote+" + wisp + "+"[ ".quote+" + (input.color("+"white".quote+")) + "+" ]".quote+").color("+"black".quote+");  print error + c10;  return error;end function ;parse_error=function(input_str, beginning=0, ending=1);  while input_str[-1] == "+".".quote+";input_str=input_str[:-1];end while;  if not tp(input_str) == "+"string".quote+" then return tp(input_str);  input_str=input_str.lower;  if beginning and beginning[-1] != "+"'".quote+" then beginning=beginning+"+"'".quote+";  if input_str.search("+"denied".quote+") then input_str="+"permission denied".quote+";  if ending==1 then return reveal(beginning, (beginning!=0), "+"'".quote+")+reveal(input_str.elipsis+"+"' not found.".quote+", (input_str.len>15), input_str+"+"' not found...".quote+");  if tp(ending)=="+"string".quote+" then return reveal(beginning, (beginning!=0), "+"'".quote+")+reveal(input_str.elipsis+ending, (input_str.len>15), input_str+ending);  if not input_str.split("+"error: ".quote+").len < 2 then input_str=input_str.split("+"error: ".quote+")[1]+"+"...".quote+" else input_str=input_str+"+"...".quote+";  return reveal(beginning, (beginning!=0), "+"".quote+")+input_str;end function;printb=function(input="+"".quote+");  print b+(input)+c0;end function;success=function(add=1);  print b+("+"success".quote+".color("+"purple".quote+"))+reveal(c10, (add))+c0;end function;failed=function(add=1);  print b+("+"failed".quote+".color("+"black".quote+"))+reveal(c10, (add))+c0;end function;logo=function();  return b+(a+s(50)+"+"black".quote+".color("+"black".quote+")+"+"box".quote+".color("+"purple".quote+"))+c10;end function;show_prompt=function(im, il, add=1);  if tp(il) == "+"list".quote+" then il=il.join("+" ".quote+");  if il[-1]=="+":".quote+" then il=il[:-1];  print im.prompt+il.color("+"white".quote+")+c0;  if add then add_line;end function;shorten_dialogue=function(input_str, color=1);  char_count=0;word_count=0;res="+"".quote+";  clean=function(inp_str);    reso="+"".quote+";toggle=0;    for i in inp_str;      if i == "+"<".quote+" then ;toggle=1;continue;end if;      if i == "+">".quote+" then ;toggle=0;continue;end if;      if toggle then continue;      reso=reso+i;    end for;    return reso;  end function;  input_str=clean(input_str);  for word in input_str.split("+" ".quote+");    if char_count > 45 then ;char_count=0;res=res+c10+b+"+" ".quote+"; end if;    if word.len > 9 and char_count > 39 then ;res=res+c10;char_count=0;word_count=0; end if;    res=res+reveal("+" ".quote+", (char_count>0 or not word_count), "+"".quote+")+b+reveal(word.color("+"black black purple".quote+"), (color), word);    char_count=char_count+(word.len+1);word_count=word_count+1;    if word.search(c10) then ;char_count=0;word_count=0;end if;  end for;  return res+c10;end function;usage=function(map);  headers=map.indexes;  result="+"".quote+";head_count=0;  for head in headers;    head_count=head_count+1;    if map[head].len > 0 then;      while map[head][0][0]=="+" ".quote+";map[head][0]=map[head][0][1:];end while;    end if;    if map[head].len > 1 and head == "+"usage".quote+" then;      mini_result="+"".quote+";      for item in map[head];        mini_result=mini_result+b+reveal("+" ".quote+", (item[0]!="+" ".quote+"), "+"".quote+")+item.color("+"black black purple".quote+")+c10;      end for;      result=result+b+(head.upper+"+": ".quote+").color("+"black".quote+")+c10;      result=result+mini_result+c10;      continue;    end if;    //if map[head].len == 1 then print head+"+" : ".quote+"+map[head][0].len;    if map[head].len == 1 and map[head][0].len > 45 then;      result=result+b+(head.upper+"+": ".quote+").color("+"black".quote+")+c10;      result=result+shorten_dialogue(map[head][0])+c10;      continue;    else if map[head].len == 1 and map[head][0].len <= 45 then;      result=result+b+(head.upper+"+": ".quote+").color("+"black".quote+")+map[head][0].color("+"black black purple".quote+")+c10;      continue;    end if;    result=result+reveal(c10, (head_count>1))+b+(head.upper+"+":".quote+").color("+"black".quote+");    result=result+c10;    result=result+shorten_dialogue(map[head]);    if head_count==1 then result=result+c10;  end for;  while result[-1]==c10;result=result[:-1];end while;  print result+c10;end function;generate_prompt=function(val=["+"blbx".quote+"], new_line=0);  res="+"".quote+";count=-1;pointer="+"> ".quote+".color("+"purple".quote+");pointer_color=c("+"b".quote+");  for box_content in val;    count=count+1;    res=reveal(next, (new_line==1), "+"".quote+")+reveal(wisp, (count > 0), "+"".quote+")+box(box_content);  end for;  res=res+next+wisp+box("+"#".quote+")+pointer+pointer_color;  return res;end function;//markup.so;"

_src_compiler.body["prompt.src"] = "Prompt = {};Prompt.current_path = "+"/root".quote+";Prompt.ip_address = "+"local".quote+";Prompt.get_current_path = function();    return self.current_path;end function ;Prompt.get_ip_address = function();    return self.ip_address;end function ;Prompt.set_path = function(new_path);    self.current_path = new_path;end function;Prompt.set_ip_address = function(new_ip_address);    self.ip_address = new_ip_address;end function ;Prompt.message = function();    return box("+"blbx".quote+") + wisp + box(self.get_current_path()) + wisp + box(self.get_ip_address()) + "+"\n".quote+" + "+"-".quote+".c("+"black".quote+") + box("+"#".quote+") + "+":> ".quote+";end function;Prompt.get_message = function();    return self.message();end function ;Prompt.show_message = function(cmd_name, params);    print self.message() + b + (cmd_name + "+" ".quote+" + params).c("+"purple".quote+");end function;Prompt.run_command = function(command_ast, show_error = 1);    if not command.hasIndex(command_ast[0].value) then ;        print;        printb("+"[blbx][sys]: command not found...".quote+".c("+"black black purple".quote+"));        print ;        return _callback.catch("+"".quote+", 0) ;    end if ;  ;    safe_run_result = Session.process.safe_run(command_ast[0].value, command_ast[0].params);    ;    if not safe_run_result.status and show_error then;        print ;        print b + safe_run_result.data.c("+"black black purple".quote+");        print ;    end if;    return safe_run_result;end function ;Prompt.prepare_input = function(input, show_error = 1);    count = -1;    for cmd in input.split("+":".quote+");        count = count + 1;        cmd = cmd.trim;        if count > 0 then print self.get_message() + (cmd).c("+"purple".quote+") ;        command_ast = Parser.ParseCLI(cmd);        if not command_ast then continue;        runtime_result = self.run_command(command_ast, show_error);    end for;    Parser.reset();    return true;end function "

_src_compiler.body["lexer.src"] = "c0 = char(0);c33 = char(33);tp = @typeof;cs = @clear_screen;c10=function(int=1);  if not tp(int) == "+"number".quote+" or (tp(int) == "+"number".quote+" and int==1) then return char(10);  return (char(10)*int);end function;;TokenTypes = {"+"Command".quote+": "+"COMMAND".quote+", "+"Float".quote+": "+"FLOAT".quote+", "+"Macro".quote+": "+"MACRO".quote+", "+"Assign".quote+": "+"ASSIGN".quote+", "+"Flag".quote+": "+"FLAG".quote+", "+"Number".quote+": "+"NUMBER".quote+", "+"ParenOpen".quote+": "+"PARENOPEN".quote+", "+"ParenClosed".quote+": "+"PARENCLOSED".quote+", "+"BracketOpen".quote+": "+"BRACKETOPEN".quote+", "+"BracketClosed".quote+": "+"BRACKETCLOSED".quote+", "+"Comma".quote+": "+"COMMA".quote+", "+"String".quote+": "+"STRING".quote+", "+"Pipe".quote+": "+"PIPE".quote+", "+"Dot".quote+": "+"DOT".quote+", "+"Argument".quote+": "+"ARGUMENT".quote+"};;Lexer = {};Lexer.input = "+"".quote+";Lexer.position = 0;Lexer.first_token = true;Lexer.token_output = [];;Lexer.wipe = function();    self.input = "+"".quote+";    self.position = 0;    self.first_token = true;    self.token_output = [];end function;;;Lexer.get_input = function();    return self.input;end function ;;Lexer.set_input = function(new_input);    self.input = new_input;    return self.input;end function;;Lexer.consume = function();    if Lexer.get_input() == "+"".quote+" then return null;    element = Lexer.get_input()[0];    Lexer.set_input(Lexer.get_input()[1:]);    return element;end function;;Lexer.next_token = function();    ch = self.consume();    if tp(ch) == "+"null".quote+" then return null;;    if ch.is_match("+"\s".quote+") then return self.next_token() // skip whitespace;;    if ch.is_match("+"".quote+""+"".quote+"+"+"|'".quote+") then ;        quote = ch;        value = "+"".quote+";        ;         // move past the first character;        while self.position < self.input.len ;            next_char = self.consume();            ;            if next_char == quote then break ;            value = value + next_char;        end while ;;        return { "+"type".quote+": TokenTypes.String, "+"value".quote+": value };    end if ;;;    //Handle flags ;;    if ch.is_match("+"\-+".quote+") then ;        flag = ch;        temp_flag = ch;        flag_content = [];        fill_toggle = false;        ;        while self.get_input().len > 0 and (ch.is_match("+"\-+".quote+") or ch.is_match("+"[a-zA-Z0-9_]+".quote+") or ch.is_match("+"\[\S+(,\s+?\S+)*\]".quote+"));            next_char = self.consume();;            temp_flag = temp_flag + next_char;        end while ;;        return { "+"type".quote+": TokenTypes.Flag, "+"value".quote+": temp_flag };    end if ;    ;    //Handle numbers;    if ch.is_match("+"\d".quote+") then ;        number = ch;        //if ch == "+" ".quote+" and number.len > 1 then return { "+"type".quote+": TokenTypes.Float, "+"value".quote+": number };        ;        while self.get_input().len > 0 and ch.is_match("+"\d|\.".quote+");            next_number = self.consume();            if tp(("+"abcdefghigklmnopqrstuv".quote+" + "+"abcdefghigklmnopqrstuv ".quote+".upper).values.indexOf(next_number)) == "+"number".quote+" then break;            number = number + next_number;        end while;        ;        return { "+"type".quote+": TokenTypes.Float, "+"value".quote+": number };    end if;;    //Handle commands;    if ch.is_match("+"[a-zA-z_]".quote+") or ch.is_match("+"\/".quote+") then ;;        keyword = ch;        ;        while self.get_input().len > 0 and (self.get_input()[self.position].is_match("+"[a-zA-Z0-9_]".quote+") or self.get_input()[self.position].is_match("+"\/".quote+") or self.get_input()[self.position].is_match("+"\.".quote+"));			keyword = keyword + self.consume();        end while ;;        if self.first_token then ;            self.first_token = false ;            //print { "+"type".quote+": TokenTypes.Command, "+"value".quote+": keyword };            return { "+"type".quote+": TokenTypes.Command, "+"value".quote+": keyword };        end if ;        //print{ "+"type".quote+": TokenTypes.Argument, "+"value".quote+": keyword };        return { "+"type".quote+": TokenTypes.Argument, "+"value".quote+": keyword };    end if;;    //Handle punctuation (including comma for argument separation);    if tp("+"(){}=,|".quote+".values.indexOf(ch)) == "+"number".quote+" then self.consume();    if ch == "+"(".quote+" then return { "+"type".quote+": TokenTypes.ParenOpen, "+"value".quote+": ch };    if ch == "+")".quote+" then return { "+"type".quote+": TokenTypes.ParenClosed, "+"value".quote+": ch };    if ch == "+"{".quote+" then return { "+"type".quote+": TokenTypes.BracketOpen, "+"value".quote+": ch };    if ch == "+"}".quote+" then return { "+"type".quote+": TokenTypes.BracketClosed, "+"value".quote+": ch };    if ch == "+"=".quote+" then return { "+"type".quote+": TokenTypes.Assign, "+"value".quote+": ch };    if ch == "+",".quote+" then return { "+"type".quote+": TokenTypes.Comma, "+"value".quote+": ch };    if ch == "+"|".quote+" then return { "+"type".quote+": TokenTypes.Pipe, "+"value".quote+": ch };    //if ch.is_match("+"\.".quote+") then return { "+"type".quote+": TokenTypes.Dot, "+"value".quote+": ch };;    return true; //unexpected token;end function;;Lexer.Tokenize = function() ;    self.token_output.push(self.next_token());    if tp(self.token_output[-1]) == "+"null".quote+" then ;        self.token_output = self.token_output[:-1];        return self.token_output.clean([true]);    end if ;    if self.token_output[-1] == true then self.token_output = self.token_output[:-1];	return self.Tokenize();end function;"

_src_compiler.body["json.src"] = "JSON={};JSON.write=function(map=false);	desc="+"<color=purple><b>JSON.write: this function takes any map object and parses it into a string in JSON format. does not support maps objects containing functions.".quote+";	if map == "+"help".quote+" then exit(desc);	if typeof(map) != "+"map".quote+" then return "+"<color=red>inputed arg '".quote+"+map+"+"' is not a map.".quote+";	if map=={} then return "+"{".quote+"+c10+"+"}".quote+";  concat=function(num, str);return (str*num);end function;  this={};  this.toStr=function(string);return "+"".quote+""+"".quote+"+string+"+"".quote+""+"".quote+";end function;  this.pair=function(key,value,extra=false);if not extra then return key+"+": ".quote+"+value+"+",".quote+" else return key+"+": ".quote+"+value;end function;  this.result=["+"{".quote+"];	this.transform=function(map);	 this.toggle=false;this.ind=-1;	 list=map.indexes;    for i in map;			this.ind=this.ind+1;			if this.ind == list.len-1 then this.toggle=true;			if typeof(i.key) == "+"string".quote+" then i.key=self.toStr(i.key);      if [(typeof(i.key) == "+"list".quote+"), (typeof(i.key) == "+"map".quote+"), (typeof(i.key) == "+"function".quote+")].indexOf(true) != null then continue;      if typeof(i.value) == "+"string".quote+" and this.result.indexOf(self.pair(i.key , self.toStr(i.value), this.toggle)) == null then ;self.result.push(self.pair(i.key , self.toStr(i.value), this.toggle));continue;end if;      if typeof(i.value) == "+"number".quote+" and this.result.indexOf(self.pair(i.key , i.value, this.toggle)) == null then ;self.result.push(self.pair(i.key , i.value, this.toggle));continue;end if;      if typeof(i.value) == "+"list".quote+" then;temp=[];for ide in i.value;if typeof(ide) == "+"map".quote+" then continue;temp.push(ide);end for;if self.result.indexOf(self.pair(i.key , temp, this.toggle)) == null then self.result.push(self.pair(i.key , temp, this.toggle));continue;end if;      if typeof(i.value) == "+"map".quote+" then ;self.result.push(i.key+"+": {".quote+");this.transform(i.value);continue;end if;    end for;    this.result.push("+"}".quote+");  end function;  this.transform(map);  indent=0;  newResult=[];  for i in this.result;    v=i.split("+": ".quote+")[0];    line=i.split("+": ".quote+");    if line.len == 1 and v == "+"{".quote+" then ;newResult.push(concat(indent, "+" ".quote+")+i);indent=indent+2;continue;end if;		if line.len == 1 and line[0].search("+"}".quote+") then ;indent=indent-2;newResult.push(concat(indent, "+" ".quote+")+i);continue;end if;    if line.len > 1 and line[1].search("+"{".quote+") then ;newResult.push(concat(indent, "+" ".quote+")+i);indent=indent+2;continue;end if;		newResult.push(concat(indent, "+" ".quote+")+i);  end for;  this.result=newResult.join(c10);  return this.result;end function;JSON.read=function(string="+"{}".quote+");  desc="+"<color=red><b>JSON.read: this function takes a serialized map and reverts it back to a usable map object.".quote+";  if string == "+"help".quote+" then exit(desc);  if (tp(string) != "+"string".quote+") then return "+"<color=red>inputed arg '".quote+"+string+"+"' is not a string.".quote+";  if string == "+"{}".quote+" or string=="+"{".quote+"+c10+"+"}".quote+" or string.values.clean(["+" ".quote+", "+"".quote+"]).len==0 then return {};  if string[0]!="+"{".quote+" then string="+"{".quote+"+string;  if string[-1] != "+"}".quote+" then string=string+"+"}".quote+";  get_indent=function(string);count=0;while string[0]=="+" ".quote+";string=string[1:];count=count+1;end while;return count;end function;	group_it=function(input_list);		l=[];ignore=0;temp=input_list;		if temp[0] == "+"{".quote+" then temp=temp[1:];		while temp.len > 0;			i=temp.pull;			if ignore>0 then ;ignore=ignore-1;continue;end if;			if i.search("+": {".quote+") and get_indent(i) == 2 then;				ind2=temp.indexOf("+"  }".quote+");				newl=temp[0:ind2];				while i[0] == "+" ".quote+";i=i[1:];end while;				l.push([i]+newl);				ignore=newl.len;				continue;			end if;			l.push(i);		end while;		return l;	end function;  compile=function(mainl, gll, indent=4);ignore=0;		get_indent=function(s);count=0;while s[0]=="+" ".quote+";s=s[1:];count=count+1;end while;return count;end function;		recursive_build=function(list, pouch);			ignore=0;			if not list.len then return pouch;			while list.len > 0;				i=list.pull;				if ignore > 0 then ;ignore=ignore-1;continue;end if;				if i.search("+": {".quote+") then;					if i.search("+": {}".quote+") then; pouch.push([i[:-1]]) ;continue;end if;					ind2=list.indexOf(("+" ".quote+"*get_indent(i))+"+"}".quote+");					newl=list[0:ind2];					ignore=newl.len;					while i[0] == "+" ".quote+";i=i[1:];end while;					pouch.push(recursive_build(newl, [i]));					if pouch[-1] == [] then pouch[-1].pop;					continue;				end if;				while i[0] == "+" ".quote+";i=i[1:];end while;				if i[-1] == "+",".quote+" then i=i[:-1];				if i.search("+"}".quote+") then continue;				pouch.push(i);			end while;			return pouch;		end function;		check_nested=function(list);if list.join("+"".quote+").search("+": {".quote+") then return true;return false;end function;		for i in mainl;			if tp(i) == "+"list".quote+" then//["+"foo: {".quote+", ["+"bar: {".quote+"]] == {..."+"foo".quote+": {"+"bar".quote+":{}}...};				if not check_nested(i[1:]) then; gll.push(compile(i[1:], [i[0]])) ;continue;end if;				gll.push(recursive_build(i[1:], [i[0]]));				continue;			end if;			if tp(i) == "+"string".quote+" and i.search("+": {}".quote+") then; gll.push([i[:-1]]) ;continue;end if;			if i.split("+": ".quote+").len < 2 then continue;			gll.push(i);		end for;		return gll;  end function;	inputClean=function(l);ll=[];for i in l;if i == "+" ".quote+" or i == "+"".quote+" then continue;ll.push(i);end for;return ll;end function;  main=inputClean(string.split(c10));  glm={};  get_str=function(str);news="+"".quote+";for i in str;if i == "+"".quote+""+"".quote+" then continue;news=news+i;end for;return news;end function;  get_head=function(str);if tp(str.to_int) == "+"number".quote+" then return str.to_int;return get_str(str);end function;  parse=function(mainl, input_map, fp=1)//this function is recursive;		if fp then fp=0;		if not mainl.len then return input_map;		for i in mainl;			while i[0] == "+" ".quote+";i=i[1:];end while;			if i[-1] == "+",".quote+" then i=i[:-1];			if tp(i) == "+"list".quote+" then;				if not i.len then continue;				head=get_head(i[0].split("+": ".quote+")[0]);if tp(head.to_int) == "+"number".quote+" then head=head.to_int;				newl=i[1:];				input_map[head]=parse(newl, {}, 0);				continue;      end if;			if not i.split("+": ".quote+").len > 1 then continue;      head=get_head(i.split("+": ".quote+")[0]);tail=i.split("+": ".quote+")[1];			if tp(head) != "+"number".quote+" and tp(head.to_int) == "+"number".quote+" then head=head.to_int;			if tail.search("+"[".quote+") then;				temp=i.split("+": ".quote+")[-1];				temp=temp.replace("+"\[".quote+", "+"".quote+");temp=temp.replace("+"\]".quote+", "+"".quote+");				chain=temp.split("+", ".quote+");newl=[];ignore=0;				for ide in chain;					if ide.search("+"[]".quote+") then ;newl.push([]);continue;end if;					if ide.search("+"]".quote+") then ;ignore=0;continue;end if;					if ignore then continue;					if ide.search("+"".quote+""+"".quote+") then ;newl.push(get_str(ide));continue;end if;					if not ide.search("+"".quote+""+"".quote+") and tp(ide.to_int)=="+"number".quote+" then ;newl.push(ide.to_int);continue;end if;					if not ide.search("+"".quote+""+"".quote+") and tp(ide.to_int)!="+"number".quote+" then;if ide=="+"true".quote+" then;newl.push(1);else if ide=="+"false".quote+" then;newl.push(0);else;newl.push(ide);end if;continue;end if;					if ide.search("+"[".quote+") then ignore=1;				end for;				input_map[head]=newl;				continue;			end if;      if tail.search("+"".quote+""+"".quote+") then;if get_str(tail)=="+"true".quote+" then input_map[head]=1;if get_str(tail)=="+"false".quote+" then input_map[head]=0;if tail.search("+"".quote+""+"".quote+") then input_map[head]=get_str(tail);continue;end if;			if not tail.search("+"".quote+""+"".quote+") and tp(tail.to_int)=="+"number".quote+" then ;input_map[head]=tail.to_int;continue;end if;			if not tail.search("+"".quote+""+"".quote+") and tp(tail.to_int) != "+"number".quote+" then;				if tail=="+"true".quote+" then;input_map[head]=1;else if tail == "+"false".quote+" then;input_map[head]=0;else;input_map[head]=tail;end if;				continue;			end if;		end for;		return input_map;  end function;	raw_compile=group_it(main);	glm=parse(compile(raw_compile, []), {});	//print glm;  return glm;end function;//testf=hc.File("+"/root/blackbox/db/.exploit/.exploit-1".quote+");//print testf.get_content+c10+c10;//JSON.read(testf.get_content);//exit;//json.so;"

_src_compiler.body["dict.src"] = "String={};String.capitalize=function(string);  if tp(string) == list then string=string.join("+"".quote+");  if string.len<2 then return string.upper;  string=string[0].upper+string[1:].lower//;print("+"string:".quote+" +string);  return string;end function;String.strip=function(t,s);  if not t then return "+"".quote+";  for b in range(0,t.len-1);    if s.indexOf(t[b])==null then break;  end for;  if s.indexOf(t[b])>=0 then return "+"".quote+";  for e in range(-1,-1*t.len);    if s.indexOf(t[e])==null then break;  end for;  if e==-1 then return t[b:];  return t[b:e+1];end function;// pwgen v0.4 author unkown, modifications by Plu70;PasswordGenerator={};PasswordGenerator.PASSWORDSB="+"fifteen,abgDw32fhGu58k,sfuzzer,1111,2222,3333,00000,4444,5555,55555555,4fb426abgDw32fHG,6666,thx1138,7777,8888,9999,0000,oicu812,1337,8008,4hpu79htgbr,80085,007007,43110,69696969,t23t49k21af3,evkfdhgbv78ery,6h057,h4ck,h4ckg4m3,g01ng,p0st4l,g01ngp0st4l,81rd,7074g,35sk1m0,pr0n,n00b,nu8,suxor,hazorz,5uxzorz,owned,pwnd,0wnd,p0wn3d,w00t,woo7,woot,w007,10100111001,teh,meh,lol,brb,afk,wyd,gtfo,lmao,lmfao,gitgud,lawl,troll,bawl,epic,54321,987654321,88888888,555555,1234567890,1973,147147,151515,1515,101010,202020,21122112,12341234,74lk,dir7y,53nP4I,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,1,2,3,4,5,6,7,8,9,0,le375p34k,420420,11111111,112233,h4f4jf53fk74,123abc,1234qwer,123321,5y4hpu79htgbrub,ncc1701e,7777777,51505150,000000,5150,222222,999999,252525,77777777,98765432,poop,polyamorous,zelda,password,6gtr43,123456,12345678,1234,qwerty,12345,dragon,baseball,football,letmein,monkey,696969,abc123,mustang,michael,shadow,master,jennifer,111111,2000,jordan,superman,harley,1234567,hunter,trustno1,ranger,buster,thomas,tigger,robert,soccer,batman,test,pass,hockey,george,charlie,andrew,michelle,love,sunshine,jessica,6969,pepper,daniel,access,123456789,654321,joshua,maggie,starwars,silver,william,dallas,yankees,123123,ashley,666666,hello,amanda,orange,biteme,freedom,computer,sexy,thunder,nicole,ginger,heather,hammer,summer,corvette,taylor,swift,austin,1111,merlin,matthew,121212,golfer,cheese,princess,martin,chelsea,patrick,richard,diamond,yellow,bigdog,secret,asdfgh,sparky,cowboy,camaro,anthony,matrix,falcon,iloveyou,bailey,guitar,jackson,purple,scooter,phoenix,aaaaaa,morgan,tigers,porsche,mickey,maverick,cookie,nascar,peanut,justin,131313,money,horny,samantha,panties,steelers,joseph,snoopy,boomer,whatever,iceman,smokey,gateway,dakota,cowboys,eagles,chicken,black,zxcvbn,please,pharoa,andrea,ferrari,knight,hardcore,porn,ass,love,sex,hooker,blow,coke,melissa,compaq,coffee,booboo,bitch,johnny,bulldog,xxxxxx,welcome,james,player,ncc1701,wizard,scooby,charles,junior,internet,mike,brandy,tennis,banana,monster,spider,lakers,miller,rabbit,enter,mercedes,brandon,steven,fender,john,yamaha,diablo,chris,boston,tiger,marine,chicago,rangers,gandalf,winter,bigtits,barney,edward,raiders,porn,badboy,blowme,spanky,bigdaddy,johnson,chester,london,midnight,blue,fishing,hannah,slayer,rachel,sexsex,redsox,asdf,marlboro,panther,zxcvbnm,arsenal,oliver,qazwsx,mother,victoria,jasper,angel,david,winner,crystal,golden,butthead,viking,jack,iwantu,shannon,murphy,angels,prince,cameron,girls,madison,wilson,carlos,hooters,willie,startrek,captain,maddog,jasmine,butter,booger,angela,golf,lauren,rocket,tiffany,theman,dennis,liverpoo,flower,forever,green,jackie,muffin,turtle,sophie,danielle,redskins,toyota,jason,sierra,winston,debbie,giants,packers,newyork,jeremy,casper,bubba,dracula,sandra,lovers,mountain,united,cooper,driver,tucker,helpme,pookie,lucky,maxwell,8675309,bear,suckit,gators,shithead,jaguar,monica,fred,happy,hotdog,tits,gemini,lover,xxxxxxxx,777777,canada,nathan,victor,florida,nicholas,rosebud,metallic,doctor,trouble,success,stupid,tomcat,warrior,peaches,apples,fish,qwertyui,magic,buddy,dolphins,rainbow,gunner,987654,freddy,alexis,braves,2112,1212,xavier,dolphin,testing,bond007,member,calvin,voodoo,7777,samson,alex,apollo,fire,tester,chess,walter,beavis,voyager,peter,porno,bonnie,rush2112,beer,apple,scorpio,jonathan,skippy,sydney,scott,red123,power,gordon,travis,beaver,star,flyers,232323,zzzzzz,steve,rebecca,scorpion,doggie,legend,ou812,yankee,blazer,bill,runner,birdie,bitches,parker,topgun,asdfasdf,heaven,viper,animal,bigboy,arthur,baby,private,godzilla,donald,williams,lifehack,phantom,dave,rock,august,sammy,cool,brian,platinum,jake,bronco,paul,mark,frank,heka6w2,copper,billy,cumshot,garfield,willow,cunt,little,carter,slut,albert,kitten,super,jordan23,eagle1,shelby,america,11111,jessie,house,free,chevy,bullshit,white,broncos,horney,surfer,nissan,saturn,airborne,elephant,marvin,shit,action,adidas,qwert,kevin,1313,explorer,walker,police,christin,december,benjamin,wolf,sweet,therock,king,online,brooklyn,teresa,cricket,sharon,dexter,racing,penis,gregory,0000,teens,redwings,dreams,michigan,hentai,magnum,87654321,nothing,donkey,trinity,digital,333333,ramsesii,stella,cartman,guinness,speedy,buffalo,kitty,pimpin,eagle,einstein,kelly,nelson,nirvana,vampire,xxxx,playboy,louise,pumpkin,snowball,test123,girl,sucker,mexico,beatles,fantasy,ford,gibson,celtic,marcus,cherry,cassie,888888,natasha,sniper,chance,genesis,hotrod,reddog,alexande,college,jester,passw0rd,smith,lasvegas,carmen,slipknot,death,kimberly,1q2w3e,eclipse,1q2w3e4r,stanley,samuel,drummer,homer,montana,music,aaaa,spencer,jimmy,carolina,colorado,creative,hello1,rocky,goober,friday,AceofSpades,bollocks,scotty,abcdef,bubbles,hawaii,asakista,fluffy,mine,stephen,horses,thumper,darkness,asdfghjk,pamela,boobies,buddha,vanessa,sandman,naughty,douglas,honda,matt,azerty,6666,shorty,money1,beach,loveme,4321,simple,poohbear,444444,badass,destiny,sarah,denise,vikings,lizard,melanie,assman,sabrina,nintendo,water,good,howard,time,123qwe,november,xxxxx,october,zxcv,shamrock,atlantis,warren,wordpass,julian,mariah,rommel,1010,harris,predator,sylvia,massive,cats,sammy1,mister,stud,marathon,rubber,ding,trunks,desire,montreal,justme,faster,kathleen,irish,1999,bertha,jessica1,alpine,sammie,diamonds,tristan,swinger,shan,stallion,pitbull,letmein2,roberto,ready,april,palmer,ming,shadow1,audrey,chong,clitoris,wang,shirley,jackoff,bluesky,sundance,renegade,hollywoo,bernard,wolfman,soldier,picture,pierre,ling,goddess,manager,nikita,76hj93DB3wsa2,sweety,titans,hang,fang,ficken,niners,bottom,bubble,hello123,ibanez,webster,sweetpea,stocking,freeman,french,mongoose,speed,dddddd,hong,henry,hungry,yang,catdog,cheng,ghost,gogogo,randy,tottenha,curious,butterfl,mission,january,singer,sherman,shark,techno,lancer,lalala,autumn,chichi,orion,trixie,clifford,delta,bobbob,bomber,holden,kang,kiss,1968,spunky,liquid,mary,beagle,granny,network,bond,kkkkkk,millie,biggie,beetle,teacher,susan,toronto,anakin,genius,dream,dang,bush,nyx".quote+".split("+",".quote+");PasswordGenerator.PASSWORDSA="+"323232,osint,msfconsole,Bd5gHie89YA,tornado,lindsey,content,bruce,buck,aragorn,griffin,chen,campbell,trojan,christop,newman,wayne,tina,rockstar,father,geronimo,pascal,crimson,brooks,hector,penny,anna,camera,chandler,fatcat,lovelove,cody,cunts,waters,stimpy,finger,cindy,wheels,viper1,latin,robin,greenday,creampie,brendan,hiphop,willy,snapper,funtime,duck,trombone,adult,cotton,cookies,kaiser,mulder,westham,latino,jeep,ravens,aurora,drizzt,madness,hermit,energy,kinky,314159,leather,bastard,young,,extreme,hard,password1,vincent,lacrosse,hotmail,spooky,amateur,alaska,badger,paradise,maryjane,soup,crazy,mozart,video,russell,vagina,spitfire,anderson,norman,otaku,eric,cherokee,cougar,barbara,long,family,horse,enigma,allison,raider,brazil,blonde,jones,55555,dude,drowssap,jeff,school,marshall,lovely,1qaz2wsx,jeffrey,caroline,franklin,booty,molly,snickers,leslie,nipples,courtney,diesel,rocks,eminem,westside,suzuki,daddy,passion,hummer,ladies,Azachary,frankie,elvis,reggie,alpha,suckme,simpson,patricia,pirate,tommy,semperfi,jupiter,redrum,freeuser,wanker,stinky,ducati,paris,natalie,babygirl,bishop,windows,spirit,tiktok,thot,pantera,monday,patches,brutus,houston,smooth,penguin,marley,forest,cream,212121,flash,maximus,nipple,bobby,bradley,vision,pokemon,champion,fireman,indian,softball,picard,system,clinton,cobra,enjoy,lucky1,claire,claudia,boogie,timothy,marines,security,dirty,admin,wildcats,pimp,dancer,hardon,veronica,abcd1234,abcdefg,ironman,wolverin,remember,great,freepass,bigred,squirt,justice,francis,hobbes,kermit,pearljam,mercury,domino,9999,denver,brooke,rascal,hitman,mistress,simon,tony,bbbbbb,friend,peekaboo,naked,budlight,electric,sluts,stargate,saints,bondage,brittany,bigman,zombie,swimming,duke,qwerty1,babes,scotland,disney,rooster,brenda,mookie,swordfis,candy,duncan,olivia,hunting,blink182,alicia,8888,samsung,bubba1,whore,virginia,general,passport,aaaaaaaa,erotic,liberty,arizona,jesus,abcd,newport,skipper,rolltide,balls,happy1,galore,christ,weasel,242424,wombat,digger,classic,bulldogs,poopoo,accord,popcorn,turkey,jenny,amber,bunny,mouse,titanic,liverpool,dreamer,everton,friends,chevelle,carrie,gabriel,psycho,nemesis,burton,pontiac,connor,eatme,lickme,roland,cumming,mitchell,ireland,lincoln,arnold,spiderma,patriots,goblue,devils,eugene,empire,asdfg,cardinal,brown,shaggy,froggy,qwer,kawasaki,kodiak,people,phpbb,light,kramer,chopper,hooker,honey,whynot,lisa,baxter,adam,snake,ncc1701d,qqqqqq,airplane,britney,avalon,sandy,sugar,sublime,stewart,wildcat,raven,scarface,elizabet,123654,trucks,wolfpack,lawrence,raymond,american,alyssa,bambam,movie,woody,shaved,snowman,tiger1,chicks,raptor,1969,stingray,shooter,france,stars,madmax,kristen,sports,jerry,789456,garcia,simpsons,lights,ryan,looking,chronic,alison,hahaha,packard,hendrix,perfect,service,spring,srinivas,spike,katie,oscar,brother,bigmac,suck,single,cannon,georgia,popeye,tattoo,texas,party,bullet,taurus,sailor,wolves,panthers,japan,strike,flowers,pussycat,chris1,loverboy,berlin,sticky,marina,tarheels,fisher,russia,connie,wolfgang,testtest,mature,bass,catch22,juice,michael1,159753,women,alpha1,trooper,hawkeye,head,freaky,dodgers,pakistan,machine,pyramid,vegeta,katana,moose,tinker,coyote,infinity,inside,letmein1,bang,control,hercules,morris,james1,tickle,outlaw,browns,billybob,pickle,test1,michele,antonio,sucks,pavilion,changeme,caesar,prelude,tanner,adrian,darkside,bowling,wutang,sunset,robbie,alabama,danger,zeppelin,juan,rusty,pppppp,nick,2001,ping,darkstar,madonna,qwe123,bigone,casino,cheryl,charlie1,mmmmmm,integra,wrangler,apache,tweety,qwerty12,bobafett,simone,none,business,sterling,trevor,transam,dustin,harvey,england,2323,seattle,ssssss,rose,harry,openup,pandora,trucker,wallace,indigo,storm,malibu,weed,review,babydoll,doggy,dilbert,pegasus,joker,catfish,flipper,valerie,herman,detroit,kenneth,cheyenne,bruins,stacey,smoke,joey,seven,marino,fetish,xfiles,wonder,stinger,pizza,babe,pretty,stealth,manutd,gracie,gundam,cessna,longhorn,presario,mnbvcxz,wicked,mustang1,victory,shelly,awesome,athena,q1w2e3r4,help,holiday,knicks,street,redneck,casey,gizmo,scully,dragon1,devildog,triumph,eddie,bluebird,shotgun,peewee,hubris,ronnie,angel1,daisy,special,metallica,madman,country,impala,lennon,roscoe,omega,access14,enterpri,miranda,search,smitty,blizzard,unicorn,tight,rick,ronald,asdf1234,harrison,trigger,truck,danny,home,winnie,beauty,thailand,cadillac,castle,tyler,bobcat,buddy1,sunny,stones,asian,freddie,chuck,butt,loveyou,norton,hellfire,hotsex,indiana,short,panzer,lonewolf,trumpet,colors,blaster,12121212,fireball,logan,precious,aaron,elaine,jungle,masamune,atlanta,gold,corona,curtis,nikki,polaris,timber,theone,baller,chipper,orlando,island,skyline,dragons,dogs,benson,licker,goldie,engineer,kong,pencil,basketba,open,hornet,world,linda,barbie,chan,farmer,valentin,indians,larry,redman,foobar,travel,morpheus,bernie,target,141414,hotstuff,photos,laura,savage,holly,rocky1,dollar,turbo,design,newton,hottie,moon,blondes,4128,lestat,avatar,future,goforit,random,abgrtyu,jjjjjj,q1w2e3,smiley,goldberg,express,zipper,wrinkle1,stone,andy,babylon,dong,powers,consumer,dudley,Aster,monkey1,serenity,samurai,99999999,skeeter,lindsay,joejoe,master1,aaaaa,chocolat,christia,birthday,stephani,tang,alfred,ball,maria,sexual,maxima,sampson,buckeye,highland,kristin,seminole,reaper,bassman,nugget,lucifer,airforce,nasty,watson,warlock,2121,philip,always,dodge,chrissy,burger,bird,snatch,missy,pink,gang,maddie,holmes,huskers,piglet,photo,joanne,hamilton,dodger,paladin,christy,chubby,buckeyes,hamlet,abcdefgh,bigfoot,sunday,manson,goldfish,garden,deftones,icecream,blondie,spartan,julie,harold,charger,brandi,stormy,sherry,pleasure,juventus,rodney,galaxy,holland,escort,zxcvb,planet,jerome,wesley,blues,song,peace,david1,1966,cavalier,gambit,karen,sidney,ripper,jamie,sister,marie,martha,nylons,aardvark,nadine,minnie,whiskey,bing,plastic,anal,babylon5,chang,savannah,loser,racecar,insane,yankees1,mememe,hansolo,chiefs,fredfred,freak,frog,salmon,concrete,yvonne,sophia,stefan,8a1n80w,slick,rocker,opensesame,onessnap".quote+".split("+",".quote+");PasswordGenerator.PASSWORDS = PasswordGenerator.PASSWORDSA + PasswordGenerator.PASSWORDSB;PasswordGenerator.init=function(samples);  self.s=[];  self.c={};  for string in samples;    string=string.trim.upper;    if string.len>3 then self.s.push(string);  end for;  for string in self.s;    for ind in range(0,string.len-4);      k=string[ind:ind+3];      if self.c.hasIndex(k) then;        if self.c[k].indexOf(string[ind+3])==null then self.c[k].push(string[ind+3]);      else;        self.c[k]=[string[ind+3]];      end if;    end for;  end for;end function;PasswordGenerator.r=function(length,snip,object);  suffix=snip[snip.len-3:];  if self.c.hasIndex(suffix) and snip.len<length then;    for char in self.c[suffix];      self.r(length,(snip+char),object);    end for;  else;    object[snip]=1;  end if;end function;PasswordGenerator.AllPasswords=function();  r={};  for string in self.s;    for i in range(0,string.len-4);      self.r(string.len,string[i:(i+3)],r);    end for;  end for;  sub=[];final=[];final2=[];  for s in r.indexes;    if sub.indexes.len == 3 then ;o=o+sub;sub={}; end if;    s=inputClean(s);    if s.indexOf("+"".quote+")>=0 then;    n=s.split("+"".quote+");    for i in range(0,n.len-1);    n[i]=String.capitalize(n[i]);    end for;s=n.join("+"".quote+");    else;    s=String.capitalize(s);    end if;    if s.len<5 then continue;    a=s[0];    b=s[1];    if a.lower==b or "+"hrl'aeiou".quote+".indexOf(b)==null and "+"AEIOUS".quote+".indexOf(a)==null and [Ch,Mc].indexOf(a+b)==null then s=String.capitalize(s[1:]);    s=String.strip(s,"+"'-".quote+");    sub.push(s);    sub.push(s.lower);    str_len=str(sub.len);    if str_len.len > 3 and str_len[-3:].search(000) then ;final.push(sub);final2=final2+sub;sub=[];continue;end if;  end for;  return final;end function;//PasswordGenerator.init(PasswordGenerator.PASSWORDS);//dict.so"

_src_compiler.body["internal.src"] = "Directory = {};;Directory.find_file_memory = [];;Directory.find_file = function(file_obj, file_path = 0, file_name = 0, return_all = 0, is_first_pass = 1);    if is_first_pass then ;        if file_path == "+"".quote+" then file_path = "+"/".quote+";        find_file_memory = [];        is_first_pass = 0 ;    end if ;;    if tp(file_path) == "+"string".quote+" and file_path == "+"/".quote+" then return file_obj;    if tp(file_path) == "+"string".quote+" and file_path[0] != "+"/".quote+" then file_path = "+"/".quote+" + file_path;    if tp(file_path) == "+"string".quote+" and file_path[-1] == "+"/".quote+" then file_path = path[:-1];    if tp(file_path) == "+"string".quote+" then file_path = file_path.lower;    if tp(file_name) == "+"string".quote+" then file_name = file_name.lower;;    target_file = false;;    for object in file_obj.get_folders + file_obj.get_files;        if tp(object) != "+"file".quote+" then continue;        if not return_all and tp(target_file) == "+"file".quote+" then ;            self.find_file_memory = [];            return target_file;        end if ;        ;        if return_all and [file_path, file_name] == [0, 0] then ;            self.find_file_memory.push([object, object.name, object.get_content, {"+"is_folder".quote+": object.is_folder, "+"is_binary".quote+": object.is_binary}, object.size, object.permissions, object.owner, object.group]);            continue ;        end if ;;        if (return_all and tp(file_name) == "+"string".quote+") and object.name.lower == file_name.lower then ;            self.find_file_memory.push([object, object.name, object.get_content, {"+"is_folder".quote+": object.is_folder, "+"is_binary".quote+": object.is_binary}, object.size, object.permissions, object.owner, object.group]);            continue;        end if ;;        if (tp(file_path) == "+"string".quote+" and not return_all) and object.path.lower == file_path.lower then ;            target_file = object ;            continue;        end if ;        ;        if (tp(file_name) == "+"string".quote+" and not return_all) and object.name.lower.search(file_name) then ;            target_file = object ;            continue;        end if ;;        if ([file_path, file_name, return_all] == [0, 0, 0]) then ;            self.find_file_memory.push([object, object.name, object.path, object.get_content, {"+"is_folder".quote+": object.is_folder, "+"is_binary".quote+": object.is_binary}, object.size, object.permissions, object.owner, object.group]);            continue;        end if ;        if object.is_folder then target_file = self.find_file(object, file_path, file_name, return_all, is_first_pass);    end for ;;    if ([file_path, file_name, return_all] == [0, 0, 0]) or return_all then return self.find_file_memory;    self.find_file_memory = [] ;   ;    return target_file;end function;;Directory.validate_file = function(root_file, cmd_name, param_token, only_folders = 0);    param_token_value = param_token[0].value;    param_token_type = param_token[0].type;    target_file = false;    ;    is_keyword = true ;    if param_token_value.split("+"/".quote+").len > 1 then is_keyword = false;    print "+"internal 66: ".quote+"+ is_keyword ;    print "+"internal 67: ".quote+"+ param_token_value;    if not tp(root_file) == "+"file".quote+" then return _callback.catch("+"[blbx][".quote+"+cmd_name+"+"][err]: remote session has no file objects...".quote+");    ;    if is_keyword then ;        target_file = Directory.find_file(root_file, 0, param_token_value);        if not tp(target_file) == "+"file".quote+" then return _callback.catch("+"[blbx][".quote+"+cmd_name+"+"][err]: could not find target file by name...".quote+");        if not target_file.is_folder and only_folders then return _callback.catch("+"[blbx][".quote+"+cmd_name+"+"][err]: object must be a folder...".quote+");;        return _callback.catch(target_file, 1);    end if;;    target_file = Directory.find_file(root_file, param_token_value);    if not tp(target_file) == "+"file".quote+" then return _callback.catch("+"[blbx][".quote+" + cmd_name + "+"][err]: could not find target file by name...".quote+");    if not target_file.is_folder and only_folders then return _callback.catch("+"[blbx][".quote+"+cmd_name+"+"][err]: object must be a folder...".quote+");;    return _callback.catch(target_file, 1);end function ;;;Session = {};;Session.process = {};;;Session.process.safe_run = function(cmd_name, parameters, data = 0);    if tp(command.indexes.indexOf(cmd_name)) != "+"number".quote+" then return false;    command_syntax_proxy = command[cmd_name];    return command_syntax_proxy(parameters);end function;;Session.process.status = true;Session.process.connected = false;;Session.process.is_running = function();    return self.status;end function ;;Session.process.set_status = function(new_status);    self.status = new_status;    return self.status;end function;;Session.process.is_connected = function();    return self.connected;end function ;;Session.process.set_connected = function(new_connected);    self.connected = new_connected;    return self.status;end function;;Session.db = {};Session.db.items = {};Session.db.root_folder = "+"/root/blackbox/db/".quote+";;Session.db.get_path = function(table_name);    return self.root_folder + "+".".quote+" + table_name;end function;;Session.db.init_database = function(table_name);    get_shell.host_computer.touch(self.get_path(table_name), "+"init_blbx_db.json".quote+");    init_path = self.get_path(table_name) + "+"/init_blbx_db.json".quote+";    init_file = Directory.find_file(get_shell.host_computer.File("+"/".quote+"), init_path);    ;    if not tp(init_file) == "+"file".quote+" then return false;    init_file.set_content(JSON.write({"+"name".quote+": table_name, "+"entries".quote+": 0}));    ;    init_file.chmod("+"u-rwx".quote+");    init_file.chmod("+"g-rwx".quote+");    init_file.chmod("+"o-rwx".quote+");end function;;Session.db.select = function(table_name);    if table_name.split("+"/".quote+").len == 1 then table_name = self.get_path(table_name);    target_directory = Directory.find_file(get_shell.host_computer.File("+"/".quote+"), table_name);    if not tp(target_directory) == "+"file".quote+" then return false;    return target_directory;end function ;;Session.db.add_file = function(table_name);    database = self.select(table_name);    if not database then return false ;    entry_name = "+".".quote+" + table_name + "+"-".quote+" + str(database.get_files.len);    create_entry_file = get_shell.host_computer.touch(database.path, entry_name);    if not create_entry_file then return false;    check_entry = Directory.find_file(get_shell.host_computer.File("+"/".quote+"), database.path + "+"/".quote+" + entry_name);    check_entry.set_content(JSON.write({}));    return check_entry;end function;;Session.db.create = function(table_name) ;    self.init_database(table_name);    self.add_file(table_name);end function;;Session.db.parse = function(table_name);    database = self.select(table_name);    if tp(database) != "+"file".quote+" then return false ;    database = database.get_files;;    result = {};    for entry_file in database ;        if not entry_file.name.lower.search(table_name) then continue ;        result = result + JSON.read(entry_file.get_content);    end for ;    return result ;end function;;Session.db.split_map = function(map, max_size = 10000);    temp = map ;    master = {"+"0".quote+": {}};    index1 = -1;    index2 = -1;;    total_length = function();        count = 0;        for element in master.values ;            count = count + element.len ;        end for ;        return count ;    end function ;;    while not total_length() >= map.len ;        recent_child_object = master.values[-1];        index1 = index1 + 1;        if not master.hasIndex(str(index)) then ;            master[str(index)] = {} ;            continue ;        end if ;        while recent_child_object.len < max_size;            index2 = index2 + 1;            if index2 >= max_size then break ;            wait(.1);            temp_indexes = temp.indexes[:1];            temp_values = temp.values[:1];            recent_child_object[temp_indexes[0]] = temp_values[0];            temp.pop;        end while ;        index1 = index1 + 1;        master[str(index1)] = {};    end while ;    return master;end function ;;Session.db.add_to = function(incoming_data = {}, table_name);    if not incoming_data.len then return true ;    if tp(incoming_data) != "+"map".quote+" and tp(incoming_data) != "+"list".quote+" then return false;    database = self.select(table_name);    if not database then return false;    database = database.get_files;    if not database.len then self.init_database(table_name);    if database.len == 1 then ;        self.add_file(table_name);        database = self.select(table_name).get_files;    end if ;    ;    entry_file = database[-1];    entry_file.set_content(JSON.write(incoming_data));;    return true;end function ;;Session.db.reset = function(table_name);    database = self.select(table_name);    if not database then return false ;    database = database.get_files;    for entry_file in database;        if entry_file.name.lower.search("+"init_blbx_db.json".quote+") then continue ;        entry_file.delete;    end for ;    return true  ;end function ;;Session.db.set = function(incoming_data, table_name);    database = self.select(table_name);    if tp(database) != "+"file".quote+" then return false ;    if tp(incoming_data) == "+"list".quote+" then ;        incoming_data = incoming_data.combine;        if not incoming_data.len then return false;    end if ;    self.add_to(incoming_data, table_name) ;    return true;end function ;;Session.db.has_entry = function(entry, table_name);    database = self.select(table_name);    if tp(database) != "+"file".quote+" then return false ;    database = database.get_files ;    temp = {};    for entry_file in database ;        if entry.file.name.lower.search("+"init_blbx_db.json".quote+") then continue ;        temp = temp + JSON.read(file.get_content);    end for ;    if temp == {} then return false ;    if temp.hasIndex(entry) or tp(temp.indexes.indexOf(entry)) == "+"number".quote+" or tp(temp.values.indexOf(entry)) == "+"number".quote+" then return true;    return false;end function;;Session.db.has = function(table_name);    database = self.select(table_name);    if not database then return false ;    return true;end function ;;Session.db.init = function(table_name_arr);    for table_name in table_name_arr ;        database = self.select(table_name);        if not database then ;            self.create(table_name);            database = self.select(table_name);        end if ;;        if table_name == "+"dictionary".quote+" and not database.get_files.len > 1 then ;            PasswordGenerator.init(PasswordGenerator.PASSWORDS)    ;            printb(a + "+"*** building dictionary attack hash map ***".quote+".color("+"purple".quote+"));            printb(a + "+"this may take a minute".quote+".color("+"black".quote+"));            printb(a + "+"please wait".quote+".color("+"black".quote+"));            self.add_to(PasswordGenerator.AllPasswords, "+"dictionary".quote+");        end if ;    end for ;;    return true;end function;;Session.macro = {};// Session.macro.extract_db = function();;// end function ;;// Session.dict = {};// Session.dict.extract_db = function();;// end function ;;// Session.exploits = {};// Session.exploits.extract_db = function();;// end function;;Session.rpc = {} // Remote Procedure Call - look it up;Session.rpc.hand_shake = get_custom_object();;Session.rpc.get_hand_shake = function();    return self.hand_shake;end function ;;Session.rpc.wipe_hand_shake = function();    self.hand_shake = get_custom_object();    return self.hand_shake;end function ;;Session.rpc.new_hand_shake = function();    self.hand_shake = get_custom_object();    return self.hand_shake;end function ;;Session.rpc.get_access = function(file_instance);    for machine_file in file_instance.get_folders;        if machine_file.has_permission("+"w".quote+") and machine_file.has_permission("+"x".quote+") then return machine_file;;        result = self.get_access(machine_file);        if not result then continue ;        return result ;    end for ;    return false;end function ;;Session.rpc.set_endpoint = function(shell_instance, src_file_name, src_file_content);    comp_instance = shell_instance.host_computer;    file_instance = comp_instance.File("+"/".quote+");    ;    accessed_file = self.get_access(file_instance);    if not accessed_file then return _callback.catch("+"[session][rpc][endp]: no accessable directories found...".quote+");    accessed_file_path = fif((accessed_file.path == "+"/".quote+"), "+"".quote+", accessed_file.path);    src_file_name = "+".".quote+" + src_file_name ;    src_file_path = accessed_file_path + "+"/".quote+" + src_file_name;;    try_touch = comp_instance.touch(fif(accessed_file_path == "+"".quote+", "+"/".quote+", accessed_file_path), src_file_name);    if not try_touch then return _callback.catch("+"[session][rpc][endp]: failed to create '".quote+"+src_file_name+"+"', permission denied...".quote+");    touched_file = comp_instance.File(src_file_path);    if not touched_file then return _callback.catch("+"[session][rpc][endp]: source file '".quote+"+src_file_name+"+"' created but not found...".quote+");    touched_file.set_content(src_file_content.split("+";".quote+").join(char(10)));    ;    store = shell_instance.build(touched_file.path, fif((accessed_file_path == "+"".quote+"), "+"/".quote+", accessed_file_path));;    binary_name = src_file_name[:-4] // removes '.src';    if tp(store) == "+"string".quote+" and store.len > 0 then return _callback.catch("+"[session][rpc][endp]: ".quote+" + store);    binary_file = comp_instance.File(accessed_file_path + "+"/".quote+" + binary_name);    if not tp(binary_file) == "+"file".quote+" then return _callback.catch("+"[session][rpc][endp]: binary file '".quote+"+binary_name+"+"' created but not found...".quote+");    ;    return _callback.catch(binary_file, 1);end function;;Session.rpc.src = {};Session.rpc.src.scan_nw = function();    return "+"incoming_data = get_custom_object().data;_callback = @incoming_data._callback;scan_network = function();    local_router = get_router ;    lan_address_arr = get_router.devices_lan_ip;    router_addresses = [];    count = 0;    for lan_address in lan_address_arr ;        if lan_address.split(".quote+"+"+"\.".quote+".quote+"+")[-1] == ".quote+"+"+"1".quote+".quote+"+" then ;            router_addresses.push(lan_address);            count = count + 1;            continue;        end if ;    end for ;    ;    print ;    print ".quote+"+"+"<b>".quote+".quote+"+" + ".quote+"+"+"network devices: ".quote+".quote+"+" + ".quote+"+"+"</b>".quote+".quote+"+";    print ;    print ".quote+"+"+"<b>".quote+".quote+"+" + lan_address_arr[:-count].join(char(10) + ".quote+"+"+"<b>".quote+".quote+"+");    print ;    print ".quote+"+"+"<b>".quote+".quote+"+" + ".quote+"+"+"nearby routers: ".quote+".quote+"+" + ".quote+"+"+"</b>".quote+".quote+"+";    print ;    print ".quote+"+"+"<b>".quote+".quote+"+" + router_addresses.join(char(10) + ".quote+"+"+"<b>".quote+".quote+"+");    print;    return _callback.catch({".quote+"+"+"network_devices".quote+".quote+"+": lan_address_arr[:-count], ".quote+"+"+"routers".quote+".quote+"+": router_addresses}, 1);end function ;return scan_network()".quote+";end function;Session.rpc.src.rshell = function();    return "+"incoming_object = get_custom_object();incoming_data = incoming_object.data ;_callback = @incoming_data._callback;string.search = function(sub_string = ".quote+"+"+"".quote+".quote+"+");  return tp(self.lower.indexOf(sub_string.lower)) == ".quote+"+"+"number".quote+".quote+"+";end function;tp = @typeof;Directory = @incoming_data.Directory;host_ip_address = incoming_data.host_ip_address;send_reverse_shell_instance = function(reverse_shell_host_ip);    target_library_file = Directory.find_file(get_shell.host_computer.File(".quote+"+"+"/".quote+".quote+"+"), 0, ".quote+"+"+"metaxploit.so".quote+".quote+"+");    if not target_library_file then return _callback.catch(".quote+"+"+"[blbx][rshell][err]: cannot find metaxploit.so on machine...".quote+".quote+"+");    metaxploit = include_lib(target_library_file.path);    try_rshell_client = metaxploit.rshell_client(reverse_shell_host_ip, 1222, c0);    if tp(try_rshell_client) == ".quote+"+"+"string".quote+".quote+"+" then return _callback.catch(".quote+"+"+"[blbx][rshell][err]: ".quote+".quote+"+" + try_rshell_client);    return _callback.catch(try_rshell_client, 1);end function ;result = send_reverse_shell_instance(host_ip_address).data;incoming_object.data = {".quote+"+"+"rshell".quote+".quote+"+": result};return incoming_object".quote+";end function ;Session.rpc.src.escalate = function();    return "+"incoming_data = get_custom_object().data;_callback = @incoming_data._callback;username = incoming_data.username;password = incoming_data.password;dictionary = incoming_data.dictionary ;escalate = function(_user, _dict, _pass = 0);    if _pass then ;        try_shell_login = get_shell(_user, _pass);        if typeof(try_shell_login) == ".quote+"+"+"null".quote+".quote+"+" then return _callback.catch(".quote+"+"+"[blbx][esca][err]: shell instance login attempt failed...".quote+".quote+"+");        ;        return _callback.catch(try_shell_login, 1);    end if ;    found = false ;    for password in _dict.values ;        try_shell_login = get_shell(_user, password);        if typeof(try_shell_login) == ".quote+"+"+"null".quote+".quote+"+" then continue ;        found = try_shell_login;        break;    end for ;    if not found then return _callback.catch(".quote+"+"+"[blbx][esca][err]: dictionary attack failed. password not found...".quote+".quote+"+", 0)  ;    return _callback.catch(found, 1);end function ;return escalate(username, dictionary, password)".quote+";end function ;Session.rpc.src.dictionary = function();    return "+"incoming_data = get_custom_object().data;_callback = @incoming_data._callback;username = incoming_data.username;dictionary = incoming_data.dictionary;dictionary_attack = function(_user, _dict);    found = false ;    for password in _dict.values ;        try_shell_login = get_shell(_user, password);        if typeof(try_shell_login) == ".quote+"+"+"null".quote+".quote+"+" then continue ;        found = password;        break;    end for ;    if not found then return _callback.catch(".quote+"+"+"[blbx][dict][err]: dictionary attack failed. password not found...".quote+".quote+"+", 0)  ;    print ".quote+"+"+"<b>password found: ".quote+".quote+"+" + found + ".quote+"+"+"</b>".quote+".quote+"+";    return _callback.catch(found, 1);end function ;return dictionary_attack(username, dictionary)".quote+";end function ;Session.rpc.src.bounce = function();    return "+"incoming_data = get_custom_object().data ;_callback = @incoming_data._callback;Directory = @incoming_data.Directory;Exploit = @incoming_data.Exploit;string = @incoming_data.string;Session = @incoming_data.Session;library_path = @incoming_data.library_path;database = @incoming_data.database;lan_address = @incoming_data.lan_address;notify = incoming_data.notify;hide_ip = incoming_data.hide_ip;tp = @typeof;memory_arr = [];library = Exploit.module.get_local_lib(".quote+"+"+"metaxploit.so".quote+".quote+"+")//;library = library.load(library_path);if not Exploit.module.library.get_metax() then return _callback.catch(".quote+"+"+"[expl][attack][err]: metaxploit library not found on machine...".quote+".quote+"+");if tp(Session.machine.ip.get_lan_address_arr().indexOf(Session.machine.ip.get_lan_address())) != ".quote+"+"+"number".quote+".quote+"+" then Session.machine.ip.add_lan_address(lan_address);if tp(Exploit.module.library.get_metax().rshell_server) != ".quote+"+"+"list".quote+".quote+"+" then rshell_arr = [] else rshell_arr = Exploit.module.library.get_metax().rshell_server ;exploit_map = Exploit.module.parse_exploits(library, database);memory_address_arr = exploit_map.data.indexes;saved_exploits = [];for address in memory_address_arr ;    database = Exploit.module.run_exploits(exploit_map.data[address], address, lan_address, library, lan_address, database, 0) //change_password json;end for ;print notify(".quote+"+"+"recon for ".quote+".quote+"+" + (".quote+"+"+"'".quote+".quote+"+" + hide_ip(Session.machine.ip.get_pub_address_arr()[-1])+ ".quote+"+"+"'".quote+".quote+"+").c(".quote+"+"+"black black white".quote+".quote+"+") + ".quote+"+"+" @ ".quote+".quote+"+" + (".quote+"+"+"'".quote+".quote+"+" + hide_ip(lan_address) + ".quote+"+"+"'".quote+".quote+"+").c(".quote+"+"+"black black white".quote+".quote+"+") + ".quote+"+"+" completed.".quote+".quote+"+")+c0;object = get_custom_object();object.data = {".quote+"+"+"objects".quote+".quote+"+": Session.object, ".quote+"+"+"exploits".quote+".quote+"+": database };return object".quote+";end function;;Session.rpc.data = {} // organizes RPC data for sending and recieving;;Session.rpc.data.catch = function();    return _callback.catch(get_custom_object(), 1);end function;;Session.rpc.data.send = function(shell_instance, program, program_prompt = "+"".quote+", data = {}, delete = 0);    Session.rpc.new_hand_shake().data = data;;    try_rpc = shell_instance.launch(program.path, program_prompt.trim);    if delete then program.delete;    if tp(try_rpc) == "+"string".quote+" then return _callback.catch("+"[session][rpc][send]: ".quote+" + try_rpc);    return _callback.catch(try_rpc, 1);end function;;;Session.machine = {};Session.machine.ip = {};Session.machine.ip.lan_address = "+"".quote+";Session.machine.ip.pub_address = "+"".quote+";Session.machine.ip.lan_address_arr = [];Session.machine.ip.pub_address_arr = [];;Session.machine.ip.random_ip = function();    n = function();        return floor(rnd * (255 - 0 + 1) + 0);    end function ;;    return str(n) + "+".".quote+" + str(n) + "+".".quote+" + str(n) + "+".".quote+" + str(n);end function ;;Session.machine.ip.get_lan = function();    return self.lan_address;end function;;Session.machine.ip.set_lan = function(new_lan_address);    self.lan_address = new_lan_address;    return self.lan_address;end function;;Session.machine.ip.get_pub = function();    return self.pub_address;end function ;;Session.machine.ip.set_pub = function(new_pub_address);    self.pub_address = new_pub_address;    return self.pub_address;end function ;;Session.machine.ip.add_lan_address = function(new_lan_address);    self.lan_address_arr.push(new_lan_address);    return new_lan_address;end function ;;Session.machine.ip.set_lan_address_arr = function(new_lan_address_arr);    self.lan_address_arr = new_lan_address_arr;    return self.lan_address_arr;end function ;;Session.machine.ip.get_lan_address_arr = function();    return self.lan_address_arr;end function ;;Session.machine.ip.get_lan_address = function();    return self.lan_address;end function ;;Session.machine.ip.add_pub_address = function(new_pub_address);    self.pub_address_arr.push(new_pub_address);    return new_pub_address;end function ;;Session.machine.ip.set_pub_address_arr = function(new_pub_address_arr);    self.pub_address_arr = new_pub_address_arr;    return self.pub_address_arr;end function ;;Session.machine.ip.get_pub_address_arr = function;    return self.pub_address_arr;end function ;;;Session.machine.user = {};Session.machine.user.current = {"+"name".quote+": "+"".quote+"};;Session.machine.user.get_name = function();    return self.current.name;end function;;Session.machine.user.set_name = function(new_user_name);    self.current.name = new_user_name;    return self.current.name;end function ;;Session.machine.user.wipe = function() ;    self.current = {"+"name".quote+": "+"".quote+"};end function;;Session.object = {};;Session.object.rshell = {"+"list".quote+": []};Session.object.shell = {"+"list".quote+": []};Session.object.computer = {"+"list".quote+": []};Session.object.file = {"+"list".quote+": []};;Session.parse_object = function(object_list, lan_address, as_user = 0, return_all = 0);    if not object_list.len then return false ;    user_dict = {"+"root".quote+": [], "+"guest".quote+": [], "+"unknown".quote+": [], "+"usr".quote+": []};    ;    search_sub_array = function(main_arr, search_for_str);        found = false ;        for sub_arr in main_arr ;            if sub_arr[1].lower.search(sub_arr) then found = sub_arr[1];        end for;        return false ;    end function ;    ;    for object_arr in object_list;        //if not tp(object_arr) == "+"map".quote+" or (tp(object_arr) == "+"map".quote+" and object_arr.hasIndex("+"value".quote+")) then continue;        //if not object_arr.len then continue ;        object = object_arr[0];        username = object_arr[1];        if not username then username = "+"unknown".quote+";        lanip = object_arr[2];;        if lanip != lan_address then continue;        ;        if as_user then ;            if username.lower.search(as_user.lower) then user_dict.usr.push(object);            continue;        end if;    ;        if username == "+"root".quote+" then user_dict.root.push([object, username]);        if username == "+"guest".quote+" then user_dict.guest.push([object, username]);        if username == "+"unknown".quote+" then user_dict.unknown.push([object, username]);        ;        ;        if not tp(user_dict.usr.indexOf(username)) == "+"number".quote+" then user_dict.usr.push([object, username]);    end for ;;    if not as_user and lan_address and return_all then return user_dict.root + user_dict.guest + user_dict.unknown + user_dict.usr;    if ((not as_user and lan_address) and not return_all) then;        if user_dict.root.len > 0 then return user_dict.root[0][0];        if user_dict.usr.len > 0 then return user_dict.usr[0][0];        if user_dict.unknown.len > 0 then return user_dict.unknown[0][0];        if user_dict.guest.len > 0 then return user_dict.guest[0][0];    end if ;;    if ((as_user and lan_address) and not return_all) then ;        if user_dict.root.len > 0 and as_user == "+"root".quote+" then return user_dict.root[0][0];        found = "+"".quote+";        if user_dict.usr.len > 0 and as_user then;            for user in user_dict.usr ;                if user[1].lower.search(as_user.lower) then found = user[1];            end for ;        end if ;        if found.len then return found ;        if user_dict.unknown.len > 0 then return user_dict.unknown[0][0];        if user_dict.guest.len > 0 then return user_dict.guest[0][0];    end if ;;    return false;end function;;Session.is_empty = function(object_name);    if not self.object[object_name].list.len then return true ;    return false ;end function ;;Session.get_object_arr = function(object_type);    return self.object[object_type];end function;;Session.borrow = function(object_name, lan_address, as_user = 0);    if self.is_empty(object_name) then return false;    print "+"internal 548: ".quote+"+ Exploit.device.get(lan_address);    object = self.parse_object(Exploit.device.get(lan_address)[object_name + "+"s".quote+"], lan_address, as_user);    if not object then return false ;    ;    return object;end function;;Session.allocate = function(object, lanip);    if tp(["+"shell".quote+", "+"computer".quote+", "+"file".quote+"].indexOf(tp(object)) == "+"number".quote+") then printb(tp(object).c("+"purple".quote+"));    if tp(object) == "+"shell".quote+" or tp(object) == "+"rshell".quote+" then ;        self.add(object, lanip);        self.add(object.host_computer, lanip);        self.add(object.host_computer.File("+"/".quote+"), lanip);    end if ;    if tp(object) == "+"computer".quote+" then ;        self.add(object, lanip);        self.add(object.File("+"/".quote+"), lanip);    end if ;    if tp(object) == "+"file".quote+" then ;        while object.path != "+"/".quote+" ;            object = object.parent ;        end while ;        self.add(object, lanip);    end if ;end function;;Session.get_user = function(object);    if tp(object) == "+"shell".quote+" then object = object.host_computer ;    if tp(object) == "+"computer".quote+" then object = object.File("+"/".quote+");;    if not tp(Directory.find_file(object, "+"/root".quote+")) == "+"file".quote+" then file = [Directory.find_file(object, "+"/boot/System.map".quote+"), Directory.find_file(object, "+"/home".quote+")] else file = [Directory.find_file(object, "+"/root".quote+"), Directory.find_file(object, "+"/home".quote+")]; ;    if tp(file[0]) == "+"file".quote+" and file[0].has_permission("+"w".quote+") then return "+"root".quote+";    if tp(file[1]) == "+"file".quote+" then file_list = file[1].get_folders else return false ;    users = [] ;    result = [];;    for file in file_list ;       if file.has_permission("+"w".quote+") then users.push(file.name);    end for ;;    if users.hasIndex(1) then return users[0];    if tp(users.indexOf("+"guest".quote+")) == "+"number".quote+" then return "+"guest".quote+";    return "+"unknown".quote+";end function;;Session.add = function(object, lanip);    self.object[tp(object)].list.push([object, self.get_user(object), lanip, tp(object)]);    if tp(object) == "+"shell".quote+" then return self.add(object.host_computer, lanip);    if tp(object) == "+"computer".quote+" then return self.add(object.File("+"/".quote+"), lanip);end function ;;Session.wipe = function();    self.object.number = {"+"list".quote+": []};    self.object.rshell = {"+"list".quote+": []};    self.object.shell = {"+"list".quote+": []};    self.object.comp = {"+"list".quote+": []};    self.object.file = {"+"list".quote+": []};end function;;;;;Exploit = {};;Exploit.net_session = false ;Exploit.change_password = false;Exploit.scan_library = false ;;Exploit.get_net_session = function();    return self.net_session;end function ;;Exploit.set_net_session = function(new_net_session);    self.net_session = new_net_session;end function ;;Exploit.is_change_pass = function();    return self.change_password;end function ;;Exploit.set_change_pass = function(new_pass_bool);    self.change_password = new_pass_bool;    return self.change_password;end function    ;;Exploit.is_scan_mode = function();    return self.scan_library;end function ;;Exploit.set_scan_mode = function(new_mode_bool);    self.scan_library = new_mode_bool;    return self.scan_library;end function;;Exploit.device = {};;Exploit.device.tree = {};Exploit.device.current = {};Exploit.device.user_map = {};Exploit.device.serialized_tree = "+"".quote+";;Exploit.device.wipe = function();    self.device.tree = {};    self.device.current = {};    self.device.user_map = {};    self.device.serialized_tree = "+"".quote+";end function;;Exploit.device.get_current = function();    return self.current;end function;;Exploit.device.set_current = function(new_current_device);    self.current = new_current_device;    return self.current;end function;;Exploit.device.add = function(object, lan_address);    if not self.tree.hasIndex(lan_address) then self.tree[lan_address] = {"+"shells".quote+": [], "+"rshells".quote+": [], "+"computers".quote+": [], "+"files".quote+": []};    if tp(object) == "+"shell".quote+" then ;        self.tree[lan_address].shells.push([object, Session.get_user(object), lan_address, tp(object)]);        return self.add(object.host_computer, lan_address);    end if ;    if tp(object) == "+"rshell".quote+" then self.tree[lan_address].shells.push([object, Session.get_user(object), lan_address, tp(object)]);    if tp(object) == "+"computer".quote+" then ;        self.tree[lan_address].computers.push([object, Session.get_user(object), lan_address, tp(object)]);        return self.add(object.File("+"/".quote+"), lan_address);    end if ;    if tp(object) == "+"file".quote+" then self.tree[lan_address].files.push([object, Session.get_user(object), lan_address, tp(object)]);;    return true;end function ;;Exploit.device.has = function(lan_address);    return tp(self.tree.indexes.indexOf(lan_address)) == "+"number".quote+";end function;;Exploit.device.get = function(lan_address);    if not self.has(lan_address) then return false ;    return self.tree[lan_address];end function ;;Exploit.device.add_user = function(lan_address, username);    if not self.user_map.hasIndex(lan_address) then self.user_map[lan_address] = [];    user_arr = self.user_map[lan_address];    if username and tp(user_arr.indexOf(username)) != "+"number".quote+" then user_arr.push(username.lower);    self.user_map[lan_address] = user_arr.remove_repeats    ;    return true ;end function;;Exploit.device.has_user = function(username, lan_address);    if not self.user_map.hasIndex(lan_address) then return false;    return tp(self.user_map[lan_address].indexOf(username)) == "+"number".quote+";end function ;;Exploit.device.get_user = function(username, lan_address);    full_username = false;    if not self.has_user(username, lan_address) then return false;    for user in self.device.user_map[lan_address];        if user.lower.search(username.lower) then ;            full_username = user ;            break ;        end if ;    end for ;    return full_username;end function;;Exploit.device.get_user_arr = function(lan_address);    if not self.user_map.indexes.hasIndex(lan_address) then return false ;    return self.user_map[lan_address];end function ;;Exploit.device.align_ip_addresses = function();    for lan_address in Session.machine.ip.get_lan_address_arr();        if not self.has(lan_address) then self.add(lan_address);        if not self.user_map.hasIndex(lan_address) then self.add_user(lan_address);        ;        for obj in Session.object.shell.list + Session.object.computer.list + Session.object.file.list;            if lan_address != obj[2] then continue;            username = obj[1];            object = obj[0];;            if not self.has_user(username, lan_address) then self.add_user(lan_address, username);            if tp(object) == "+"shell".quote+" then Session.machine.ip.set_pub(object.host_computer.public_ip) ;            if tp(object) == "+"computer".quote+" then Session.machine.ip.set_pub(object.public_ip);        end for  ;    end for ;end function ;;Exploit.device.show_tree = function();    add_line;    printb(bar(30));    add_line;    printb(("+" public address: ".quote+".c("+"black".quote+") + Session.machine.ip.get_pub()).c("+"purple".quote+"));    add_line;    for lan_address in self.user_map.indexes;        printb("+"  lan address: ".quote+".c("+"black".quote+") + lan_address.c("+"purple".quote+"));        add_line;        for user in self.user_map[lan_address];            printb(("+"   user: ".quote+".c("+"black".quote+") + user).c("+"purple".quote+"));        end for;        if Exploit.device.has(lan_address) and Exploit.device.get(lan_address) then shells = Exploit.device.get(lan_address).shells else shells = 0;        if Exploit.device.has(lan_address) and Exploit.device.get(lan_address) then computers = Exploit.device.get(lan_address).computers else computers = 0;        if Exploit.device.has(lan_address) and Exploit.device.get(lan_address) then files = Exploit.device.get(lan_address).files else files = 0;        ;        add_line;        printb(("+"   ".quote+" + fif(shells, ("+"shell: ".quote+".c("+"black".quote+") + str(shells.len)).c("+"purple".quote+"), "+"".quote+") + "+" ".quote+" + fif(computers, ("+"computer: ".quote+".c("+"black".quote+") + str(computers.len)).c("+"purple".quote+"), "+"".quote+") + "+" ".quote+" + fif(files, ("+"file: ".quote+".c("+"black".quote+") + str(files.len)).c("+"purple".quote+") + "+"\n".quote+", "+"".quote+")));    end for ;    printb(bar(30));;    return true;end function ;;Exploit.module = {};Exploit.module.library = {};;Exploit.module.get_payloads = function(library, check = 0, find_memory = 0);    database = Session.db.parse("+"exploit".quote+");    library_name = library.lib_name ;    library_version = library.version ;    if not database.len then return false ;    if not database.hasIndex(library_name) then return false ;    if database.hasIndex(library_name) and not database[library_name].hasIndex(library_version) then return false;    if check then return true ;    ;    owned_memory_array = database[library_name][library_version].indexes;    mathes = [];    payload = [];    for memory_address in owned_memory_array;        if not find_memory then ;            payload = payload + database[lib_name][library_version][memory_address];            continue ;        end if ;;        if memory_address == find_memory then ;            payload = database[library_name][library_version][memory_address];            break ;        end if ;    end for ;;    return payload;end function;;Exploit.module.create_exploit = function(payload_arr, memory_address, library_name, library_version);    return {library_version: {memory_address: payload_arr}};end function;;Exploit.module.add_exploit = function(database_entry, library, saved_database = 0, set_db = 1);    add_line ;    printb(("+"storing to ".quote+" + library.lib_name + "+" v".quote+" + library.version).c("+"black black purple".quote+"));    ;    if not saved_database then saved_database = Session.db.parse("+"exploits".quote+");;    library_name = library.lib_name;    library_version = library.version ;    ;    for entry in database_entry ;        ;        if not saved_database.len or (saved_database.len > 0 and not saved_database.hasIndex(library_name)) then saved_database[library_name] = {};        if not saved_database[library_name].len or (saved_database[library_name].len > 0 and not saved_database[library_name].hasIndex(library_version)) then saved_database[library_name][library_version] = {};        //print not saved_database[library_name].len or (not saved_database[library_name].hasIndex(library_version));        ;        printb((("+"adding ".quote+" + str(entry.value.indexes.len) + "+" exploits to ".quote+" + library_name + "+" v".quote+" + library_version).c("+"purple".quote+")).c("+"purple".quote+"));        //saved_database[library_name][library_version] = entry.value ;;        for memory_address in entry.value.indexes;            if not saved_database[library_name][library_version].hasIndex(memory_address) then saved_database[library_name][library_version][memory_address] = [];            saved_database[library_name][library_version][memory_address] = (saved_database[library_name][library_version][memory_address] + entry.value[memory_address]).remove_repeats;        end for ;;    end for ;    if set_db then Session.db.set(saved_database, "+"exploit".quote+");    return saved_database ;end function ;;Exploit.module.get_local_lib = function(library_name);    try_library_arr = Directory.find_file(get_shell.host_computer.File("+"/".quote+"), 0, library_name, 1);    ;    if not try_library_arr.len then return false ;    result = false ;    for library_file in try_library_arr ;        library_file = library_file[0];        if library_file.name == library_name then ;            try_library = include_lib(library_file.path);            if tp(["+"null".quote+", "+"number".quote+"].indexOf(tp(try_library))) == "+"number".quote+" then continue;            result = try_library;            break ;        end if ;    end for ;;    return result;end function ;;;Exploit.module.library.get_metax = function();    return Exploit.module.get_local_lib("+"metaxploit.so".quote+");end function ;;Exploit.module.library.get_crypto = function();    return Exploit.module.get_local_lib("+"crypto.so".quote+");end function ;;Exploit.module.parse_exploits = function(library, database = 0);    exploit_map = {};;    if not database then database = Session.db.parse("+"exploit".quote+");    if database then ;        if database.hasIndex(library.lib_name) then ;            if ((database[library.lib_name].hasIndex(library.version) and database[library.lib_name][library.version].indexes.len > 0) and not Exploit.is_scan_mode()) then ;                memory_address_arr = database[library.lib_name][library.version].indexes;                ;                for address in memory_address_arr ;                    unsafe_value_arr = self.get_payloads(library, 0, address);                    exploit_map[address] = unsafe_value_arr;                end for ;;                if exploit_map.len then return _callback.catch(exploit_map, 1);            end if ;    ;        end if;        print;        printb(("+"[expl][attack][notif]: library ".quote+" + library.lib_name + "+" v".quote+" + library.version + "+" not found in database...".quote+").c("+"black black purple".quote+"));    end if;;    print ;    printb("+"commencing scan...".quote+".c("+"purple".quote+"));    print;;    memory_address_arr = self.library.get_metax().scan(library);    for address in memory_address_arr;        unsafe_value_arr = [];        output = self.library.get_metax().scan_address(library, address);        for line in output.split(c10);            if tp(line.indexOf("+"</b>.".quote+")) == "+"number".quote+" then unsafe_value_arr.push(slice(line, line.indexOf("+"<b>".quote+"), line.indexOf("+"</b>".quote+"))[3:]);        end for ;        exploit_map[address] = unsafe_value_arr;    end for ;;    return _callback.catch(exploit_map, 1);end function ;;Exploit.module.run_exploits = function(payload_arr = [], memory_address, lan_address, library, change_password = 0, database = 0, set_db = 1);    if not payload_arr.len then return false ;    if not database then database = Session.db.parse("+"exploit".quote+");    for payload in payload_arr;        print "+"internal 893: ".quote+"+ change_password;        if change_password then object = library.overflow(memory_address, payload, change_password) else object = library.overflow(memory_address, payload);        if tp(object) == "+"null".quote+" then continue ;        if tp(object) == "+"number".quote+" then ;            printb("+"password changed or firewall bypassed...".quote+".c("+"black".quote+"));            printb(("+"new password: ".quote+"+ change_password).c("+"black black purple".quote+"));            continue ;        end if ;        self.add_exploit(self.create_exploit(payload_arr, memory_address, library.lib_name, library.version), library, database, set_db);        Session.allocate(object, lan_address);        Exploit.device.add(object, lan_address);    end for ;    ;    Exploit.device.align_ip_addresses();    ;    return true;end function;;Exploit.module.grab_ports = function(ip_address, must_match = [], all = 0);    match_arr = [];    remote_router = get_router(ip_address);    if tp(remote_router) == "+"null".quote+" then return false ;    ports_arr = remote_router.used_ports;    if all then return ports_arr;;    for port in ports_arr ;        if tp(must_match.indexOf(str(port.port_number))) == "+"number".quote+" then match_arr.push(port);    end for ;;    return match_arr;end function;;Exploit.module.malware = {};Exploit.module.malware.send = function(shell_instance, malware_src_name, malware_prompt, malware_src_content, rpc_data = {});    try_set_endpoint = Session.rpc.set_endpoint(shell_instance, malware_src_name, malware_src_content);    if not try_set_endpoint.status then return try_set_endpoint;;    try_send_data = Session.rpc.data.send(shell_instance, try_set_endpoint.data, malware_prompt, rpc_data, 1);    return try_send_data;    //use to build trojan and rat commands. trojans are traps, rats are ran by us.;end function ;;Exploit.module.malware.catch = function();    return Session.rpc.data.catch() // callback must accept param custom_obj that houses rpc return data;end function ;;Exploit.scout = function();;end function;;Exploit.attack = function(lan_address, change_password = 0, third_arg);    memory_arr = [];    //we will store mems and payloads by object type ;    //this allows recon command and Exploit.scout to ;    //avoid shell objects because it will only scan;    library = self.get_net_session().dump_lib;    if not self.module.library.get_metax() then return _callback.catch("+"[expl][attack][err]: metaxploit library not found on machine...".quote+");    if tp(Session.machine.ip.get_lan_address_arr().indexOf(Session.machine.ip.get_lan_address())) != "+"number".quote+" then Session.machine.ip.add_lan_address(lan_address);    if tp(self.module.library.get_metax().rshell_server) != "+"list".quote+" then rshell_arr = [] else rshell_arr = Exploit.module.library.get_metax().rshell_server ;;    exploit_map = self.module.parse_exploits(library);    ;    memory_address_arr = exploit_map.data.indexes;;    for address in memory_address_arr ;        self.module.run_exploits(exploit_map.data[address], address, lan_address, library, third_arg) //change_password json;    end for ;    print notify("+"recon for ".quote+" + ("+"'".quote+" + hide_ip(Session.machine.ip.get_pub_address_arr()[-1])+ "+"'".quote+").c("+"black black white".quote+") + "+" @ ".quote+" + ("+"'".quote+" + hide_ip(lan_address) + "+"'".quote+").c("+"black black white".quote+") + "+" completed.".quote+")+c0;    ;    return _callback.catch("+"".quote+", 1);end function;;Usage = {};Usage.usage_object_map = {};Usage.display = function(cmd_name, usage_object);    print;    printb(("+"command name: ".quote+").upper.c("+"black".quote+") + cmd_name.upper.c("+"purple".quote+"));    printb("+"long: ".quote+".upper.c("+"black".quote+") + usage_object.long.c("+"black black purple".quote+"));    printb("+"short: ".quote+".upper.c("+"black".quote+") + usage_object.short.c("+"black black purple".quote+"));    print;    printb("+"usage: ".quote+".upper.c("+"black".quote+"));    for usage_line in usage_object.usage_arr ;        printb("+" ".quote+" + usage_line.c("+"black black purple".quote+"));    end for ;    print ;    printb("+"desc: ".quote+".upper.c("+"black".quote+"));    print "+" ".quote+" + usage_object.desc.c("+"black black purple".quote+");    print;end function ;;Usage.create_usage_object = function(cmd_name, usage_arr, description, long, short);    self.usage_object_map[cmd_name] = {"+"usage_arr".quote+": usage_arr, "+"desc".quote+": description, "+"long".quote+": long, "+"short".quote+": short};    return self.usage_object_map[cmd_name];end function;;Usage.get_usage_object = function(cmd_name) ;    return self.usage_object_map[cmd_name];end function ;;Usage.init = function();    //  {"+"cmd_name".quote+": "+"ls".quote+", "+"usage_arr".quote+": ["+" clear ".quote+", "+" cls ".quote+", "+" cs ".quote+"], "+"desc".quote+": "+"clears terminal screen and displays next input.".quote+", "+"long".quote+": "+"clear".quote+", "+"short".quote+": "+"cls | cs".quote+"};    linux_cmd_arr = [{"+"cmd_name".quote+": "+"clear".quote+", "+"usage_arr".quote+": ["+" clear ".quote+", "+" cls ".quote+", "+" cs ".quote+"], "+"desc".quote+": "+"clears terminal screen and displays next input.".quote+", "+"long".quote+": "+"clear".quote+", "+"short".quote+": "+"cls | cs".quote+"}, {"+"cmd_name".quote+": "+"exit".quote+", "+"usage_arr".quote+": ["+" exit ".quote+"], "+"desc".quote+": "+"leaves the blbx process and exits program.".quote+", "+"long".quote+": "+"exit".quote+", "+"short".quote+": "+"-q".quote+"}, {"+"cmd_name".quote+": "+"ls".quote+", "+"usage_arr".quote+": ["+" ls [<file_path> | <file_name>]".quote+"], "+"desc".quote+": "+"displays files and directories found in a directory.".quote+", "+"long".quote+": "+"ls".quote+", "+"short".quote+": "+"".quote+"}, {"+"cmd_name".quote+": "+"cd".quote+", "+"usage_arr".quote+": ["+" cd [<file_path> | <file_name>] ".quote+", "+" cd ... ".quote+", "+" cd .. ".quote+", "+" cd . ".quote+" , "+" cd ".quote+"], "+"desc".quote+": "+"navigates shell instance to directory.".quote+", "+"long".quote+": "+"cd".quote+", "+"short".quote+": "+"".quote+"}, {"+"cmd_name".quote+": "+"cat".quote+", "+"usage_arr".quote+": ["+" cat [<file_name> | <file_path>] ".quote+"], "+"desc".quote+": "+"displays the contents of a text file on terminal.".quote+", "+"long".quote+": "+"cat".quote+", "+"short".quote+": "+"".quote+"},  {"+"cmd_name".quote+": "+"rm".quote+", "+"usage_arr".quote+": ["+" rm [<file_name> | <file_path>] ".quote+"], "+"desc".quote+": "+"removes file or directory from machine.".quote+", "+"long".quote+": "+"rm".quote+", "+"short".quote+": "+"".quote+"}];    custom_cmd_arr = [{"+"cmd_name".quote+": "+"find".quote+", "+"usage_arr".quote+": ["+" find [<file_name> | <file_path>] OPTION: -content ".quote+"], "+"desc".quote+": "+"recursively finds a file on machine and displays its path and content by option.".quote+", "+"long".quote+": "+"find".quote+", "+"short".quote+": "+"--f".quote+"},  {"+"cmd_name".quote+": "+"apt".quote+", "+"usage_arr".quote+": ["+" apt [-upgrade | -upg] ".quote+", "+" apt [-update | -upd] ".quote+", "+" apt [-addrepo | -ar] ".quote+", "+" apt [-delrepo | -dr] ".quote+", "+" apt [-search | -sch] ".quote+", "+" apt [-show | -shw] ".quote+", "+" apt [-install | -i] ".quote+"], "+"desc".quote+": "+"handles repository commands for local machine.".quote+", "+"long".quote+": "+"apt".quote+", "+"short".quote+": "+"".quote+"},  {"+"cmd_name".quote+": "+"attack".quote+", "+"usage_arr".quote+": ["+" attack <ip_address> OPTION: -port[<port_number>, ...] | -p[...] OPTION: [-scan | -s] -cgp -fw ".quote+"], "+"desc".quote+": "+"attacks target ip address on all ports unless specified. also attacks router and changes password and bypasses firewalls.".quote+", "+"long".quote+": "+"attack".quote+", "+"short".quote+": "+"-atk".quote+"},  {"+"cmd_name".quote+": "+"rat".quote+", "+"usage_arr".quote+": ["+" rat [-rshell | -rsh] ".quote+", "+" rat [-scan_nw | -snw] ".quote+", "+" rat [-dict | -d] ".quote+", "+" rat [-esc | -e] ".quote+", "+" rat -bounce[<lan_address>, <library_name>] | -b[...] ".quote+"], "+"desc".quote+": "+"rat exploit that remotely runs scripts to reverse shell, scan the network, dictionary attack, or escalate permissions.".quote+", "+"long".quote+": "+"rat".quote+", "+"short".quote+": "+"".quote+"}, {"+"cmd_name".quote+": "+"connect".quote+", "+"usage_arr".quote+": ["+" connect <lan_address> OPTION: <as_user> ".quote+"], "+"desc".quote+": "+"initializes the emulated remote shell instance without starting a shell. now you can use linux and exploiting commands on the remote victim.".quote+", "+"long".quote+": "+"connect".quote+", "+"short".quote+": "+"con".quote+"}, {"+"cmd_name".quote+": "+"sweep".quote+", "+"usage_arr".quote+": ["+" sweep <target_amount> OPTION: -port[<port_number>, ...] ".quote+"], "+"desc".quote+": "+"finds random ip addresses to attack or investigate.".quote+", "+"long".quote+": "+"sweep".quote+", "+"short".quote+": "+"sw".quote+"}, {"+"cmd_name".quote+": "+"nmap".quote+", "+"usage_arr".quote+": ["+" nmap <ip_address> ".quote+", "+" nmap <domain_address> ".quote+"], "+"desc".quote+": "+"displays available open and closed ports on a target ip address.".quote+", "+"long".quote+": "+"nmap".quote+", "+"short".quote+": "+"".quote+"}, {"+"cmd_name".quote+": "+"disconnect".quote+", "+"usage_arr".quote+": ["+" disconnect ".quote+"], "+"desc".quote+": "+"exits emulated shell connection and starts operating with local machine objects.".quote+", "+"long".quote+": "+"disconnect".quote+", "+"short".quote+": "+"dc".quote+"}];;;    cmd_arr = linux_cmd_arr + custom_cmd_arr;;    for cmd in cmd_arr ;        self.create_usage_object(cmd.cmd_name, cmd.usage_arr, cmd.desc, cmd.long, cmd.short);    end for ;;    return true ;end function ;;Wifi = {};Wifi.connect = function();    wifi_info=Directory.find_file(get_shell.host_computer.File("+"/".quote+"), 0, "+"Gift.txt".quote+");    co=Exploit.module.library.get_crypto();co.airmon("+"start".quote+", "+"wlan0".quote+");    if tp(co) == "+"null".quote+" then exit "+"*** missing 'crypto.so' library. wifi connection failed ***".quote+".color("+"red".quote+");    try=0;    if tp(wifi_info) == "+"file".quote+" and wifi_info.get_content.split(c10)[0] == "+"Wifi access:".quote+" then;    bssid=wifi_info.get_content.split(c10)[3];    essid=wifi_info.get_content.split(c10)[4];    passwd=wifi_info.get_content.split(c10)[5].split("+": ".quote+")[1];    try=get_shell.host_computer.connect_wifi("+"wlan0".quote+", bssid, essid, passwd);    print notify("+"gift.txt found. attempting connection".quote+")+c0;    if try == 1 then ;print notify("+"connected to '".quote+"+essid+"+"'.".quote+", "+"!".quote+")+c0;return true;end if;    if tp(try) == "+"string".quote+" then ;print notify(try.lower.color("+"black black white".quote+"), "+"?".quote+")+c0;end if;    if tp(try) == "+"null".quote+" then ;print notify(("+"failed to connect to '".quote+"+essid+"+"'".quote+").color("+"black black white".quote+"), "+"?".quote+")+c0;end if;    end if;    if not try then ;print notify("+"'Gift.txt' not found, proceeding...".quote+", "+"!".quote+")+c0;wait(2);end if;;    bl=[];el=[];pl=[];    for i in get_shell.host_computer.wifi_networks("+"wlan0".quote+");    i=i.split("+" ".quote+");    bl.push(i[0]);el.push(i[2]);pl.push(i[1][:-1].to_int);    end for;;    sorted=[];for i in pl;sorted.push(i);end for;sorted.sort;    ind=pl.indexOf(sorted[-1]);    bssid=bl[ind];essid=el[ind];pwr=(300000/pl.sort[-1]);    file_capture=objects.nf(get_shell.host_computer.File("+"/".quote+"), 0, "+"file.cap".quote+");;    if tp(file_capture) != "+"file".quote+" or tp(file_capture) == "+"file".quote+" and tp(co.aircrack(file_capture.path)) == "+"null".quote+" then;;    add_line;    print notify("+" hacking '".quote+"+essid+"+"'. target ack count is ".quote+"+str(round(pwr))+"+". ".quote+", "+"!".quote+")+c0;    add_line;;    try2=co.aireplay(bssid, essid, pwr);    if tp(try2) == "+"string".quote+" then ;print notify("+" ".quote+"+try+"+" ".quote+", "+"?".quote+")+c0;return false;end if;    end if;;    passwd=co.aircrack(objects.nf(get_shell.host_computer.File("+"/".quote+"), 0, "+"file.cap".quote+").path);    try=get_shell.host_computer.connect_wifi("+"wlan0".quote+", bssid, essid, passwd);    if tp(try) == "+"string".quote+" then ;print notify(("+" ".quote+"+try.lower+"+" ".quote+").color("+"black black white".quote+"), "+"?".quote+")+c0;end if;    if tp(try) == "+"null".quote+" then ;print notify(("+" failed to connect to '".quote+"+essid+"+"' ".quote+").color("+"black black white".quote+"), "+"?".quote+")+c0;end if;    if try == 1 then print notify("+" connected to '".quote+"+essid+"+"'. ".quote+", "+"!".quote+")+c0;    wait(3);cs;    return true;end function;;Params = {};Params.extract_type = function(PARAMS, token_type_arr);    instances = [];;    for param_token in PARAMS;        for token_type in token_type_arr;            if param_token.type == token_type then ;                instances.push(param_token);                continue ;            end if;        end for ;    end for ;;    return instances;end function;;Params.extract_flags = function(PARAMS) ;    result_flags = [];    for token in PARAMS ;        if token.type != TokenTypes.Flag then continue ;        result_flags.push(token);    end for;;    return result_flags;end function ;;Params.extract_flag_content = function(flag);    return flag.split("+"\[|\]|\,|\s".quote+").clean(["+"".quote+"]);end function ;;Dia = {};Dia.bridge = {};Dia.bridge.network = {};;Dia.bridge.endpoint = {};;Dia.bridge.endpoint.add_bot = function(shell_instance);    comp_instance = shell_instance.host_computer;    ;end function;;//Internal;"


if active_user != "root" then exit("[blbx]: active user must be root".c("black purple"))

_src_compiler.zip = function()
    

    file_names = _src_compiler.body.indexes 
    file_contents = _src_compiler.body.values
    index = -1

    //build
    //allow_import
    
    for name in file_names 
        index = index + 1
        check_for_file = get_shell.host_computer.File("/root/blackbox/"+name)
        
        if not check_for_file then 
            get_shell.host_computer.touch("/root/blackbox", name)
            file = get_shell.host_computer.File("/root/blackbox/"+name)
            file.set_content(file_contents[index].split(";").join(char(10)))
			if name == "blbx_beta.src" then continue
            get_shell.build(file.path, "/root/blackbox/", 1)
            file.delete //gets rid of source code after build
            continue
        end if  
		
		
        check_for_file.set_content(file_contents[index].split(";").join(char(10)))
		if name == "blbx_beta.src" then continue
        get_shell.build(file.path, "/root/blackbox/", 1)
        check_for_file.delete //gets rid of source code after build
       
    end for

    main_file = get_shell.host_computer.File("/root/blackbox/blbx_beta.src")
    if main_file then 
		get_shell.build(main_file.path, "/root/blackbox")
		main_file.delete
	end if

    //remove imported builds
    for name in file_names 
        name = name[:-4]
		if name == "blbx_beta" then continue
        check_for_file = get_shell.host_computer.File("/root/blackbox/"+name)
        //if check_for_file then check_for_file.delete
    end for 
    
    print
    print "<b><#7A53F6>To move [blbx] to your root folder and rename it, run the following in the terminal: </color><b>"
    print
    print "<b><#7A53F6> --> ' mv /root/blackbox/blbx_beta /root/<custom_name> '</color><b>"
    print

end function

_src_compiler.zip()